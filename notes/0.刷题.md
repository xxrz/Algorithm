# 刷题

## 剑指offer

### - 排序

- [21. 调整数组顺序使奇数位于偶数前面](https://github.com/CyC2018/CS-Notes/blob/master/notes/21. 调整数组顺序使奇数位于偶数前面.md)

  - 暴力解法: 复制数组，计算奇数的个数

    时间复杂度：O(n)，空间复杂度：O(n)

    ```java
    public int[] reOrderArray(int[] array){
            // 奇数个数
            int oddCnt = 0;
            for (int x : array)
                if (!isEven(x))
                    oddCnt++;
            
            int[] help = array.clone();
            int i = 0;
            for (int num : help) {
                if (!isEven(num))
                    //奇数
                    array[i++] = num;
                else
                    //偶数
                    array[oddCnt++] = num;
            }
            return array;
        }
    ```

  - 冒泡法:利用冒泡排序的想法，为偶数则向后冒

    时间复杂度：O(n^2)，空间复杂度：O(1)

  ```java
  public class Solution {
      //利用冒泡排序的想法，为偶数则向后冒
      public int[] reOrderArray (int[] array) {
          // write code here
          if(array==null || array.length<2){
              return array;
          }
          
          for(int i = 0;i < array.length;i++){
              for(int j = 1;j<array.length-i;j++){
                  if(isEven(array[j-1])&&!isEven(array[j])){
                      swap(array,j-1,j);
                  }
              }
          }
          return array;
      }
      
      public static void swap(int[] arr,int i,int j){
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
      }
      
  //     public static boolean isEven(int num){
  //         if( num % 2 == 0){
  //             return true;
  //         }
  //         else
  //             return false;
  //     }
      public static boolean isEven(int num){
          return num % 2 == 0;
      }
  }
  ```

- [45. 把数组排成最小的数](https://github.com/CyC2018/CS-Notes/blob/master/notes/45. 把数组排成最小的数.md)

  - 快排+利用比较器

  ```java
  //利用快排的思想,划分成左右两个部分
      //找一个基准，左边放拼接起来小的数，右边放拼接起来大的数
      public String PrintMinNumber(int [] numbers) {
          if(numbers==null ||numbers.length<1)
              return "";
          //转为字符串数组
          String [] stringArr = new String[numbers.length];
          for(int i=0;i<numbers.length;i++){
              stringArr[i] = String.valueOf(numbers[i]);
          }
          
          //利用快排
          quickSort(stringArr,0,stringArr.length-1);
          
          //转为字符串，StringBuilder比String更通用，可变，快速且节省空间
          StringBuilder res = new StringBuilder();
          for(String s:stringArr){
              res.append(s);
          }
          
          return res.toString();
      }
      
      public void quickSort(String [] numbers,int L,int R) {
          //递归停止条件
          if(L>=R){
              return;
          }
          int mid = partition(numbers,L,R);
          quickSort(numbers, L , mid-1);
          quickSort(numbers, mid + 1 ,R);
          
      } 
      
      public static int partition(String []numbers,int L,int R){
          if(L>R)
              return -1;
          if(L==R)
              return L;
          int less = L-1;
          int i = L;
          
          String p = numbers[R];
          while(i < R){
              if((numbers[i]+p).compareTo(p+numbers[i]) < 0){
                  swap(numbers,i,++less);
              }
              i++;
          }
          swap(numbers,R,++less);
          return less;
      }
     
      public static void swap(String[] numbers,int i,int j){
          String tmp = numbers[i];
          numbers[i] = numbers[j];
          numbers[j] = tmp;
      }
  ```

  - 调用

  ```java
  public String PrintMinNumber(int [] numbers) {
          if(numbers==null || numbers.length<1 ){
              return "";
          }
          
          //转为字符串
          String[] strs =  new String[numbers.length];
          for(int i = 0;i<numbers.length;i++){
              strs[i] = numbers[i] + "";
          }
          
          //定义字符串排序,比较器
          Arrays.sort(strs,(s1,s2)->(s1+s2).compareTo(s2+s1));
          String res = "";
          for(String str:strs){
              res = res + str;
          }
          return res;
      }
  ```

  

- [51. 数组中的逆序对](https://github.com/CyC2018/CS-Notes/blob/master/notes/51. 数组中的逆序对.md):利用归并排序，遍历一次知道所有数据状况

  - 正着来：nums[i] > nums[j]，说明 nums[i...mid] 都大于 nums[j]

  ```java
      
  // nums[i] > nums[j]，说明 nums[i...mid] 都大于 nums[j]
  	int cnt=0;
      public int InversePairs(int [] array) {
          if(array.length != 0){
              divide(array,0,array.length-1);
          }
          return cnt;
      }
      public void divide(int[] array,int start,int end){
          //递归终止条件
          if(start >= end)   return;
          //取中
          int mid=start+(end-start)/2;
          //分
          divide(array,start,mid);
          divide(array,mid+1,end);
          //治
          merge(array,start,mid,end);
      }
      public void merge(int[] array,int start,int mid,int end){
          //临时数组
          int[] tmp=new int[end-start+1];
          //i和j表示两个分数组的左下标，k表示临时数组的当前下标
          int i=start,j=mid+1,k=0;
          while(i<=mid && j<= end){
              //如果前小于后，则存前，前右移
              if(array[i]<=array[j]){
                  tmp[k++]=array[i++];
              }
              //如果前大于后，则存后，后右移-------***此时存在逆序对，要进行比较
              else{
                  tmp[k++]=array[j++];
                  //如果此时前大于后，那么现有前到最后的元素都会大于后
                  cnt=(cnt+mid-i+1)%1000000007;
              }
          }
          //未遍历完的直接放在右侧
          while(i<=mid){
              tmp[k++]=array[i++];
          }
          while(j<=end){
              tmp[k++]=array[j++];
          }
          //将临时数组的值覆盖原来数组
          for( k=0;k<tmp.length;k++){
              array[start+k]=tmp[k];
          }
      }
  ```

  - 反着来：

    nums[i] > nums[j]，说明 nums[mid...j] 都小于 nums[j]

    ```java
    int count = 0;
    public int InversePairs(int [] array) {
            if(array != null)
                mergeSort(array,0,array.length-1);
            return count;
        }
        
    public void mergeSort(int []array,int L,int R){
        if(L>=R)
            return;
        int mid = L + ((R-L)>>1);
        mergeSort(array,L,mid);
        mergeSort(array,mid+1,R);
        merge(array,L,mid,R);
    }
    
    public void merge(int [] array,int L,int mid,int R){
        //要反着来，因为选择的是比当前值小的数，从大到小排，最后下标好减
        // nums[i] > nums[j]，说明 nums[mid...j] 都小于 nums[j]
        int p1 = mid,p2 = R ;
        int[] help = new int[R-L+1];
        int index = help.length-1;
        while(p1>=L && p2 >= mid+1){
            if(array[p1] > array[p2]){
                help[index--] = array[p1--];
               //不能写在最后的返回，会出错
                count = (count + p2-mid)%1000000007;
            }else{
                help[index--] = array[p2--];
            }
            
        }
        
        while(p1>=L){
            help[index--] = array[p1--];
        }
        
        while(p2>=mid+1){
            help[index--] = array[p2--];
        }
        
        for(int i=0;i < help.length;i++){
            array[L+i] = help[i];
        }
    }
    ```

- 3.数组中的重复数字

  - 数组

  ```java
  public int duplicate (int[] numbers) {
          // write code here
          int[] res = new int[numbers.length];
          //由于所有数字在0-n-1内，可将原数组中每一个数组当做新数组的下标
          //新数组存次数
          for(int num:numbers){
              res[num]++;
              if(res[num]==2)
                  return num;
          }
          return -1;
      }
  ```

  - HashSet

  ```java
  //利用hashSet
      public int duplicate (int[] numbers) {
          // write code here
          HashSet<Integer> hashset = new HashSet<>();
          for(int num:numbers){
              if(hashset.contains(num))
                  return num;
              else
                  hashset.add(num);
          }
          return -1;
      }
  
  ```

4. #### [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

   - 哈希表

   ```java
   public int findRepeatNumber(int[] nums) {
           HashSet<Integer> hashset = new HashSet<Integer>();
           for(int num:nums){
               if(hashset.contains(num)){
                   return num;
               }else{
                   hashset.add(num);
               }
           }
           return -1;
       }
   ```

5. #### [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

   ```java
   public static boolean findNumberIn2DArray(int[][] matrix, int target) {
           if (matrix==null || matrix.length < 1)
               return false;
           //行
           int hlength  = matrix.length;
           //列
           int llength = matrix[0].length;
   
           int i = 0,j = llength-1;
           while(i < hlength && j>=0){
               if (j >=0 && matrix[i][j] < target){
                   i++;
               }
               if (i < hlength && matrix[i][j] > target){
                   j--;
               }
               if (j >=0 && i < hlength && matrix[i][j] == target){
                   return true;
               }
           }
           return false;
       }
   ```

#### 6. [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

```java
public String replaceSpace(String s) {
        StringBuilder tmp = new StringBuilder();
        char[] cs = s.toCharArray();
        for(int i = 0; i < cs.length; i++ ){
            if(!Character.isSpace(cs[i])){
                tmp.append(cs[i]);
            }else{
                tmp.append("%20");
            }
        }
        return tmp.toString();
    }
```

#### 7. [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

 - 哈希表

   ```java
       public int majorityElement(int[] nums) {
           if(nums==null || nums.length < 1)
               return 0;
   
   
           int cnt = nums.length / 2;
           Map<Integer,Integer> hashmap = new HashMap<Integer,Integer>();
           for(int num:nums){
               if(hashmap.containsKey(num)){
                   if(hashmap.get(num)==cnt){
                       return num;
                   }else{
                       hashmap.put(num,hashmap.get(num) + 1);
                   }
               }
               else{
                   hashmap.put(num,1);
               }
           }
           return nums[cnt];
       }
   ```

   

 - 众数算法

   ![众数](\appendix\众数.png)

```java
public int majorityElement(int[] nums) {
        if(nums==null || nums.length < 1)
            return 0;
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
```

#### [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

```java
    public static int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length <1) {
            return new int[0];
        }

        //创建大根堆
        PriorityQueue<Integer> q = new PriorityQueue<Integer>(new Comparator<Integer>(){
            public int compare(Integer a, Integer b){
                return b - a;
            }
        });

        //维护k个大小的大根堆
        for(int num:arr){
            if(q.size() < k){
                q.offer(num);
            }else if(num < q.peek()){
                q.poll();
                q.offer(num);
            }
        }

        //返回堆元素
        int[] res = new int[q.size()];
        int idx = 0;
        for(int num: q) {
            res[idx++] = num;
        }
        return res;
    }
```

- 快速选择

  ```java
      // //快速选择
      public static int[] getLeastNumbers(int[] arr, int k) {
          if (k == 0 || arr.length == 0) {
              return new int[0];
          }
          // 最后一个参数表示我们要找的是下标为k-1的数
          return quickSearch(arr, 0, arr.length - 1, k - 1);
      }
  
      private static int[] quickSearch(int[] nums, int L, int R, int k) {
          // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；
          int res = partition(nums, L, R);
          if (res == k) {
              return Arrays.copyOf(nums, res + 1);
          }
          // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。
          return res > k? quickSearch(nums, L, res - 1, k): quickSearch(nums, res + 1, R, k);
      }
      public static int partition(int[] arr,int L,int R){
          int less = L-1;
          int pivot = arr[R];
          int index = L;
  
          while(index < R){
              if(arr[index] < pivot){
                  swap(arr,++less,index);
              }
              index++;
          }
          swap(arr,++less,R);
          return less;
      }
  
      public static void swap(int[] arr,int i,int j){
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
      }
  ```

  

#### [剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

- 排序 + 规则

  ```java
      public boolean isStraight(int[] nums) {
          if(nums==null || nums.length < 5){
              return false;
          }
          Arrays.sort(nums);
          int zeroCnt = 0;
          int diff = 0;
          int i = 0;
          while(i < nums.length-1){
              if (nums[i]==0) {
                  zeroCnt++;
                  i++;
              }else if(nums[i]==nums[i+1] + 1){
                  i++;
              }else if(nums[i] != nums[i+1] +1){
                  diff = nums[i+1]-(nums[i]+1);
                  if(diff==-1 || diff > zeroCnt){
                      return false;
                  }else{
                      i++;
                      zeroCnt = zeroCnt - diff;
                  }
              }
          }
          return true;
      }
  ```

  

- 优化（排序 + 规则）

  优化原则：存在顺子的条件：1.除零外没有任何重复的数字；2.最大值-最下值<5（除0外）

  ```java
      //排序 + 除零外<5
      public boolean isStraight(int[] nums){
          if(nums==null || nums.length < 5){
              return false;
          }
          Arrays.sort(nums);
          int min = 0;
          int i = 0;
          while(i < nums.length-1){
              //
              if(nums[i]==0)
                  min++;
              //注意此处是else if 不是if 
              else if(nums[i]==nums[i+1])
                  return false;
              i++;
          }
          return nums[nums.length-1]-nums[min]<5;
      }
  ```

  

- set + 遍历

  ```java
      //set + 遍历
      //原则：存在顺子的条件：1.除零外没有任何重复的数字；2.最大值-最下值<5（除0外）
      public boolean isStraight(int[] nums) {
          if(nums==null || nums.length < 5){
              return false;
          }
          //min的初始值要注意，不能仅初始化为0，如果数组中没有0就出错了
          int max = 0,min = 14;
          Set<Integer> set = new HashSet<Integer>();
          for(int num:nums){
              if(num==0)
                  continue;
              if(set.contains(num))
                  return false;
              max = Math.max(num,max);
              min = Math.min(num,min);
              set.add(num);
          }
          return max-min < 5;
      }
  ```

  #### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)
  
  - 字符串构造器
  
  ```java
   //原则：利用字符串构造器，和系统排序
      public String minNumber(int[] nums) {
          if(nums ==null || nums.length < 1){
              return "";
          }
  
          String[] s = new String[nums.length];
          //将数据转为字符串
          for(int i = 0;i < nums.length; i++){
              s[i] = nums[i] +"";
          }
          
          //字符串compareTo的比较器
          Arrays.sort(s,(s1,s2)->(s1+s2).compareTo(s2+s1));
  
              StringBuilder确实会快一点
          StringBuilder res = new StringBuilder();
          for(String str:s){
              res.append(str);
          }
  
          // String res = "";
          // for(String str:s){
          //     res += str;
          // }
  
          return res.toString();
          // return res;
      }
  ```
  
  - 快排
  
  ```java
  public String minNumber(int[] nums) {
          if(nums ==null || nums.length < 1){
              return "";
          }
  
          String[] str = new String[nums.length];
          //将数据转为字符串
          for(int i = 0;i < nums.length; i++){
              str[i] = nums[i] +"";
          }
          quickSort(str,0,nums.length-1);
  
          StringBuilder res = new StringBuilder();
          for(String s:str){
              res.append(s);
          }
  
          return res.toString();
      }
  
      public void quickSort(String[] nums, int L,int R){
          if(L>=R)
              return;
          int mid = partition(nums,L,R);
          quickSort(nums,L,mid);
          quickSort(nums,mid+1,R);
      }
  
      public int partition(String[] nums,int L,int R){
          swap(nums,(int)(Math.random()*(R-L+1)+L),R);
          String pivot = nums[R];
          int less = L-1;
          int index =L;
          while(index < R){
              //注意字符串的比较的写法
              if((nums[index]+pivot).compareTo(pivot+nums[index]) < 0){
                  swap(nums,++less,index++);
              }else{
                  index++;
              }
          }
          swap(nums,++less,R);
          return less;
      }
  
      public void swap(String[] nums,int i,int j){
          String tmp = nums[i];
          nums[i] = nums[j];
          nums[j] = tmp;
      }
  ```
  
  #### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)
  
  - 构建两个堆，一个大根堆，一个小根堆
  
    <img src="appendix\二堆.png" alt="二堆" style="zoom:150%;" />
  
    ```java
    class MedianFinder {
    
        /** initialize your data structure here. */
    
        //建两个堆
        Queue<Integer> A, B;
    
        //算法：
        public MedianFinder() {
            A = new PriorityQueue<>(); // 小顶堆，保存较大的一半，保存较多的一般，A
            B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半,B
        }
        
        public void addNum(int num) {
            //说明是奇数，向B添加元素
            //先插入A，再向B中添加A的堆顶
            if(A.size()!=B.size()){
                A.add(num);
                B.add(A.poll());
            //说明是偶数，向A添加元素
            //先插入B，再向A中添加B的堆顶
            }else{
                B.add(num);
                A.add(B.poll());
            }
        }
        
        public double findMedian() {
    //注意写成2.0
            return A.size()!=B.size()? A.peek():(A.peek()+B.peek())/2.0;
        }
    }
    ```

### -哈希表

#### [面试题50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

- 暴力：两次遍历

  ```java
  public char firstUniqChar(String s) {
          //进入hashmap
          HashMap<Character,Integer> map = new HashMap<Character,Integer>();
          char[] cs = s.toCharArray();
          for(char str:cs){
              map.put(str,map.getOrDefault(str,0)+1);
          }
  
          //遍历，确定第一个
          for(char str:cs){
              if(map.get(str)==1){
                  return str;
              }
          }
          //注意单空格（char），单引号
          return ' ';
      }
  ```

- 优化上一种方法

  ```java
      //优化方法一
      //键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 -1−1（如果该字符出现多次）
      public char firstUniqChar(String s) {
          HashMap<Character,Integer> map = new HashMap<Character,Integer>();
          for(int i = 0;i < s.length();i++){
              if(map.containsKey(s.charAt(i))){
                  map.put(s.charAt(i),-1);
              }else{
                  map.put(s.charAt(i),i);
              }
          }
  
          //找出其中不为 -1−1 的最小值，即为第一个不重复字符的索引，然后返回该索引对应的字符
          
          //注意哈希表示无序的，遍历哈希表也无序
          int min = s.length();
          for(Map.Entry<Character,Integer> entry:map.entrySet()){
              int v = entry.getValue();
              if(v!=-1 && v < min){
                  min = v;
              }
          }
  
          return min==s.length()? ' ':s.charAt(min);
      }
  ```

- 有序哈希表

  ```java
  public char firstUniqChar(String s) {
          Map<Character,Boolean> dic = new LinkedHashMap<>();
          char[] cs = s.toCharArray();
          for (char c :cs){
              dic.put(c,!dic.containsKey(c));
          }
  
          for(Map.Entry<Character,Boolean> entry:dic.entrySet()){
              if(entry.getValue())
                  return entry.getKey();
          }
  
          return ' ';
      }
  ```

### 二分

​	[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```java
public int missingNumber(int[] nums) {
        //思路：利用二分+值和下标对应关系
        //不缺失：nums[i]=i
        //缺失：nums[i]!=i
        int p1 = 0;
        int p2 = nums.length-1;
        int mid;
        while(p1 <= p2){
            mid = (p1 + p2)/2;
            //说明缺失的在后半段
            if (nums[mid]==mid){
                p1 = mid + 1;
            //说明缺失的在前半段
            }else{
                p2 = mid - 1;
            }
        }
        return p1;

    }
```

#### [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

```java
    public int[] twoSum(int[] nums, int target) {
        //对撞双指针（理论性证明）
        int p1 = 0,p2 = nums.length-1;
        int[] res = new int[2];
        //对撞 所以不能相等
        while(p1 < p2){
            if(nums[p1]+nums[p2] == target){
                return  new int[] { nums[p1], nums[p2] };
            }else if(nums[p1]+nums[p2] < target){
                p1++;
            }else{
                p2--;
            }
        }
        return new int[0];
    }
```

#### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

- ```java
  //使用二分法分别找到 左边界 left和 右边界 right
      //清晰一些，确认边界条件或者返回值，自己走一个例子
      public int search(int[] nums,int target){
          int L = 0,R  = nums.length-1;
          int right ,left;
          //查找右边界
          while(L<=R){
              int mid = L+(R-L)/2;
              //考虑相等时，右边界应该在[mid+1,R]
              if(nums[mid] <= target){
                  L = mid + 1; 
              }
              else{
                  R = mid - 1;
              }
          }
          right  =  L;
  
          //优化提前返回,如果右边界在最左边，则该数不存在
          if(R >= 0 && nums[R] != target) return 0;
  
          L = 0;
          R  = nums.length-1;
          //查找左边界
          while(L<=R){
              int mid = L+(R-L)/2;
              //考虑相等时，做边界应该在[L,mid-1]
              if(nums[mid] < target){
                  L = mid + 1; 
              }
              else{
                  R = mid - 1;
              }
          }
          left = R;
  
          return right-left-1;
  
      }
  ```

- 优化

  ```java
      //使用二分法分别找到 左边界 left和 右边界 right
      public int search(int[] nums, int target) {
          int R = helper(nums,target);
          int L = helper(nums,target-1);
          return R-L;
  
      }
  
      //二分查找
      public int helper(int[]nums, int target){
          int L = 0;
          int R = nums.length-1;
          while(L<=R){
              int mid = L + (R-L)/2;
              if(nums[mid] <= target){
                  L = mid +1;
              }else{
                  R = mid -1;
              }
          }
          //此数大1
          return L;
      }
  ```

#### [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

- 暴力

  ```java
  
      // 暴力
      public int minArray(int[] numbers) {
          int i = 0;
          while(i < numbers.length-1){
              if(numbers[i]<=numbers[i+1] ) i++;
              else return numbers[i + 1];
          }
          return numbers[0];
      }
  ```

- 双指针

  ```java
      // 双指针
      public int minArray(int[] numbers) {
          int i = 0,j = numbers.length-1;
          while(i < j && i<numbers.length &&j>=0){
              if(numbers[i]<=numbers[i+1] ) i++;
              else return numbers[i + 1];
              if(numbers[j]>=numbers[j-1]) j--;
              else return numbers[j];
          }
          return numbers[0];
      }
  ```

- 二分

  ```java
      //二分
      //思路：旋转数组旋转点左侧比大于右侧
      //旋转点一定在右侧，一定会比最右侧值小
      //i = 0,j = length-1
      //mid < j :旋转点在左
      //mid > j :旋转点在右
      //mid = j :无法判断，但根据性质可以顺序查找
      public int minArray(int[] numbers){
          if(numbers==null ||numbers.length < 1){
              return -1;
          }
  
          int i = 0,j = numbers.length-1;
          while(i<j){
              int mid = i + ((j-i)>>1);
              if(numbers[mid] < numbers[j]){
                  //注意：4,5,1,2,3
                  j = mid;
              }else if(numbers[mid] > numbers[j]){
                  i = mid + 1;
              }else{
                  j--;
              }
          }
          return numbers[i];
      }
  ```

  

### -双指针

#### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

- 倒着遍历字符串，确认每个单词的左右边界（双指针），加入Res

  还要注意多个空格的问题

  ```java
      public String reverseWords(String s) {
          //先去掉多余的空格
          s = s.trim();
          int L = s.length()-1,R = L;
          StringBuilder res = new StringBuilder();
          while(L >= 0){
              //找左边界
              while(L>=0 && s.charAt(L)!=' '){
                  L--;
              }
              //添加单词
              res.append(s.substring(L+1,R+1)+" ");
              //跳过空格
              while(L>=0 && s.charAt(L)==' '){
                  L--;
              }
              R= L;// R 指向下个单词的尾字符
          }
          return res.toString().trim();
      }
  
  ```

- 利用系统库

  ```java
  //利用系统库
      public String reverseWords(String s) {
          String[] s1 = s.trim().split(" ");
          StringBuilder res = new StringBuilder();
          for(int i = s1.length-1; i>=0 ;i--){
              //查看是否是空格
              if(s1[i].equals("")) continue;
              res.append(s1[i]+" ");
          }
          return res.toString().trim();
      }
  ```

#### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```java
    //暴力
    public String reverseLeftWords(String s, int n) {
        StringBuilder tmp = new StringBuilder();
        StringBuilder res = new StringBuilder();
        char[] cs = s.toCharArray();
        for(int i = 0;i < cs.length; i++){
            if(i < n){
                tmp.append(cs[i]);
            }
            else{
                res.append(cs[i]);
            }
        }
        res.append(tmp);
        return res.toString();

    }

    //字符串切片
    public String reverseLeftWords(String s, int n) {
        return s.substring(n,s.length())+ s.substring(0,n);
    }

    //空间优化
    public String reverseLeftWords(String s, int n) {
        StringBuilder res = new StringBuilder();
        for(int i = n; i < s.length(); i++)
            res.append(s.charAt(i));
        for(int i = 0; i < n; i++)
            res.append(s.charAt(i));
        return res.toString();
    }

    //取余操作简化代码
    public String reverseLeftWords(String s, int n) {
        StringBuilder res = new StringBuilder();
        for(int i = n; i < n + s.length(); i++)
            res.append(s.charAt(i % s.length()));
        return res.toString();
    }
```

#### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

- 求和公式+求根公式

  ![57](appendix\57_求和公式.png)

  ```java
      //求和公式法
      //i<j 且j为整数
      public int[][] findContinuousSequence(int target) {
           int i = 1;
           //j为数组中最大的数,要保留小数
           double j = 2.0;
           List<int []> res = new ArrayList<>();
           //注意条件，不是i < target
           while(i < j){
               j = (-1 + Math.sqrt(1+4*(2*target + (long)i*i-i)))/2;
               if(i < j && j == (int)j){
                   int[] ans = new int[(int)j-i+1];
                   //注意此处的写法
                   for(int k = i;k <= (int)j;k++){
                       ans[k-i] = k;
                   }
                   res.add(ans);
               }
               i++;
           }
           return res.toArray(new int[0][]);
      }
  ```

- 滑动窗口：最大的特点是只能向右滑（双指针）

  ```java
      //滑动窗口
      //左边界，右边界，只往右边滑，而不是来回滑
      //滑动窗口只有 右边界向右移动（扩大窗口） 和 左边界向右移动（缩小窗口）
      //时间复杂度：只向右滑，O(N)
      public int[][] findContinuousSequence(int target) {
          int l = 1,r = 2;
          int sum = l + r;
          List<int []> res = new ArrayList<>();
          while(l < r){
              if(sum==target){
                  int[] ans = new int[r-l+1];
                  for(int k = l;k <= r;k++){
                      ans[k-l] = k;
                  }
                  res.add(ans);
              }
              if(sum >= target){
                  sum = sum - l;
                  l++;
              }else{
                  r++;
                  sum = sum + r;
              }
          } 
          return res.toArray(new int[0][]);
      }
  ```

  



### - 链表

总结：栈，双指针，递归

#### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

- 双指针（迭代）

  ```java
  public ListNode reverseList(ListNode head) {
          ListNode cur = null;//存当前节点
          ListNode pre = head;//存当前节点的下一个节点
          ListNode tmp = null;//先保存当前节点的下一个节点
  
          while(pre!=null){
              tmp = pre.next;
              pre.next = cur;
              cur = pre;
              pre = tmp;
          }
  
          //出来的时候pre==null
          return cur;
      }
  ```

- **递归**

  1） 如果一个问题 A 可以分解为若干子问题 B、C、D，**你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A*

  2） 所有的递归问题都可以用递推公式来表示

  

  **example**1

  - 问题：逆序打印一个数组
  - 递推公式：

  ```reasonml
  假设令F(n)=逆序遍历长度为n的数组
  那么F(n)= 打印数组中下标为n的元素 + F(n-1)
  ```

  - 终止条件：

  ```kotlin
  if (n <0) return ;
  ```

  - 递归代码：

  ```reasonml
  public void Print(int[] nums,int n){
      if(n<0) return;
      System.out.println(nums[n]);
      Print(nums,n-1);
  }
  ```

  **example2**

  - 问题：二叉树的先序遍历
  - 递推公式：

  ```reasonml
  令F(Root)为问题:遍历以Root为根节点的二叉树，
  令F(Root.left)为问题:遍历以F(Root.left)为根节点的二叉树
  令F(Root.right)为问题:遍历以F(Root.right)为根节点的二叉树
  那么其递推公式为：
  F(Root)=遍历Root节点+F(Root.left)+F(Root.right)
  ```

  - 递归代码：

  ```reasonml
  public void preOrder(TreeNode node){
      if(node==null) return;
      System.out.println(node.val);
      preOrder(node.left);
      preOrder(node.righr);
  }
  ```

  **example3**(此题)

  - 问题：单向链表的反转
  - 递推公式：

  ```reasonml
  令F(node)为问题:反转以node为头节点的单向链表；
  一般，我们需要考虑F(n)和F(n-1)的关系，那么这里，如果n代表以node为头节点的单向链表，那么n-1就代表以node.next为头节点的单向链表.
  所以，我们令F(node.next)为问题：反转以node.next为头节点的单向链表；
  那么，F(node)和F(node.next)之间的关系是？这里我们来简单画个图，假设我们反转3个节点的链表：
  1 -> 2 -> 3
  那么，F(node=1)=F(node=2)+?
  
  这里假设子问题F(node=2)已经解决，那么我们如何解决F(node=1)
  
  很明显，我们需要反转node=2和node=1， 即 node.next.next=node; 同时 node.next=null;
  所以，这个问题就可以是：F(node=1)=F(node=2)+ 反转node=2和node=1
  ```

  - 递归代码：

  ```java
  //递归
      public ListNode reverseList(ListNode head){
          //终止条件
          if(head==null || head.next==null){
              return head;
          }
  
          //f(node=2)
          ListNode node = reverseList(head.next);
  
          //反转操作
          head.next.next = head;
          head.next = null;
  
          return node;
      }
  ```

#### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

- 先反转链表 再打印（太麻烦了）

  ```java
      //先反转链表，再打印
      public int[] reversePrint(ListNode head) {
          List<Integer> list = new ArrayList<Integer>();
          ListNode res = reverseList(head);
          for(ListNode cur = res;cur!=null;cur = cur.next){
              list.add(cur.val);
          }
  
          //可变数组转数组
          int[] arrs = new int[list.size()];
          for(int i = 0;i < list.size();i++){
              arrs[i] = list.get(i);
          }
          return arrs;
  
      }
  
      public ListNode reverseList(ListNode head){
          if(head ==null ||head.next==null)
              return head;
          
          ListNode node = reverseList(head.next);
          head.next.next = head;
          head.next = null;
  
          return node;
      }
  ```

- 直接递归打印(分解问题，注意递归条件)

  ```java
      //递归
      List<Integer> tmp = new ArrayList<Integer>();
      public int[] reversePrint(ListNode head) {
          recur(head);
          int[] arrs = new int[tmp.size()];
          for(int i = 0;i < tmp.size();i++){
              arrs[i] = tmp.get(i);
          }
          return arrs;
      }
  
      public void recur(ListNode head){
          if(head==null)
              return;
          recur(head.next);
          tmp.add(head.val);
      }
  ```

- 辅助栈

  ```java
  //链表特点： 只能从前至后访问每个节点。
  //题目要求： 倒序输出节点值。
  //这种 先入后出 的需求可以借助 栈 来实现。
  ```

  ```java
      public int[] reversePrint(ListNode head){
          LinkedList<Integer> stack = new LinkedList<Integer>();
          ListNode cur = head;
          while(cur!=null){
              stack.addLast(cur.val);
              cur = cur.next;
          }
  
          int[] res = new int[stack.size()];
          for(int i=0;i<res.length;i++){
              res[i] = stack.removeLast();
          }
          return res;
      }
  ```

#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

- 辅助栈

  ```java
  //辅助栈
      public ListNode getKthFromEnd(ListNode head, int k) {
          LinkedList<ListNode> stack = new LinkedList<ListNode>();
          while(head!=null){
              stack.addLast(head);
              head = head.next;
          }
  
          ListNode newhead = head;
          //因为长度会变,所以该值要放在外面
          int length = stack.size();
          for(int i = stack.size()-1; i >= 0;i--){
              int index = length-i;
              // System.out.println("i"+i);
              // System.out.println("index"+index);
              if(length-i==k){
                  return stack.removeLast();
              }else{
                  stack.removeLast();
              }
          }
  
          return new ListNode();
      }
  ```

- 快慢指针

  ```java
      //双指针
      public ListNode getKthFromEnd(ListNode head, int k) {
          ListNode slow = head,fast = head;
          //快指针先走K步
          for(int i = 0; i<k;i++){
              fast = fast.next;
          }
          //快慢指针一起走，直到快指针为NULL
          while(fast!=null){
              slow = slow.next;
              fast = fast.next;
          }
          return slow;
      }
  ```

  #### [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

  - 迭代，伪链头

    ```java
    
       public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            //创建伪代码头,否则无法用next
            ListNode dum = new ListNode(0);
            ListNode cur = dum;
            while(l1!=null && l2!=null){
                if(l1.val <= l2.val){
                    cur.next = l1;
                    l1 = l1.next;
                }else{
                    cur.next = l2;
                    l2 = l2.next;
                }
                //注意新链表的当前指针也要移动
                cur = cur.next;
            }
            if(l1!=null){
                cur.next = l1;
            }
    
            if(l2!=null){
                cur.next = l2;
            }
    
            return dum.next;
        }
    ```

  - 递归(不是特别好理解)

    ```java
        //递归,不是很好理解
    // 特判：如果有一个链表为空，返回另一个链表
    // 如果l1节点值比l2小，下一个节点应该是l1，应该return l1，在return之前，指定l1的下一个节点应该是l1.next和l2俩链表的合并后的头结点
    // 如果l1节点值比l2大，下一个节点应该是l2，应该return l2，在return之前，指定l2的下一个节点应该是l1和l2.next俩链表的合并后的头结点
    
        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if(l1==null ||l2==null){
                return l1!=null?l1:l2;
            }
    
            if(l1.val <= l2.val){
                l1.next = mergeTwoLists(l1.next,l2);
                return l1;
            }else{
                l2.next = mergeTwoLists(l2.next,l1);
                return l2;
            }
    
        }
    ```

#### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

```java
    public ListNode deleteNode(ListNode head, int val) {
        //考虑可能会删除第一个节点，所以用了伪头
        ListNode dum = new ListNode(0);
        dum.next = head;
        ListNode cur = head,parent = dum;
        while(cur!=null){
            if(cur.val!=val){
                parent.next = cur;
                cur = cur.next;
                parent = parent.next;
            }else{
                parent.next = cur.next;
                cur = null;
                break;
            }
        }
        return dum.next;
    }
```

#### [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

- 哈希表法

  ```java
      // 哈希集合法
      // 首先遍历链表 \textit{headA}headA，并将链表 \textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中
      public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
          Set<ListNode> tmp = new HashSet<ListNode>();
          ListNode p1 = headA, p2 = headB;
          while(p1!=null){
              tmp.add(p1);
              p1 = p1.next;
          }
          while(p2!=null){
              if(tmp.contains(p2)){
                  return p2;
              }else{
                  p2 = p2.next;
              }
          }
          return null;
      }
  ```

- 双指针相遇法

  ```java
  //双指针浪漫相遇法
      //两个链表长度分别为L1+C、L2+C， C为公共部分的长度
      // 第一个人走了L1+C步后，回到第二个人起点走L2步；
      // 第2个人走了L2+C步后，回到第一个人起点走L1步。 
      // 当两个人走的步数都为L1+L2+C时就两个人就相爱了
      public ListNode getIntersectionNode(ListNode headA,ListNode headB){
          //处理特殊情况
          if(headA==null || headB==null){
              return null;
          }
  
          ListNode p1 = headA, p2 = headB;
          while(p1!=p2){
              if(p1!=null){
                  p1 = p1.next;
              }else{
                  p1 = headB;
              }
  
              if(p2!=null){
                  p2 = p2.next;
              }else{
                  p2 = headA;
              }
  
          }
  
          return p1;
          
      }
  ```

#### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

- 普通链表的复制,同时说明问题难度

  ```java
      //普通链表的复制
      public Node copyList(Node head) {
          Node dum = new Node(0);
          Node pre = dum;
          Node cur = head;
          while(cur!=null){
              Node node = new Node(cur.val);
              pre.next = node;
              //random? 存在问题
              pre = node;
              cur = cur.next;
          }
  
          return dum.next;
      }
  ```

- 哈希表法

  ```java
  //利用哈希表
      //思路：先利用哈希表创建新节点 + 保留old,new之间的关系
      //遍历old的关系，同时赋值给new
      时间复杂度：O(N)
      空间复杂度：O(N)，哈希表
      public Node copyRandomList(Node head) {
          if(head==null)
              return null;
  
          Map<Node,Node> nodeMap = new HashMap<Node,Node>();
          Node cur = head;
  
          //先利用哈希表创建新节点 + 保留old,new之间的关系
          while(cur!=null){
              Node node = new Node(cur.val);
              nodeMap.put(cur, node);
              cur = cur.next;
          }
  
          //遍历old
          cur = head;
          Node newHead =  nodeMap.get(head);
          while(cur!=null){
              Node newCur = nodeMap.get(cur);
              //注意此处是nodeMap.get(cur.next),链向的是新空间，而不是原来的引用
              newCur.next = nodeMap.get(cur.next);
              newCur.random  = nodeMap.get(cur.random);
              cur = cur.next;
          }
          return newHead;
      }
  ```

- 混合链表

  ```java
  //链接链表的方式
      //思路：分三个阶段，第一阶段，创建空间，并让新节点跟着老节点后面，形成合成链表
      //第二阶段，链接新节点的random
      //第三阶段，分割新老链
      //时间复杂度：O(N)
      //空间复杂度：O(1)
      public Node copyRandomList(Node head) {
          if(head==null)
              return null;
  
          //创建空间，形成合成链表
          Node cur = head;
          while(cur!=null){
              Node tmp = new Node(cur.val);
              tmp.next = cur.next;
              cur.next = tmp;
              cur = tmp.next;
          }
  
          //链接random
          cur = head;
          while(cur!=null){
              //注意条件的设置
              if(cur.random!=null){
                  cur.next.random = cur.random.next;
              }
              cur = cur.next.next;
          }
  
          //拆分链表
          cur = head.next;
          Node pre = head, res = head.next;
          while(cur.next!=null){
              pre.next = pre.next.next;
              cur.next = cur.next.next;
              pre = pre.next;
              cur = cur.next;
          }
          //单独处理原链表尾节点
          pre.next = null;
          return res;
      }
  ```



### -二叉树

#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

- 递归

  ```java
      public TreeNode mirrorTree(TreeNode root) {
          if(root==null) return null;
  
          //处理当前
          TreeNode tmp = mirrorTree(root.left);
          root.left = mirrorTree(root.right);
          root.right = tmp;
  
          return root;
      }
  ```

- 非递归（栈）

  ```java
      public TreeNode mirrorTree(TreeNode root) {
          //非递归，利用栈，中左右入栈
          //然后交换了左右孩子
  
          if(root==null) return null;
          Stack<TreeNode> stack = new Stack<TreeNode>();
          stack.add(root);
  
          while(!stack.isEmpty()){
              TreeNode cur = stack.pop();
              if(cur.left!=null) stack.add(cur.left);
              if(cur.right!=null) stack.add(cur.right);
  
              TreeNode tmp = cur.left;
              cur.left = cur.right;
              cur.right = tmp;
          }
  
          return root;
          
      }
  ```

#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

- 根据后序遍历

  ```java
      //根据后序遍历
      public int maxDepth(TreeNode root) {
          if(root==null) return 0;
  
          int left = maxDepth(root.left);
          int right = maxDepth(root.right);
          return Math.max(left,right) + 1;
      }
  ```

- 根据找信息

  ```java
      // 找信息的方式
      // 左右两树的层数
      public static int max;  //在此初始化无用
      public int maxDepth(TreeNode root) {
          if(root==null) return 0;
          //注意使用前对全局变量的初始化
          max = 0;
          return maxDepthRecur(root,1) + 1;
      }
      
      public int maxDepthRecur(TreeNode root, int height){
          int left = 0;
          if(root.left!=null){
              left = maxDepthRecur(root.left,height + 1);
              max = Math.max(left, height);
          }
          int right = 0;
          if(root.right!=null){
              right = maxDepthRecur(root.right,height + 1);
              max = Math.max(right ,height);
          }
          return max;
      }
  ```

- 根据层次遍历(队列)

  ```java
      //根据层次遍历
      public int maxDepth(TreeNode root) {
          if(root==null) return 0;
          List<TreeNode> parent = new LinkedList<>(); //存当前层的节点
          List<TreeNode> child; //存上一层节点的所有的孩子
          int res = 0;
          parent.add(root);
          while(!parent.isEmpty()){
              //child初始化的位置很重要...，每一层都是一个新的队列
              child = new LinkedList<>();
              for(TreeNode cur : parent){
                  if(cur.left!=null) child.add(cur.left);
                  if(cur.right!=null) child.add(cur.right);
                  
              }
              //巧妙
              parent = child;
              res ++;
          }
          return res;
      }
  ```

- 错误遍历

  ```java
  
      //错误代码
      public int maxDepthRecur(TreeNode root, int height){
          //实例max的值从来都没有变化过，只会返回0，应该在后序进行比较，因为max写在这一句会递归进行
          //max没有+1，当前节点的高度应该等于max(left+right) + 1,且只加一次
          if(root.left!=null){
              left = maxDepthRecur(root.left,height + 1);
              max = Math.max(left, max);
          }
          if(root.right!=null){
              right = maxDepthRecur(root.right,height + 1);
              max = Math.max(right ,max);
          }
          return max;
      }
  ```

#### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

![1](\appendix\二叉树10.png)

- 递归

  ```java
      // 递归方法二
      // 罗列：
      //         L.val=R.val ：即此两对称节点值相等。
      //         L.left.val = R.right.valL.left.val=R.right.val
      //         L.right.val = R.left.valL.right.val=R.left.val 
      // 信息：
      //         L,R 其实和递归方法一一样
  
  
      //递归方法一
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return true;
          return recur(root.left,root.right);
      }
  
      public boolean recur(TreeNode L,TreeNode R){
          //黑盒判断当前左右节点，并处理特殊情况
          if(L==null && R == null) return true;
          if(L==null || R==null || L.val!=R.val) return false;
  
          //返回最基础的类型
          return recur(L.left,R.right) && recur(L.right,R.left); 
      }
  ```

  - 复杂度分析

    ![1](appendix\二叉树11.png)

- 错误解法：镜像

  ```java
      // 镜像求也不可以，同一个道理
      //左根右 = 右根左的遍历
      //[1,2,2,2,null,2] 过不了,除了根节点，所有节点的val都一一样
      public static List<Integer> in1,in2;
  
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return true;
          //初始化
          in1 = new ArrayList<>();
          in2 = new ArrayList<>();
  
          inOrder1Recur(root);
          inOrder2Recur(root);
          System.out.println("in1: " + in1);
          System.out.println("in2: " + in2);
          if(in1.equals(in2)){
              return true;
          }
          return false;
      }
  
      public void inOrder1Recur(TreeNode root){
          if(root==null) return;
          inOrder1Recur(root.left);
          in1.add(root.val);
          inOrder1Recur(root.right);
          
      }
  
      public void inOrder2Recur(TreeNode root){
          if(root==null) return;
          inOrder2Recur(root.right);
          in2.add(root.val);
          inOrder2Recur(root.left);
      }
  ```


#### [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

- 层次遍历

  ```java
      public List<List<Integer>> levelOrder(TreeNode root) {
          //层次遍历
          //可变二维数组
          List<List<Integer>> res = new ArrayList<>();
          //队列,存储某一层的所有节点
          LinkedList<TreeNode> queue = new LinkedList<>();  
          
          //先添加头结点
          if(root!=null) queue.add(root);
  
          //处理
          while(!queue.isEmpty()){
              //新建一个当前层的打印结果
              List<Integer> tmp = new ArrayList<>();
              //遍历当前层的节点
              for(int i = queue.size();i > 0;i--){
                  //先出队列
                  TreeNode node  = queue.poll();
                  tmp.add(node.val);
  
                  if(node.left!=null) queue.add(node.left);
                  if(node.right!=null) queue.add(node.right);
              }
              res.add(tmp);
          }
          return res;
      }
  ```

  



 ### -找规律

#### [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

思路：(有点难受)

根据以上分析，可将求解分为三步：

    确定n所在数字的位数 ，记为digit；
    确定n所在的数字，记为num；
    确定n是num中的哪一数位，并返回结果。

![44](\appendix\44_1.png)

![44](\appendix\44_2.png)

![44](\appendix\44_3.png)

![44](\appendix\44_4.png)

![44](\appendix\44_5.png)

![44](\appendix\44_6.png)

```java
    public int findNthDigit(int n) {
        //1.求位数
        int digit = 1; //位数
        long start = 1; //首位数
        long count = 9; //digit有多少位数
        while (n > count) { // 1.
            n -= count;
            //下一轮的
            digit += 1;
            start *= 10;
            count = digit * start * 9;
        }

        //2.求是哪个数字
        long num = start + (n - 1) / digit; // 2.

        //3.求数字中的第几位
        return Long.toString(num).charAt((n - 1) % digit) - '0'; // 3.
    }
```







## leetcode

### - 排序

- [148.排序链表](https://leetcode-cn.com/problems/sort-list/submissions/)

  ```java
  class Solution {
      public ListNode sortList(ListNode head) {
          //注意处理特殊情况
          if(head==null || head.next == null)
              return head;
  
          //定义快慢指针，慢指针走1，快指针走2，快指针指向最后一个node，慢指针走到中点
          ListNode slow = head;
          ListNode fast = head.next;
          
          //找中点
          while(fast!=null && fast.next!=null){  //因为要保证fast和fast.next不会访问出错
              slow = slow.next;
              fast = fast.next.next;
          }
  
          // ListNode mid = slow;
          ListNode mid = slow.next;
  
          //断成两个链
          slow.next = null;
  
          //递归分
          ListNode l1 = sortList(head);
          ListNode l2 = sortList(mid);
  
          //合并
          //新建一个链表
          ListNode mergeList = new ListNode();
          //定义头结点
          ListNode cur = mergeList;
  
          while(l1!=null && l2!=null){
              if(l1.val<l2.val){
                  cur.next = l1;
                  l1= l1.next;
              }else{
                  cur.next = l2;
                  l2 = l2.next;
              }
              //cur指针的更新
              cur = cur.next;
          }
          if(l1!=null){
              cur.next = l1;
          }else{
              cur.next = l2;
          }
      //链表是链，只用链头就可以
      //     while(l1!=null){
      //         cur.next = l1;
      //         l1 = l1.next;
      //     }
  
      //     while(l2!=null){
      //         cur.next = l2;
      //         l2 = l2.next;
      //     }
  
          return mergeList.next;
  
      }
  ```

  

- [56.合并区间](https://leetcode-cn.com/problems/merge-intervals/)

  ```java
  public int[][] merge(int[][] intervals) {
          if(intervals==null || intervals.length < 2)
              return intervals;
  
          //将intervals用升序进行排序,定义比较器
          Arrays.sort(intervals,new Comparator<int[]>(){
              public int compare(int[] intervals0,int[] intervals1){
                  return intervals0[0]-intervals1[0];
              }
          });
  
          //定义可变数组
          // List list = new ArrayList();这句创建了一个ArrayList实现类的对象后把它上溯到了List接口。此时它就是一个List对
          // 象了，它有些ArrayList类具有的，但是List接口没有的属性和方法，它就不能再用了。 
          // ArrayList list=newArrayList();
          // 创建一对象则保留了ArrayList的所有属性和方法。 
          List <int[]> merged = new ArrayList<int[]>();
  
          //解法：判断merge[1]和当前cur[0]的大小，决定是更新还是添加
          //更新则选merge[1]和cur[1]的最大值
          for(int i = 0; i < intervals.length;  ++i){
              int L = intervals[i][0],R = intervals[i][1];
              if(merged.size()==0 || merged.get(merged.size()-1)[1] < L){
                  merged.add(intervals[i]);
              }else{
                  merged.get(merged.size()-1)[1] = Math.max(merged.get(merged.size()-1)[1],R);
              }
          }
  
          //将可变数组变为普通数组
          return merged.toArray(new int[merged.size()][]);   
      }
  ```

- 215.数组中第K个最大元素

  - 快速选择

  **快速选择**一般用于求解 k-th Element 问题，可以在 *O*(*n*) 时间复杂度，*O*(1) 空间复杂度完成求解工作。快速选择的实现和快速排序相似，不过只需要找到第 *k* 大的枢（pivot）即可，不需要对其左右再进行排序。与快速排序一样，快速选择一般需要先打乱数组。

  由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置

  所以只要某次划分的 q\*q\* 为倒数第 k\*k\* 个下标的时候，我们就已经找到了答案

  分解的过程当中，我们会对子数组进行划分，如果划分得到的 q正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。

  ```java
  //利用快速选择
      public int findKthLargest(int[] nums, int k){
          return quickSelect(nums,0,nums.length-1,nums.length-k);
      }
  
      public int quickSelect(int[] nums, int L, int R, int index){
          //随机交换值，保证最快的速度
          swap(nums,(int)(L + Math.random()*(R-L+1)),R);
          int res = partition(nums,L,R);
          if(res==index){
              return nums[index];
          }else if (res < index) {
              return quickSelect(nums,res+1,R,index);
          }else{
              return quickSelect(nums,L,res-1,index);
          }
      }
  
      public int partition(int[] nums, int L , int R){
          int less = L-1;
          int pivot = nums[R];
          int index = L;
          while(index < R){
              if(nums[index] < pivot){
                  swap(nums,++less,index);
              }
              index++;
          }
          swap(nums,++less,R);
          return less;
      }
  
      public void swap(int[] nums,int i,int j){
          int tmp = nums[i];
          nums[i] = nums[j];
          nums[j] = tmp;
      }
  ```

  - 堆排序：做k次堆调整就可以

    ```java
    public void swap(int[] nums,int i,int j){
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    
        //堆排
        public int findKthLargest(int[] nums, int k){
            int heapSize = nums.length;
            //建堆，建成完全二叉树
            buildHeap(nums,heapSize);
    
            //调整堆,排序
            for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
                swap(nums, 0, i);
                --heapSize;
                heapify(nums, 0, heapSize);
            }
            return nums[0];
        }
    
        //根节点,向下,选出最大得数
    	//循环的写法
        public void heapify(int[] nums,int i,int heapSize){
            int L = 2*i + 1,R = L + 1;
            int largest = i;
            //当下方还有孩子的时候
            while(i < heapSize){
                if (L < heapSize && nums[L] > nums[largest]){
                    largest = L;
                 }
                 if (R < heapSize && nums[R] > nums[largest]){
                     largest = R;
                 }
    
                if(largest==i)  //如果本来就是自己大，就停止
                    break;
                //不断向下的过程
                swap(nums,largest,i);
                i = largest;
                L = 2*i+1;
                R = L + 1;
            }
        }
    	
    	//递归的写法
        // public void heapify(int[] a, int i, int heapSize) {
        //     int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        //     if (l < heapSize && a[l] > a[largest]) {
        //         largest = l;
        //     } 
        //     if (r < heapSize && a[r] > a[largest]) {
        //         largest = r;
        //     }
        //     if (largest != i) {
        //         swap(a, i, largest);
        //         heapify(a, largest, heapSize);
        //     }
        // }
    
    
        //建堆，下沉的方法
        public void buildHeap(int[] nums,int heapSize){
            for (int i = heapSize - 1; i >= 0; i--) {
    			heapify(nums, i, heapSize);
    		}
        }
    ```

- 347.前k个高频元素

  - 维护k值的最小堆

    ```java
    public int[] topKFrequent(int[] nums, int k) {
            // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
            HashMap<Integer,Integer> map = new HashMap();
            for(int num: nums){
                if(map.containsKey(num)){
                    map.put(num,map.get(num) + 1);
                }else{
                    map.put(num,1);
                }
            }
    
            //创建小根堆
            PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>(){
                public int compare(Integer a, Integer b){
                    return map.get(a)- map.get(b);
                }
            });
    
            //维护k大小的小根堆
            //获取哈希表中的所有key值
            for(Integer key:map.keySet()){
                if (heap.size() < k){
                    heap.add(key);
                //更新最小值，确保是频数最高的k个
                }else if (map.get(key) > map.get(heap.peek())){
                    heap.remove();
                    heap.add(key);
                }
            }
    
            //取出最小堆的元素
            List<Integer> res = new ArrayList<>();
            while(!heap.isEmpty())
            {
                res.add(heap.remove());
            }
    
            int[] array = new int[res.size()];
    
            //使用for循环得到数组
            for(int i = 0; i < res.size();i++){
                array[i] = res.get(i);
            }
    
            return array;
        }
    ```

  - 桶排序

    ![桶](C:\Users\Administrator\Desktop\数据结构\appendix\桶排.png)

    ```java
    
        //桶排序的方法
        public int[] topKFrequent(int[] nums, int k) {
            //创建哈希表
            HashMap<Integer,Integer> map = new HashMap();
            for (int num : nums){
                if(map.containsKey(num)){
                    map.put(num,map.get(num)+1);
                }else{
                    map.put(num,1);
                }
            }
    
            //桶排序
            //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
            List<Integer>[] bucket = new List[nums.length + 1];
            for(int key: map.keySet()){
                int i = map.get(key);
                //要申请空间
                if(bucket[i]==null){
                    //因为可能存在频数一样多的数字，要用数组存放
                    bucket[i] = new ArrayList();
                }
                bucket[i].add(key);
            }
    
            List<Integer> res = new ArrayList();
            //使用for循环得到数组
            for(int i = bucket.length-1; i >=0 && res.size() < k ;i--){
                if(bucket[i] == null) continue;
                res.addAll(bucket[i]);
            }
    
            int[] array = new int[res.size()];
    
            //使用for循环得到数组
            for(int i = 0; i < res.size();i++){
                array[i] = res.get(i);
            }
            return array;
        }
    ```

- #### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

  - 桶排序

    ```java
    //桶排序
        public String frequencySort(String s) {
            //创建哈希表
            Map<Character,Integer> map = new HashMap<Character,Integer>();
            char[] cs = s.toCharArray();
            //记录最大频数，以确定桶的数量
            int max = 0;
            for(char c:cs){
                map.put(c,map.getOrDefault(c,0) + 1);
                max = Math.max(map.getOrDefault(c,0) + 1,max);
            }   
    
            //创建桶
            StringBuilder[] bucket = new StringBuilder[max + 1];
            for(int i = 0; i <= max ; i++){
                bucket[i] = new StringBuilder();
            }
            //遍历哈希表，并进桶
            for(Map.Entry<Character,Integer> entry: map.entrySet()){
                char c = entry.getKey();
                int frequency = entry.getValue();
                bucket[frequency].append(c);
            }
    
            //创建字符串
            StringBuilder res = new StringBuilder();
            for(int i = max; i> 0 ;i--){
                StringBuilder b = bucket[i];
                int size = b.length();
                for(int j = 0; j< size; j++){
                    for(int k = 0; k < i;k++)
                        res.append(b.charAt(j));
                }
            }
    
            return res.toString();
    
        }
    ```

    

  - 哈希+优先队列

    ```java
        //定义存入优先队列的数据结构
        class Node{
            char c;
            int v;
            Node (char _c,int _v){
                c = _c;
                v = _v;
            }
        }
        //按照出现频率排序
        public String frequencySort(String s) {
    
            //创建哈希表
            Map<Character,Integer> map = new HashMap<Character,Integer>();
            char[] cs = s.toCharArray();
            for(char c: cs){
                // if(map.containsKey(c)){
                //     map.put(c,map.get(c) + 1);
                // }else{
                //     map.put(c,1);
                // }
                map.put(c, map.getOrDefault(c, 0) + 1);
            }
    
            //存入优先级队列，并构造排序规则
            PriorityQueue<Node> q = new PriorityQueue<>(new Comparator<Node>(){
                public int compare(Node a, Node b){
                    //分词频
                    if (a.v != b.v)
                        return b.v-a.v;
                    return a.v- b.c;
                }
            });
    
            //将hashmap存入优先级队列
            for(char c:map.keySet()){
                q.add(new Node(c,map.get(c)));
            }
    
            //打印
            StringBuilder sb = new StringBuilder();
            while(!q.isEmpty()){
                Node poll = q.poll();
                int count = poll.v;
                while(count > 0){
                    sb.append(poll.c);
                    count--;
                }
            }
            return sb.toString();
    
        }
    ```

- #### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

  - 一次partition

    ```java
    //一次快排的partition
        public void sortColors(int[] nums) {
            if(nums.length < 2){
                return;
            }
    
            int less = 0, more = nums.length;
            int i = 0;
            while(i < more){
                if(nums[i]==0){
                    swap(nums,i++,less++);
                }
                else if (nums[i] == 1){
                    i++;
                }
                else{
                    swap(nums,i,--more);
                }
            }
        }
    
        public void swap(int[]nums,int i,int j){
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    ```

    

