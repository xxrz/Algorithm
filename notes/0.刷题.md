# 刷题

## 剑指offer

### - 排序

- [21. 调整数组顺序使奇数位于偶数前面](https://github.com/CyC2018/CS-Notes/blob/master/notes/21. 调整数组顺序使奇数位于偶数前面.md)

  - 暴力解法: 复制数组，计算奇数的个数

    时间复杂度：O(n)，空间复杂度：O(n)

    ```java
    public int[] reOrderArray(int[] array){
            // 奇数个数
            int oddCnt = 0;
            for (int x : array)
                if (!isEven(x))
                    oddCnt++;
            
            int[] help = array.clone();
            int i = 0;
            for (int num : help) {
                if (!isEven(num))
                    //奇数
                    array[i++] = num;
                else
                    //偶数
                    array[oddCnt++] = num;
            }
            return array;
        }
    ```

  - 冒泡法:利用冒泡排序的想法，为偶数则向后冒

    时间复杂度：O(n^2)，空间复杂度：O(1)

  ```java
  public class Solution {
      //利用冒泡排序的想法，为偶数则向后冒
      public int[] reOrderArray (int[] array) {
          // write code here
          if(array==null || array.length<2){
              return array;
          }
          
          for(int i = 0;i < array.length;i++){
              for(int j = 1;j<array.length-i;j++){
                  if(isEven(array[j-1])&&!isEven(array[j])){
                      swap(array,j-1,j);
                  }
              }
          }
          return array;
      }
      
      public static void swap(int[] arr,int i,int j){
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
      }
      
  //     public static boolean isEven(int num){
  //         if( num % 2 == 0){
  //             return true;
  //         }
  //         else
  //             return false;
  //     }
      public static boolean isEven(int num){
          return num % 2 == 0;
      }
  }
  ```

- [45. 把数组排成最小的数](https://github.com/CyC2018/CS-Notes/blob/master/notes/45. 把数组排成最小的数.md)

  - 快排+利用比较器

  ```java
  //利用快排的思想,划分成左右两个部分
      //找一个基准，左边放拼接起来小的数，右边放拼接起来大的数
      public String PrintMinNumber(int [] numbers) {
          if(numbers==null ||numbers.length<1)
              return "";
          //转为字符串数组
          String [] stringArr = new String[numbers.length];
          for(int i=0;i<numbers.length;i++){
              stringArr[i] = String.valueOf(numbers[i]);
          }
          
          //利用快排
          quickSort(stringArr,0,stringArr.length-1);
          
          //转为字符串，StringBuilder比String更通用，可变，快速且节省空间
          StringBuilder res = new StringBuilder();
          for(String s:stringArr){
              res.append(s);
          }
          
          return res.toString();
      }
      
      public void quickSort(String [] numbers,int L,int R) {
          //递归停止条件
          if(L>=R){
              return;
          }
          int mid = partition(numbers,L,R);
          quickSort(numbers, L , mid-1);
          quickSort(numbers, mid + 1 ,R);
          
      } 
      
      public static int partition(String []numbers,int L,int R){
          if(L>R)
              return -1;
          if(L==R)
              return L;
          int less = L-1;
          int i = L;
          
          String p = numbers[R];
          while(i < R){
              if((numbers[i]+p).compareTo(p+numbers[i]) < 0){
                  swap(numbers,i,++less);
              }
              i++;
          }
          swap(numbers,R,++less);
          return less;
      }
     
      public static void swap(String[] numbers,int i,int j){
          String tmp = numbers[i];
          numbers[i] = numbers[j];
          numbers[j] = tmp;
      }
  ```

  - 调用

  ```java
  public String PrintMinNumber(int [] numbers) {
          if(numbers==null || numbers.length<1 ){
              return "";
          }
          
          //转为字符串
          String[] strs =  new String[numbers.length];
          for(int i = 0;i<numbers.length;i++){
              strs[i] = numbers[i] + "";
          }
          
          //定义字符串排序,比较器
          Arrays.sort(strs,(s1,s2)->(s1+s2).compareTo(s2+s1));
          String res = "";
          for(String str:strs){
              res = res + str;
          }
          return res;
      }
  ```

  

- [51. 数组中的逆序对](https://github.com/CyC2018/CS-Notes/blob/master/notes/51. 数组中的逆序对.md):利用归并排序，遍历一次知道所有数据状况

  - 正着来：nums[i] > nums[j]，说明 nums[i...mid] 都大于 nums[j]

  ```java
      
  // nums[i] > nums[j]，说明 nums[i...mid] 都大于 nums[j]
  	int cnt=0;
      public int InversePairs(int [] array) {
          if(array.length != 0){
              divide(array,0,array.length-1);
          }
          return cnt;
      }
      public void divide(int[] array,int start,int end){
          //递归终止条件
          if(start >= end)   return;
          //取中
          int mid=start+(end-start)/2;
          //分
          divide(array,start,mid);
          divide(array,mid+1,end);
          //治
          merge(array,start,mid,end);
      }
      public void merge(int[] array,int start,int mid,int end){
          //临时数组
          int[] tmp=new int[end-start+1];
          //i和j表示两个分数组的左下标，k表示临时数组的当前下标
          int i=start,j=mid+1,k=0;
          while(i<=mid && j<= end){
              //如果前小于后，则存前，前右移
              if(array[i]<=array[j]){
                  tmp[k++]=array[i++];
              }
              //如果前大于后，则存后，后右移-------***此时存在逆序对，要进行比较
              else{
                  tmp[k++]=array[j++];
                  //如果此时前大于后，那么现有前到最后的元素都会大于后
                  cnt=(cnt+mid-i+1)%1000000007;
              }
          }
          //未遍历完的直接放在右侧
          while(i<=mid){
              tmp[k++]=array[i++];
          }
          while(j<=end){
              tmp[k++]=array[j++];
          }
          //将临时数组的值覆盖原来数组
          for( k=0;k<tmp.length;k++){
              array[start+k]=tmp[k];
          }
      }
  ```

  - 反着来：

    nums[i] > nums[j]，说明 nums[mid...j] 都小于 nums[j]

    ```java
    int count = 0;
    public int InversePairs(int [] array) {
            if(array != null)
                mergeSort(array,0,array.length-1);
            return count;
        }
        
    public void mergeSort(int []array,int L,int R){
        if(L>=R)
            return;
        int mid = L + ((R-L)>>1);
        mergeSort(array,L,mid);
        mergeSort(array,mid+1,R);
        merge(array,L,mid,R);
    }
    
    public void merge(int [] array,int L,int mid,int R){
        //要反着来，因为选择的是比当前值小的数，从大到小排，最后下标好减
        // nums[i] > nums[j]，说明 nums[mid...j] 都小于 nums[j]
        int p1 = mid,p2 = R ;
        int[] help = new int[R-L+1];
        int index = help.length-1;
        while(p1>=L && p2 >= mid+1){
            if(array[p1] > array[p2]){
                help[index--] = array[p1--];
               //不能写在最后的返回，会出错
                count = (count + p2-mid)%1000000007;
            }else{
                help[index--] = array[p2--];
            }
            
        }
        
        while(p1>=L){
            help[index--] = array[p1--];
        }
        
        while(p2>=mid+1){
            help[index--] = array[p2--];
        }
        
        for(int i=0;i < help.length;i++){
            array[L+i] = help[i];
        }
    }
    ```

- 3.数组中的重复数字

  - 数组

  ```java
  public int duplicate (int[] numbers) {
          // write code here
          int[] res = new int[numbers.length];
          //由于所有数字在0-n-1内，可将原数组中每一个数组当做新数组的下标
          //新数组存次数
          for(int num:numbers){
              res[num]++;
              if(res[num]==2)
                  return num;
          }
          return -1;
      }
  ```

  - HashSet

  ```java
  //利用hashSet
      public int duplicate (int[] numbers) {
          // write code here
          HashSet<Integer> hashset = new HashSet<>();
          for(int num:numbers){
              if(hashset.contains(num))
                  return num;
              else
                  hashset.add(num);
          }
          return -1;
      }
  
  ```

4. #### [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

   - 哈希表

   ```java
   public int findRepeatNumber(int[] nums) {
           HashSet<Integer> hashset = new HashSet<Integer>();
           for(int num:nums){
               if(hashset.contains(num)){
                   return num;
               }else{
                   hashset.add(num);
               }
           }
           return -1;
       }
   ```

5. #### [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

   ```java
   public static boolean findNumberIn2DArray(int[][] matrix, int target) {
           if (matrix==null || matrix.length < 1)
               return false;
           //行
           int hlength  = matrix.length;
           //列
           int llength = matrix[0].length;
   
           int i = 0,j = llength-1;
           while(i < hlength && j>=0){
               if (j >=0 && matrix[i][j] < target){
                   i++;
               }
               if (i < hlength && matrix[i][j] > target){
                   j--;
               }
               if (j >=0 && i < hlength && matrix[i][j] == target){
                   return true;
               }
           }
           return false;
       }
   ```

#### 6. [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

```java
public String replaceSpace(String s) {
        StringBuilder tmp = new StringBuilder();
        char[] cs = s.toCharArray();
        for(int i = 0; i < cs.length; i++ ){
            if(!Character.isSpace(cs[i])){
                tmp.append(cs[i]);
            }else{
                tmp.append("%20");
            }
        }
        return tmp.toString();
    }
```

#### 7. [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

 - 哈希表

   ```java
       public int majorityElement(int[] nums) {
           if(nums==null || nums.length < 1)
               return 0;
   
   
           int cnt = nums.length / 2;
           Map<Integer,Integer> hashmap = new HashMap<Integer,Integer>();
           for(int num:nums){
               if(hashmap.containsKey(num)){
                   if(hashmap.get(num)==cnt){
                       return num;
                   }else{
                       hashmap.put(num,hashmap.get(num) + 1);
                   }
               }
               else{
                   hashmap.put(num,1);
               }
           }
           return nums[cnt];
       }
   ```

   

 - 众数算法

   ![众数](appendix\众数.png)

```java
public int majorityElement(int[] nums) {
        if(nums==null || nums.length < 1)
            return 0;
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
```

#### [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

```java
    public static int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length <1) {
            return new int[0];
        }

        //创建大根堆
        PriorityQueue<Integer> q = new PriorityQueue<Integer>(new Comparator<Integer>(){
            public int compare(Integer a, Integer b){
                return b - a;
            }
        });

        //维护k个大小的大根堆
        for(int num:arr){
            if(q.size() < k){
                q.offer(num);
            }else if(num < q.peek()){
                q.poll();
                q.offer(num);
            }
        }

        //返回堆元素
        int[] res = new int[q.size()];
        int idx = 0;
        for(int num: q) {
            res[idx++] = num;
        }
        return res;
    }
```

- 快速选择

  ```java
      // //快速选择
      public static int[] getLeastNumbers(int[] arr, int k) {
          if (k == 0 || arr.length == 0) {
              return new int[0];
          }
          // 最后一个参数表示我们要找的是下标为k-1的数
          return quickSearch(arr, 0, arr.length - 1, k - 1);
      }
  
      private static int[] quickSearch(int[] nums, int L, int R, int k) {
          // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；
          int res = partition(nums, L, R);
          if (res == k) {
              return Arrays.copyOf(nums, res + 1);
          }
          // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。
          return res > k? quickSearch(nums, L, res - 1, k): quickSearch(nums, res + 1, R, k);
      }
      public static int partition(int[] arr,int L,int R){
          int less = L-1;
          int pivot = arr[R];
          int index = L;
  
          while(index < R){
              if(arr[index] < pivot){
                  swap(arr,++less,index);
              }
              index++;
          }
          swap(arr,++less,R);
          return less;
      }
  
      public static void swap(int[] arr,int i,int j){
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
      }
  ```

  

#### [剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

- 排序 + 规则

  ```java
      public boolean isStraight(int[] nums) {
          if(nums==null || nums.length < 5){
              return false;
          }
          Arrays.sort(nums);
          int zeroCnt = 0;
          int diff = 0;
          int i = 0;
          while(i < nums.length-1){
              if (nums[i]==0) {
                  zeroCnt++;
                  i++;
              }else if(nums[i]==nums[i+1] + 1){
                  i++;
              }else if(nums[i] != nums[i+1] +1){
                  diff = nums[i+1]-(nums[i]+1);
                  if(diff==-1 || diff > zeroCnt){
                      return false;
                  }else{
                      i++;
                      zeroCnt = zeroCnt - diff;
                  }
              }
          }
          return true;
      }
  ```

  

- 优化（排序 + 规则）

  优化原则：存在顺子的条件：1.除零外没有任何重复的数字；2.最大值-最下值<5（除0外）

  ```java
      //排序 + 除零外<5
      public boolean isStraight(int[] nums){
          if(nums==null || nums.length < 5){
              return false;
          }
          Arrays.sort(nums);
          int min = 0;
          int i = 0;
          while(i < nums.length-1){
              //
              if(nums[i]==0)
                  min++;
              //注意此处是else if 不是if 
              else if(nums[i]==nums[i+1])
                  return false;
              i++;
          }
          return nums[nums.length-1]-nums[min]<5;
      }
  ```

  

- set + 遍历

  ```java
      //set + 遍历
      //原则：存在顺子的条件：1.除零外没有任何重复的数字；2.最大值-最下值<5（除0外）
      public boolean isStraight(int[] nums) {
          if(nums==null || nums.length < 5){
              return false;
          }
          //min的初始值要注意，不能仅初始化为0，如果数组中没有0就出错了
          int max = 0,min = 14;
          Set<Integer> set = new HashSet<Integer>();
          for(int num:nums){
              if(num==0)
                  continue;
              if(set.contains(num))
                  return false;
              max = Math.max(num,max);
              min = Math.min(num,min);
              set.add(num);
          }
          return max-min < 5;
      }
  ```

  #### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)
  
  - 字符串构造器
  
  ```java
   //原则：利用字符串构造器，和系统排序
      public String minNumber(int[] nums) {
          if(nums ==null || nums.length < 1){
              return "";
          }
  
          String[] s = new String[nums.length];
          //将数据转为字符串
          for(int i = 0;i < nums.length; i++){
              s[i] = nums[i] +"";
          }
          
          //字符串compareTo的比较器
          Arrays.sort(s,(s1,s2)->(s1+s2).compareTo(s2+s1));
  
              StringBuilder确实会快一点
          StringBuilder res = new StringBuilder();
          for(String str:s){
              res.append(str);
          }
  
          // String res = "";
          // for(String str:s){
          //     res += str;
          // }
  
          return res.toString();
          // return res;
      }
  ```
  
  - 快排
  
  ```java
  public String minNumber(int[] nums) {
          if(nums ==null || nums.length < 1){
              return "";
          }
  
          String[] str = new String[nums.length];
          //将数据转为字符串
          for(int i = 0;i < nums.length; i++){
              str[i] = nums[i] +"";
          }
          quickSort(str,0,nums.length-1);
  
          StringBuilder res = new StringBuilder();
          for(String s:str){
              res.append(s);
          }
  
          return res.toString();
      }
  
      public void quickSort(String[] nums, int L,int R){
          if(L>=R)
              return;
          int mid = partition(nums,L,R);
          quickSort(nums,L,mid);
          quickSort(nums,mid+1,R);
      }
  
      public int partition(String[] nums,int L,int R){
          swap(nums,(int)(Math.random()*(R-L+1)+L),R);
          String pivot = nums[R];
          int less = L-1;
          int index =L;
          while(index < R){
              //注意字符串的比较的写法
              if((nums[index]+pivot).compareTo(pivot+nums[index]) < 0){
                  swap(nums,++less,index++);
              }else{
                  index++;
              }
          }
          swap(nums,++less,R);
          return less;
      }
  
      public void swap(String[] nums,int i,int j){
          String tmp = nums[i];
          nums[i] = nums[j];
          nums[j] = tmp;
      }
  ```
  
  #### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)
  
  - 构建两个堆，一个大根堆，一个小根堆
  
    <img src="appendix\二堆.png" alt="二堆" style="zoom:150%;" />
  
    ```java
    class MedianFinder {
    
        /** initialize your data structure here. */
    
        //建两个堆
        Queue<Integer> A, B;
    
        //算法：
        public MedianFinder() {
            A = new PriorityQueue<>(); // 小顶堆，保存较大的一半，保存较多的一般，A
            B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半,B
        }
        
        public void addNum(int num) {
            //说明是奇数，向B添加元素
            //先插入A，再向B中添加A的堆顶
            if(A.size()!=B.size()){
                A.add(num);
                B.add(A.poll());
            //说明是偶数，向A添加元素
            //先插入B，再向A中添加B的堆顶
            }else{
                B.add(num);
                A.add(B.poll());
            }
        }
        
        public double findMedian() {
    //注意写成2.0
            return A.size()!=B.size()? A.peek():(A.peek()+B.peek())/2.0;
        }
    }
    ```

### -哈希表

#### [面试题50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

- 暴力：两次遍历

  ```java
  public char firstUniqChar(String s) {
          //进入hashmap
          HashMap<Character,Integer> map = new HashMap<Character,Integer>();
          char[] cs = s.toCharArray();
          for(char str:cs){
              map.put(str,map.getOrDefault(str,0)+1);
          }
  
          //遍历，确定第一个
          for(char str:cs){
              if(map.get(str)==1){
                  return str;
              }
          }
          //注意单空格（char），单引号
          return ' ';
      }
  ```

- 优化上一种方法

  ```java
      //优化方法一
      //键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 -1−1（如果该字符出现多次）
      public char firstUniqChar(String s) {
          HashMap<Character,Integer> map = new HashMap<Character,Integer>();
          for(int i = 0;i < s.length();i++){
              if(map.containsKey(s.charAt(i))){
                  map.put(s.charAt(i),-1);
              }else{
                  map.put(s.charAt(i),i);
              }
          }
  
          //找出其中不为 -1−1 的最小值，即为第一个不重复字符的索引，然后返回该索引对应的字符
          
          //注意哈希表示无序的，遍历哈希表也无序
          int min = s.length();
          for(Map.Entry<Character,Integer> entry:map.entrySet()){
              int v = entry.getValue();
              if(v!=-1 && v < min){
                  min = v;
              }
          }
  
          return min==s.length()? ' ':s.charAt(min);
      }
  ```

- 有序哈希表

  ```java
  public char firstUniqChar(String s) {
          Map<Character,Boolean> dic = new LinkedHashMap<>();
          char[] cs = s.toCharArray();
          for (char c :cs){
              dic.put(c,!dic.containsKey(c));
          }
  
          for(Map.Entry<Character,Boolean> entry:dic.entrySet()){
              if(entry.getValue())
                  return entry.getKey();
          }
  
          return ' ';
      }
  ```

### - 二分

​	[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```java
public int missingNumber(int[] nums) {
        //思路：利用二分+值和下标对应关系
        //不缺失：nums[i]=i
        //缺失：nums[i]!=i
        int p1 = 0;
        int p2 = nums.length-1;
        int mid;
        while(p1 <= p2){
            mid = (p1 + p2)/2;
            //说明缺失的在后半段
            if (nums[mid]==mid){
                p1 = mid + 1;
            //说明缺失的在前半段
            }else{
                p2 = mid - 1;
            }
        }
        return p1;

    }
```

#### [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

```java
    public int[] twoSum(int[] nums, int target) {
        //对撞双指针（理论性证明）
        int p1 = 0,p2 = nums.length-1;
        int[] res = new int[2];
        //对撞 所以不能相等
        while(p1 < p2){
            if(nums[p1]+nums[p2] == target){
                return  new int[] { nums[p1], nums[p2] };
            }else if(nums[p1]+nums[p2] < target){
                p1++;
            }else{
                p2--;
            }
        }
        return new int[0];
    }
```

#### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

- ```java
  //使用二分法分别找到 左边界 left和 右边界 right
      //清晰一些，确认边界条件或者返回值，自己走一个例子
      public int search(int[] nums,int target){
          int L = 0,R  = nums.length-1;
          int right ,left;
          //查找右边界
          while(L<=R){
              int mid = L+(R-L)/2;
              //考虑相等时，右边界应该在[mid+1,R]
              if(nums[mid] <= target){
                  L = mid + 1; 
              }
              else{
                  R = mid - 1;
              }
          }
          right  =  L;
  
          //优化提前返回,如果右边界在最左边，则该数不存在
          if(R >= 0 && nums[R] != target) return 0;
  
          L = 0;
          R  = nums.length-1;
          //查找左边界
          while(L<=R){
              int mid = L+(R-L)/2;
              //考虑相等时，做边界应该在[L,mid-1]
              if(nums[mid] < target){
                  L = mid + 1; 
              }
              else{
                  R = mid - 1;
              }
          }
          left = R;
  
          return right-left-1;
  
      }
  ```

- 优化

  ```java
      //使用二分法分别找到 左边界 left和 右边界 right
      public int search(int[] nums, int target) {
          int R = helper(nums,target);
          int L = helper(nums,target-1);
          return R-L;
  
      }
  
      //二分查找
      public int helper(int[]nums, int target){
          int L = 0;
          int R = nums.length-1;
          while(L<=R){
              int mid = L + (R-L)/2;
              if(nums[mid] <= target){
                  L = mid +1;
              }else{
                  R = mid -1;
              }
          }
          //此数大1
          return L;
      }
  ```

#### [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

- 暴力

  ```java
  
      // 暴力
      public int minArray(int[] numbers) {
          int i = 0;
          while(i < numbers.length-1){
              if(numbers[i]<=numbers[i+1] ) i++;
              else return numbers[i + 1];
          }
          return numbers[0];
      }
  ```

- 双指针

  ```java
      // 双指针
      public int minArray(int[] numbers) {
          int i = 0,j = numbers.length-1;
          while(i < j && i<numbers.length &&j>=0){
              if(numbers[i]<=numbers[i+1] ) i++;
              else return numbers[i + 1];
              if(numbers[j]>=numbers[j-1]) j--;
              else return numbers[j];
          }
          return numbers[0];
      }
  ```

- 二分

  ```java
      //二分
      //思路：旋转数组旋转点左侧比大于右侧
      //旋转点一定在右侧，一定会比最右侧值小
      //i = 0,j = length-1
      //mid < j :旋转点在左
      //mid > j :旋转点在右
      //mid = j :无法判断，但根据性质可以顺序查找
      public int minArray(int[] numbers){
          if(numbers==null ||numbers.length < 1){
              return -1;
          }
  
          int i = 0,j = numbers.length-1;
          while(i<j){
              int mid = i + ((j-i)>>1);
              if(numbers[mid] < numbers[j]){
                  //注意：4,5,1,2,3
                  j = mid;
              }else if(numbers[mid] > numbers[j]){
                  i = mid + 1;
              }else{
                  j--;
              }
          }
          return numbers[i];
      }
  ```

  

### -双指针

#### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

- 倒着遍历字符串，确认每个单词的左右边界（双指针），加入Res

  还要注意多个空格的问题

  ```java
      public String reverseWords(String s) {
          //先去掉多余的空格
          s = s.trim();
          int L = s.length()-1,R = L;
          StringBuilder res = new StringBuilder();
          while(L >= 0){
              //找左边界
              while(L>=0 && s.charAt(L)!=' '){
                  L--;
              }
              //添加单词
              res.append(s.substring(L+1,R+1)+" ");
              //跳过空格
              while(L>=0 && s.charAt(L)==' '){
                  L--;
              }
              R= L;// R 指向下个单词的尾字符
          }
          return res.toString().trim();
      }
  
  ```

- 利用系统库

  ```java
  //利用系统库
      public String reverseWords(String s) {
          String[] s1 = s.trim().split(" ");
          StringBuilder res = new StringBuilder();
          for(int i = s1.length-1; i>=0 ;i--){
              //查看是否是空格
              if(s1[i].equals("")) continue;
              res.append(s1[i]+" ");
          }
          return res.toString().trim();
      }
  ```

#### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```java
    //暴力
    public String reverseLeftWords(String s, int n) {
        StringBuilder tmp = new StringBuilder();
        StringBuilder res = new StringBuilder();
        char[] cs = s.toCharArray();
        for(int i = 0;i < cs.length; i++){
            if(i < n){
                tmp.append(cs[i]);
            }
            else{
                res.append(cs[i]);
            }
        }
        res.append(tmp);
        return res.toString();

    }

    //字符串切片
    public String reverseLeftWords(String s, int n) {
        return s.substring(n,s.length())+ s.substring(0,n);
    }

    //空间优化
    public String reverseLeftWords(String s, int n) {
        StringBuilder res = new StringBuilder();
        for(int i = n; i < s.length(); i++)
            res.append(s.charAt(i));
        for(int i = 0; i < n; i++)
            res.append(s.charAt(i));
        return res.toString();
    }

    //取余操作简化代码
    public String reverseLeftWords(String s, int n) {
        StringBuilder res = new StringBuilder();
        for(int i = n; i < n + s.length(); i++)
            res.append(s.charAt(i % s.length()));
        return res.toString();
    }
```

#### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

- 求和公式+求根公式

  ![57](appendix\57_求和公式.png)

  ```java
      //求和公式法
      //i<j 且j为整数
      public int[][] findContinuousSequence(int target) {
           int i = 1;
           //j为数组中最大的数,要保留小数
           double j = 2.0;
           List<int []> res = new ArrayList<>();
           //注意条件，不是i < target
           while(i < j){
               j = (-1 + Math.sqrt(1+4*(2*target + (long)i*i-i)))/2;
               if(i < j && j == (int)j){
                   int[] ans = new int[(int)j-i+1];
                   //注意此处的写法
                   for(int k = i;k <= (int)j;k++){
                       ans[k-i] = k;
                   }
                   res.add(ans);
               }
               i++;
           }
           return res.toArray(new int[0][]);
      }
  ```

- 滑动窗口：最大的特点是只能向右滑（双指针）

  ```java
      //滑动窗口
      //左边界，右边界，只往右边滑，而不是来回滑
      //滑动窗口只有 右边界向右移动（扩大窗口） 和 左边界向右移动（缩小窗口）
      //时间复杂度：只向右滑，O(N)
      public int[][] findContinuousSequence(int target) {
          int l = 1,r = 2;
          int sum = l + r;
          List<int []> res = new ArrayList<>();
          while(l < r){
              if(sum==target){
                  int[] ans = new int[r-l+1];
                  for(int k = l;k <= r;k++){
                      ans[k-l] = k;
                  }
                  res.add(ans);
              }
              if(sum >= target){
                  sum = sum - l;
                  l++;
              }else{
                  r++;
                  sum = sum + r;
              }
          } 
          return res.toArray(new int[0][]);
      }
  ```

  



### - 链表

总结：栈，双指针，递归

#### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

- 双指针（迭代）

  ```java
  public ListNode reverseList(ListNode head) {
          ListNode cur = null;//存当前节点
          ListNode pre = head;//存当前节点的下一个节点
          ListNode tmp = null;//先保存当前节点的下一个节点
  
          while(pre!=null){
              tmp = pre.next;
              pre.next = cur;
              cur = pre;
              pre = tmp;
          }
  
          //出来的时候pre==null
          return cur;
      }
  ```

- **递归**

  1） 如果一个问题 A 可以分解为若干子问题 B、C、D，**你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A*

  2） 所有的递归问题都可以用递推公式来表示

  

  **example**1

  - 问题：逆序打印一个数组
  - 递推公式：

  ```reasonml
  假设令F(n)=逆序遍历长度为n的数组
  那么F(n)= 打印数组中下标为n的元素 + F(n-1)
  ```

  - 终止条件：

  ```kotlin
  if (n <0) return ;
  ```

  - 递归代码：

  ```reasonml
  public void Print(int[] nums,int n){
      if(n<0) return;
      System.out.println(nums[n]);
      Print(nums,n-1);
  }
  ```

  **example2**

  - 问题：二叉树的先序遍历
  - 递推公式：

  ```reasonml
  令F(Root)为问题:遍历以Root为根节点的二叉树，
  令F(Root.left)为问题:遍历以F(Root.left)为根节点的二叉树
  令F(Root.right)为问题:遍历以F(Root.right)为根节点的二叉树
  那么其递推公式为：
  F(Root)=遍历Root节点+F(Root.left)+F(Root.right)
  ```

  - 递归代码：

  ```reasonml
  public void preOrder(TreeNode node){
      if(node==null) return;
      System.out.println(node.val);
      preOrder(node.left);
      preOrder(node.righr);
  }
  ```

  **example3**(此题)

  - 问题：单向链表的反转
  - 递推公式：

  ```reasonml
  令F(node)为问题:反转以node为头节点的单向链表；
  一般，我们需要考虑F(n)和F(n-1)的关系，那么这里，如果n代表以node为头节点的单向链表，那么n-1就代表以node.next为头节点的单向链表.
  所以，我们令F(node.next)为问题：反转以node.next为头节点的单向链表；
  那么，F(node)和F(node.next)之间的关系是？这里我们来简单画个图，假设我们反转3个节点的链表：
  1 -> 2 -> 3
  那么，F(node=1)=F(node=2)+?
  
  这里假设子问题F(node=2)已经解决，那么我们如何解决F(node=1)
  
  很明显，我们需要反转node=2和node=1， 即 node.next.next=node; 同时 node.next=null;
  所以，这个问题就可以是：F(node=1)=F(node=2)+ 反转node=2和node=1
  ```

  - 递归代码：

  ```java
  //递归
      public ListNode reverseList(ListNode head){
          //终止条件
          if(head==null || head.next==null){
              return head;
          }
  
          //f(node=2)
          ListNode node = reverseList(head.next);
  
          //反转操作
          head.next.next = head;
          head.next = null;
  
          return node;
      }
  ```

#### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

- 先反转链表 再打印（太麻烦了）

  ```java
      //先反转链表，再打印
      public int[] reversePrint(ListNode head) {
          List<Integer> list = new ArrayList<Integer>();
          ListNode res = reverseList(head);
          for(ListNode cur = res;cur!=null;cur = cur.next){
              list.add(cur.val);
          }
  
          //可变数组转数组
          int[] arrs = new int[list.size()];
          for(int i = 0;i < list.size();i++){
              arrs[i] = list.get(i);
          }
          return arrs;
  
      }
  
      public ListNode reverseList(ListNode head){
          if(head ==null ||head.next==null)
              return head;
          
          ListNode node = reverseList(head.next);
          head.next.next = head;
          head.next = null;
  
          return node;
      }
  ```

- 直接递归打印(分解问题，注意递归条件)

  ```java
      //递归
      List<Integer> tmp = new ArrayList<Integer>();
      public int[] reversePrint(ListNode head) {
          recur(head);
          int[] arrs = new int[tmp.size()];
          for(int i = 0;i < tmp.size();i++){
              arrs[i] = tmp.get(i);
          }
          return arrs;
      }
  
      public void recur(ListNode head){
          if(head==null)
              return;
          recur(head.next);
          tmp.add(head.val);
      }
  ```

- 辅助栈

  ```java
  //链表特点： 只能从前至后访问每个节点。
  //题目要求： 倒序输出节点值。
  //这种 先入后出 的需求可以借助 栈 来实现。
  ```

  ```java
      public int[] reversePrint(ListNode head){
          LinkedList<Integer> stack = new LinkedList<Integer>();
          ListNode cur = head;
          while(cur!=null){
              stack.addLast(cur.val);
              cur = cur.next;
          }
  
          int[] res = new int[stack.size()];
          for(int i=0;i<res.length;i++){
              res[i] = stack.removeLast();
          }
          return res;
      }
  ```

#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

- 辅助栈

  ```java
  //辅助栈
      public ListNode getKthFromEnd(ListNode head, int k) {
          LinkedList<ListNode> stack = new LinkedList<ListNode>();
          while(head!=null){
              stack.addLast(head);
              head = head.next;
          }
  
          ListNode newhead = head;
          //因为长度会变,所以该值要放在外面
          int length = stack.size();
          for(int i = stack.size()-1; i >= 0;i--){
              int index = length-i;
              // System.out.println("i"+i);
              // System.out.println("index"+index);
              if(length-i==k){
                  return stack.removeLast();
              }else{
                  stack.removeLast();
              }
          }
  
          return new ListNode();
      }
  ```

- 快慢指针

  ```java
      //双指针
      public ListNode getKthFromEnd(ListNode head, int k) {
          ListNode slow = head,fast = head;
          //快指针先走K步
          for(int i = 0; i<k;i++){
              fast = fast.next;
          }
          //快慢指针一起走，直到快指针为NULL
          while(fast!=null){
              slow = slow.next;
              fast = fast.next;
          }
          return slow;
      }
  ```

  #### [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

  - 迭代，伪链头

    ```java
    
       public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            //创建伪代码头,否则无法用next
            ListNode dum = new ListNode(0);
            ListNode cur = dum;
            while(l1!=null && l2!=null){
                if(l1.val <= l2.val){
                    cur.next = l1;
                    l1 = l1.next;
                }else{
                    cur.next = l2;
                    l2 = l2.next;
                }
                //注意新链表的当前指针也要移动
                cur = cur.next;
            }
            if(l1!=null){
                cur.next = l1;
            }
    
            if(l2!=null){
                cur.next = l2;
            }
    
            return dum.next;
        }
    ```

  - 递归(不是特别好理解)

    ```java
        //递归,不是很好理解
    // 特判：如果有一个链表为空，返回另一个链表
    // 如果l1节点值比l2小，下一个节点应该是l1，应该return l1，在return之前，指定l1的下一个节点应该是l1.next和l2俩链表的合并后的头结点
    // 如果l1节点值比l2大，下一个节点应该是l2，应该return l2，在return之前，指定l2的下一个节点应该是l1和l2.next俩链表的合并后的头结点
    
        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if(l1==null ||l2==null){
                return l1!=null?l1:l2;
            }
    
            if(l1.val <= l2.val){
                l1.next = mergeTwoLists(l1.next,l2);
                return l1;
            }else{
                l2.next = mergeTwoLists(l2.next,l1);
                return l2;
            }
    
        }
    ```

#### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

```java
    public ListNode deleteNode(ListNode head, int val) {
        //考虑可能会删除第一个节点，所以用了伪头
        ListNode dum = new ListNode(0);
        dum.next = head;
        ListNode cur = head,parent = dum;
        while(cur!=null){
            if(cur.val!=val){
                parent.next = cur;
                cur = cur.next;
                parent = parent.next;
            }else{
                parent.next = cur.next;
                cur = null;
                break;
            }
        }
        return dum.next;
    }
```

#### [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

- 哈希表法

  ```java
      // 哈希集合法
      // 首先遍历链表 \textit{headA}headA，并将链表 \textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中
      public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
          Set<ListNode> tmp = new HashSet<ListNode>();
          ListNode p1 = headA, p2 = headB;
          while(p1!=null){
              tmp.add(p1);
              p1 = p1.next;
          }
          while(p2!=null){
              if(tmp.contains(p2)){
                  return p2;
              }else{
                  p2 = p2.next;
              }
          }
          return null;
      }
  ```

- 双指针相遇法

  ```java
  //双指针浪漫相遇法
      //两个链表长度分别为L1+C、L2+C， C为公共部分的长度
      // 第一个人走了L1+C步后，回到第二个人起点走L2步；
      // 第2个人走了L2+C步后，回到第一个人起点走L1步。 
      // 当两个人走的步数都为L1+L2+C时就两个人就相爱了
      public ListNode getIntersectionNode(ListNode headA,ListNode headB){
          //处理特殊情况
          if(headA==null || headB==null){
              return null;
          }
  
          ListNode p1 = headA, p2 = headB;
          while(p1!=p2){
              if(p1!=null){
                  p1 = p1.next;
              }else{
                  p1 = headB;
              }
  
              if(p2!=null){
                  p2 = p2.next;
              }else{
                  p2 = headA;
              }
  
          }
  
          return p1;
          
      }
  ```

#### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

- 普通链表的复制,同时说明问题难度

  ```java
      //普通链表的复制
      public Node copyList(Node head) {
          Node dum = new Node(0);
          Node pre = dum;
          Node cur = head;
          while(cur!=null){
              Node node = new Node(cur.val);
              pre.next = node;
              //random? 存在问题
              pre = node;
              cur = cur.next;
          }
  
          return dum.next;
      }
  ```

- 哈希表法

  ```java
  //利用哈希表
      //思路：先利用哈希表创建新节点 + 保留old,new之间的关系
      //遍历old的关系，同时赋值给new
      时间复杂度：O(N)
      空间复杂度：O(N)，哈希表
      public Node copyRandomList(Node head) {
          if(head==null)
              return null;
  
          Map<Node,Node> nodeMap = new HashMap<Node,Node>();
          Node cur = head;
  
          //先利用哈希表创建新节点 + 保留old,new之间的关系
          while(cur!=null){
              Node node = new Node(cur.val);
              nodeMap.put(cur, node);
              cur = cur.next;
          }
  
          //遍历old
          cur = head;
          Node newHead =  nodeMap.get(head);
          while(cur!=null){
              Node newCur = nodeMap.get(cur);
              //注意此处是nodeMap.get(cur.next),链向的是新空间，而不是原来的引用
              newCur.next = nodeMap.get(cur.next);
              newCur.random  = nodeMap.get(cur.random);
              cur = cur.next;
          }
          return newHead;
      }
  ```

- 混合链表

  ```java
  //链接链表的方式
      //思路：分三个阶段，第一阶段，创建空间，并让新节点跟着老节点后面，形成合成链表
      //第二阶段，链接新节点的random
      //第三阶段，分割新老链
      //时间复杂度：O(N)
      //空间复杂度：O(1)
      public Node copyRandomList(Node head) {
          if(head==null)
              return null;
  
          //创建空间，形成合成链表
          Node cur = head;
          while(cur!=null){
              Node tmp = new Node(cur.val);
              tmp.next = cur.next;
              cur.next = tmp;
              cur = tmp.next;
          }
  
          //链接random
          cur = head;
          while(cur!=null){
              //注意条件的设置
              if(cur.random!=null){
                  cur.next.random = cur.random.next;
              }
              cur = cur.next.next;
          }
  
          //拆分链表
          cur = head.next;
          Node pre = head, res = head.next;
          while(cur.next!=null){
              pre.next = pre.next.next;
              cur.next = cur.next.next;
              pre = pre.next;
              cur = cur.next;
          }
          //单独处理原链表尾节点
          pre.next = null;
          return res;
      }
  ```



### -二叉树

#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

- 递归

  ```java
      public TreeNode mirrorTree(TreeNode root) {
          if(root==null) return null;
  
          //处理当前
          TreeNode tmp = mirrorTree(root.left);
          root.left = mirrorTree(root.right);
          root.right = tmp;
  
          return root;
      }
  ```

- 非递归（栈）

  ```java
      public TreeNode mirrorTree(TreeNode root) {
          //非递归，利用栈，中左右入栈
          //然后交换了左右孩子
  
          if(root==null) return null;
          Stack<TreeNode> stack = new Stack<TreeNode>();
          stack.add(root);
  
          while(!stack.isEmpty()){
              TreeNode cur = stack.pop();
              if(cur.left!=null) stack.add(cur.left);
              if(cur.right!=null) stack.add(cur.right);
  
              TreeNode tmp = cur.left;
              cur.left = cur.right;
              cur.right = tmp;
          }
  
          return root;
          
      }
  ```

#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

- 根据后序遍历

  ```java
      //根据后序遍历
      public int maxDepth(TreeNode root) {
          if(root==null) return 0;
  
          int left = maxDepth(root.left);
          int right = maxDepth(root.right);
          return Math.max(left,right) + 1;
      }
  ```

- 根据找信息

  ```java
      // 找信息的方式
      // 左右两树的层数
      public static int max;  //在此初始化无用
      public int maxDepth(TreeNode root) {
          if(root==null) return 0;
          //注意使用前对全局变量的初始化
          max = 0;
          return maxDepthRecur(root,1) + 1;
      }
      
      public int maxDepthRecur(TreeNode root, int height){
          int left = 0;
          if(root.left!=null){
              left = maxDepthRecur(root.left,height + 1);
              max = Math.max(left, height);
          }
          int right = 0;
          if(root.right!=null){
              right = maxDepthRecur(root.right,height + 1);
              max = Math.max(right ,height);
          }
          return max;
      }
  ```

- 根据层次遍历(队列)

  ```java
      //根据层次遍历
      public int maxDepth(TreeNode root) {
          if(root==null) return 0;
          List<TreeNode> parent = new LinkedList<>(); //存当前层的节点
          List<TreeNode> child; //存上一层节点的所有的孩子
          int res = 0;
          parent.add(root);
          //控制有多少层，从上到下
          while(!parent.isEmpty()){
              //child初始化的位置很重要...，每一层都是一个新的队列
              child = new LinkedList<>();
              //控制当前层的每个节点，从左往右
              for(TreeNode cur : parent){
                  if(cur.left!=null) child.add(cur.left);
                  if(cur.right!=null) child.add(cur.right);
                  
              }
              //巧妙
              parent = child;
              res ++;
          }
          return res;
      }
  ```

- 错误遍历

  ```java
  
      //错误代码
      public int maxDepthRecur(TreeNode root, int height){
          //实际max的值从来都没有变化过，只会返回0，应该在后序进行比较，因为max写在这一句会递归进行
          //max没有+1，当前节点的高度应该等于max(left+right) + 1,且只加一次
          if(root.left!=null){
              left = maxDepthRecur(root.left,height + 1);
              max = Math.max(left, max);
          }
          if(root.right!=null){
              right = maxDepthRecur(root.right,height + 1);
              max = Math.max(right ,max);
          }
          return max;
      }
  ```

#### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

![1](\appendix\二叉树10.png)

- 递归

  ```java
      // 递归方法二
      // 罗列：
      //         L.val=R.val ：即此两对称节点值相等。
      //         L.left.val = R.right.valL.left.val=R.right.val
      //         L.right.val = R.left.valL.right.val=R.left.val 
      // 信息：
      //         L,R 其实和递归方法一一样
  
  
      //递归方法一
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return true;
          return recur(root.left,root.right);
      }
  
      public boolean recur(TreeNode L,TreeNode R){
          //黑盒判断当前左右节点，并处理特殊情况
          if(L==null && R == null) return true;
          
          //剪枝
          if(L==null || R==null || L.val!=R.val) return false;
  
          //返回最基础的类型
          return recur(L.left,R.right) && recur(L.right,R.left); 
      }
  ```

  - 复杂度分析

    ![1](appendix\二叉树11.png)

- 镜像：但要注意只能比较先序和后序，中序不可以

  ```java
  //先镜像，再对比先序或者后序，中序不可以
      //[1,2,2,2,null,2]中序镜像前后一致
      public static List<Integer> pre1,pre2;
  
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return true;
          //初始化
          pre1 = new ArrayList<>();
          pre2 = new ArrayList<>();
  
          preOrderRecur(root,pre1);
          preOrderRecur(mirrorTree(root),pre2);
          System.out.println("pre1: " + pre1);
          System.out.println("pre2: " + pre2);
          if(pre1.equals(pre2)){
              return true;
          }
          return false;   
      }
  
      public void preOrderRecur(TreeNode root,List<Integer> list){
          if(root==null){
              list.add(-1);
              return;
          }
  
          list.add(root.val);
          preOrderRecur(root.left,list);
          preOrderRecur(root.right,list);
          
      }
  
      public TreeNode mirrorTree(TreeNode root) {
          if(root==null) return null;
  
          //处理当前
          TreeNode tmp = mirrorTree(root.left);
          root.left = mirrorTree(root.right);
          root.right = tmp;
  
          return root;
      }
  ```
  
  
  
- 错误解法：左根右 = 右根左的遍历

  ```java
     //左根右 = 右根左的遍历
      //[1,2,2,2,null,2] 过不了,除了根节点，所有节点的val都一一样
  	//插入特殊值的情况下也不可以
      public static List<Integer> in1,in2;
  
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return true;
          //初始化
          in1 = new ArrayList<>();
          in2 = new ArrayList<>();
  
          inOrder1Recur(root);
          inOrder2Recur(root);
          System.out.println("in1: " + in1);
          System.out.println("in2: " + in2);
          if(in1.equals(in2)){
              return true;
          }
          return false;
      }
  
      public void inOrder1Recur(TreeNode root){
          if(root==null) return;
          inOrder1Recur(root.left);
          in1.add(root.val);
          inOrder1Recur(root.right);
          
      }
  
      public void inOrder2Recur(TreeNode root){
          if(root==null) return;
          inOrder2Recur(root.right);
          in2.add(root.val);
          inOrder2Recur(root.left);
      }
  ```


#### [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

- 层次遍历

  ```java
      public List<List<Integer>> levelOrder(TreeNode root) {
          //层次遍历
          //可变二维数组
          List<List<Integer>> res = new ArrayList<>();
          //队列,存储某一层的所有节点
          LinkedList<TreeNode> queue = new LinkedList<>();  
          
          //先添加头结点
          if(root!=null) queue.add(root);
  
          //处理
          while(!queue.isEmpty()){
              //新建一个当前层的打印结果
              List<Integer> tmp = new ArrayList<>();
              //遍历当前层的节点
              for(int i = queue.size();i > 0;i--){
                  //先出队列
                  TreeNode node  = queue.poll();
                  tmp.add(node.val);
  
                  if(node.left!=null) queue.add(node.left);
                  if(node.right!=null) queue.add(node.right);
              }
              res.add(tmp);
          }
          return res;
      }
  ```

#### [面试题32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

```java
    public int[] levelOrder(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        LinkedList<TreeNode> queue = new LinkedList<>();

        if(root!=null) queue.add(root);

        while(!queue.isEmpty()){
            for(int i = queue.size();i > 0;i--){
                TreeNode cur = queue.poll();
                res.add(cur.val);
                if(cur.left!=null) queue.add(cur.left);
                if(cur.right!=null) queue.add(cur.right);
            }
        }

        int[] res1 = new int[res.size()];
        for(int i=0;i<res.size();i++){
            res1[i] = res.get(i);
        }

        return res1;
    }
```

#### [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

- 错误解法

  ```java
      // 单队列会出错，因为队列，先进的会先处理，那么这一层和下一层的顺序就一样了
  	//所以要么queue变成双端队列，要么tmp变成双端队列（这个方便）
      public List<List<Integer>> levelOrder(TreeNode root) {
          List<List<Integer>> res = new ArrayList<>();
          //定义队列
          LinkedList<TreeNode> queue = new LinkedList<>();
          if(root!=null) queue.add(root);
  
          int level = 0;
          //while控制从上往下，for控制同一层从左往右
          while(!queue.isEmpty()){
              List<Integer> tmp = new ArrayList<>();  //存当前层的节点
              for(int i = queue.size();i>0;i--){
                  TreeNode cur = queue.poll();
                  tmp.add(cur.val);
                  //如果当前层是奇数，那么下一层的顺序是偶数的
                  if((level % 2)==1){
                      if(cur.left!=null) queue.add(cur.left);
                      if(cur.right!=null) queue.add(cur.right);
                  }else{
                      if(cur.right!=null) queue.add(cur.right);
                      if(cur.left!=null) queue.add(cur.left);
                  } 
              }
              level++;
              res.add(tmp);
          }
          return res;
      }
  ```

- 按照层数逆转列表

  ```java
      //tmp倒序
      public List<List<Integer>> levelOrder(TreeNode root) {
          List<List<Integer>> res = new ArrayList<>();
          //定义队列
          LinkedList<TreeNode> queue = new LinkedList<>();
          if(root!=null) queue.add(root);
  
          //while控制从上往下，for控制同一层从左往右
          while(!queue.isEmpty()){
              List<Integer> tmp = new ArrayList<>();  //存当前层的节点
              for(int i = queue.size();i>0;i--){
                  TreeNode cur = queue.poll();
                  tmp.add(cur.val);
                  if(cur.left!=null) queue.add(cur.left);
                  if(cur.right!=null) queue.add(cur.right);
              }
              //逆转列表
              if(res.size()%2==1) Collections.reverse(tmp);
              res.add(tmp);
          }
          return res;
      }
  ```

- 按照层数改变入队顺序

  ```java
       public List<List<Integer>> levelOrder(TreeNode root) {
          Queue<TreeNode> queue = new LinkedList<>();
          List<List<Integer>> res = new ArrayList<>();
          if(root != null) queue.add(root);
          while(!queue.isEmpty()) {
              LinkedList<Integer> tmp = new LinkedList<>();
              for(int i = queue.size(); i > 0; i--) {
                  TreeNode node = queue.poll();
                  if(res.size() % 2 == 0) tmp.add(node.val); // 偶数层 -> 队列尾部，正常
                  else tmp.addFirst(node.val); // 奇数层 -> 队列头部
                  if(node.left != null) queue.add(node.left);
                  if(node.right != null) queue.add(node.right);
              }
              res.add(tmp);
          }
          return res;
      }
  ```

#### [剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

 **此树的深度** 等于 **左子树的深度** 与 **右子树的深度** 中的 **最大值** +1+1

- 套路（罗列 + 信息）【后序？】

  ```java
      //平衡二叉树：针对每个子树，左右高度差不超过1
      //罗列：左树是平，右树是平，|左高-右高|<=1
      //信息：（递归，信息一致）（process收信息）
      // ​	左树：平？高？
      // ​	右树：平？高？
  
      public static class ReturnType{
          public boolean is;
          public int height;
  
          public ReturnType(boolean is, int height){
              this.is = is;
              this.height = height;
          }
      }
  
      public static ReturnType process(TreeNode node) {
  		if (node == null) {//base
  			return new ReturnType(true, 0);
  		}
  
          //黑盒
          ReturnType left = process(node.left);
          ReturnType right = process(node.right);
  
          int h = Math.max(left.height,right.height) + 1;
          boolean isB = left.is && right.is && Math.abs(left.height-right.height) <=1;
          return new ReturnType(isB, h);
      }
  
      public boolean isBalanced(TreeNode root) {
          return process(root).is;
      }
  ```

- 【先序遍历 + 判断深度 （从顶至底）】（递归套递归了）

  和判断子树一样都是递归套递归

  ```java
  //简写
  //为什么是先序：
  //abs(self.depth(root.left) - self.depth(root.right)) <= 1 ：判断 当前子树 是否是平衡树；
  //self.isBalanced(root.left) ：先序遍历递归，判断 当前子树的左子树 是否是平衡树；
  //self.isBalanced(root.right) ：先序遍历递归，判断 当前子树的右子树 是否是平衡树；
  
      public boolean isBalanced(TreeNode root) {
          if (root == null) return true;
          return Math.abs(depth(root.left) - depth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
      }
  
      private int depth(TreeNode root) {
          if(root==null) return 0;
          return Math.max(depth(root.left),depth(root.right)) + 1;
      }
  ```

  - 复杂度分析

    ![1](appendix\二叉树12.png)

- 【后序遍历 + 剪枝 （从底至顶）】（后序遍历的好处就是可以带着子节点的信息返回）

  ```java
      //后序遍历+减枝
      public boolean isBalanced(TreeNode root) {
          return recur(root)!= -1;
      }
  
      private int recur(TreeNode root) {
          if(root==null) return 0;
          int left = recur(root.left);
          if(left==-1) return -1;
          int right = recur(root.right);
          if(right==-1) return -1;
          return Math.abs(left-right) < 2? Math.max(left,right) + 1 : -1;
      }
  ```

  - 复杂度分析

    时间复杂度 O(N)： N为树的节点数；最差情况下，需要递归遍历树的所有节点。
    空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用O(N) 的栈空间。

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

基于二叉搜索树的中序遍历递增，则逆中序递减

- 浪费空间

  ```java
      //直接利用逆中序遍历，用数组存储，返回结果
      List<Integer> res;
      public int kthLargest(TreeNode root, int k) {
          res  = new ArrayList<>();
          inOrderReverse(root);
          return res.get(k-1);
      }
      
      public void inOrderReverse(TreeNode root){
          if(root==null) return;
  
          inOrderReverse(root.right);
          res.add(root.val);
          inOrderReverse(root.left);
  
      
  ```

- 提前返回, 想将参数设为全局变量就这么写

  ```java
      //提前返回
      //k变全局
      int res,k;
      public int kthLargest(TreeNode root, int k) {
          this.k = k;
          inOrderReverse(root);
          return res;
      }
  
      public void inOrderReverse(TreeNode root){
          if(root==null) return;
  
          inOrderReverse(root.right);
          k--;
          if(k==0) {
              res = root.val;
              return;
          }
          inOrderReverse(root.left);
      }
  ```

#### [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

- 哈希表，哈希set，从下往上生成链

  ```java
      //哈希表，哈希set
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          if(root==null) return null;
  
          //建哈希表
          HashMap<TreeNode,TreeNode> parentMap =  new HashMap<>();
          parentMap.put(root,null);
          buildParentMap(root,parentMap);
  
          //找p的链，向上，存入hashset
          HashSet<TreeNode> pSet = new HashSet<>();
          TreeNode cur = p;
          while(parentMap.get(cur)!=null){
              pSet.add(cur);
              cur = parentMap.get(cur);
              //System.out.println(cur.val);
          }
  
          //System.out.println();
          cur = q;
          while( cur!=null &&!pSet.contains(cur)){
              cur = parentMap.get(cur);
              //System.out.println(cur.val);
          }
          if(cur==null) return root;
          return cur;
      }
  
      public static void buildParentMap(TreeNode root,HashMap<TreeNode,TreeNode> parentMap){
  
          if(root.left!=null) {
              parentMap.put(root.left,root);
              buildParentMap(root.left,parentMap);
          }
  
          if(root.right!=null) {
              parentMap.put(root.right,root);
              buildParentMap(root.right,parentMap);
          }
      }
  ```

  

- 分析情况(先序遍历)

  ```java
      //先序从上向下进行遍历，最近公共祖先，注意判断所有情况
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          //处理特殊
          if(root==null) return null;
  
          //先序
          if(root==p || root==q) return root;
  
          TreeNode left = lowestCommonAncestor(root.left,p,q);
          TreeNode right = lowestCommonAncestor(root.right,p,q);
  
          if(left==null) return right;
          if(right==null) return left;
          return root;
      }
  ```

#### [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

若 root.val < p.va ，则 p在 root右子树 中；
若 root.val > p.val ，则 pp 在 root左子树 中；
若 root.val = p.val，则 p和 root指向 同一节点 

- 递归

  ```java
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          if(root==null || root==p || root==q) return root;  //base 先序
  
          if(p.val<root.val && q.val<root.val) return lowestCommonAncestor(root.left,p,q);
          if(p.val>root.val && q.val>root.val) return lowestCommonAncestor(root.right,p,q);
  
          return root;
      }
  ```

  - 时间复杂度 O(N) ： 其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 logN （满二叉树），最大为 N （退化为链表）。
    空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到树的层数 NN 。

    

- 迭代

  ```java
  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          //迭代
          while(root!=null){
              if(p.val < root.val && q.val< root.val){
                  root = root.left;
              }
              else if(p.val > root.val && q.val > root.val){
                  root = root.right;
              }
              else{
                  break;
              }
          }
          return root;
  
      }
  ```

  - 时间复杂度 O(N)O(N) ： 其中 NN 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 \log NlogN （满二叉树），最大为 NN （退化为链表）。
    空间复杂度 O(1)O(1) ： 使用常数大小的额外空间。

#### [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)（先序和中序）

太难了（分治）

- 基于以下原理

  ```java
  // 前序遍历的首元素 为 树的根节点 node 的值
  // 在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 
  // 根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ]
  
  // 分治算法解析：
  // 递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；
  // 终止条件： 当 left > right ，代表已经越过叶节点，此时返回 null ；
  // 递推工作：
  //     1. 建立根节点 node ： 节点值为 preorder[root] ；
  //     2. 划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；
  //         为了提升效率，本文使用哈希表 dic 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)；
  //     3. 构建左右子树： 开启左右子树递归；
  // =》推出
  // 中序遍历中左子树的边界[left,i-1]，先序遍历中root位置：root+1 
  // 中序遍历中右子树的边界[i+1,right],先序遍历中root位置：i-left+1+root
  
      int[] preorder; //先序序列
      HashMap<Integer,Integer> inoderMap = new HashMap<>();  //中序序列
      public TreeNode buildTree(int[] preorder, int[] inorder) {
          this.preorder = preorder;
  
          //为中序构建map
          for(int i = 0;i < inorder.length;i++){
              inoderMap.put(inorder[i],i);
          }
          return recur(0,0,inorder.length-1);
      }
  
      public TreeNode recur(int root,int left, int right){
          if(left > right) return null; //遇到空节点,递归终止
  
          TreeNode node = new TreeNode(preorder[root]);  //创建根节点
          int i = inoderMap.get(preorder[root]); //划分根节点，左子树，右子树
          node.left = recur(root+1,left,i-1); //递归构建左子树
          node.right = recur(i-left+1+root,i+1,right); //递归构建右子树
          return node;    //分治返回给根节点
      }
  ```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java

    int[] postorder; //先序序列
    HashMap<Integer,Integer> inoderMap = new HashMap<>();  //中序序列
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.postorder = postorder;

        //为中序构建map
        for(int i = 0;i < inorder.length;i++){
            inoderMap.put(inorder[i],i);
        }
        return recur(postorder.length-1,0,inorder.length-1);
    }

    public TreeNode recur(int root, int left, int right){
        if(left > right ||  root < 0) return null;
        // System.out.print(root + " ");
        TreeNode node = new TreeNode(postorder[root]);
        int i = inoderMap.get(postorder[root]);

        node.left = recur(root-right+i-1,left,i-1);
        node.right = recur(root-1,i+1,right);
    
        return node;
    }
```

#### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

- 假设是二叉搜索树，利用中序是升序求出升序
  - 相当于利用中序和后序建树，但是不建，只是进行判断
  - 如果是，则代码没有问题，但是当不是二叉搜索树时，会出现重复遍历节点，可以依据这个进行判断

```java
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) { val = x; }
    }

    int[] postorder;
    int[] inorder;
    ArrayList<Integer> inorder1;
    HashMap<Integer,Integer> inorderMap = new HashMap<>();

    public boolean verifyPostorder(int[] postorder) {
        this.postorder = postorder;

        //得到中序遍历的列表
        int[] inorder = new int[postorder.length];
        for(int i=0;i<postorder.length;i++){
            inorder[i] = postorder[i];
        }
        Arrays.sort(inorder);
        this.inorder = inorder;
        // for(int i=0;i<inorder.length;i++){
        //     System.out.print(inorder[i]+" ");
        // }
        

        //将中序列表放入hashMap
        for(int i =0;i < inorder.length;i++){
            inorderMap.put(inorder[i],i);
        }

        //利用中序和后序建二叉树 改
        return recur(postorder.length-1,0,inorder.length-1);
    }

    HashSet<Integer> tmp = new HashSet<>();
    public boolean recur(int root, int left, int right){
        if(left > right ||  root < 0) return true; //处理叶节点

        //如果不是二叉树则会重复陷入死循环
        if(tmp.contains(postorder[root])) return false;
        // System.out.print(root+" ");
        TreeNode node = new TreeNode(postorder[root]);
        tmp.add(node.val);
        int i = inorderMap.get(postorder[root]);
        
        if(recur(root-right+i-1,left,i-1) && recur(root-1,i+1,right))
            return true;
        return false;
    }

    public void inorderRecur(TreeNode root){
        if(root==null) return;

        inorderRecur(root.left);
        inorder1.add(root.val);
        inorderRecur(root.right);
    }
```

- 标准：找出左右子树的分割点,则左树都小于根，右树都大于根，然后判断

  ```java
      // 方法二
      public boolean verifyPostorder(int[] postorder) {
          return recur(postorder, 0,postorder.length-1);
      }
  
  
      //J为根节点
      public boolean recur(int[] postorder, int i , int j){
          if(j > i) return true;
  
          int p = i;
          //p为大于根的一个数(作为左右子树的分界点)
          while(postorder[p] < postorder[j]) p++;
          int m = p; //此时m及m之后的为右子树，看能否走到底
          while(postorder[p] > postorder[j]) p++;
          return p==j && recur(postorder,i,m-1) && recur(postorder,m,j);
      }
  ```

- 假设是二叉搜索树，利用中序是升序求出升序【**好好研磨一下，感谢室友大腿帮我调了两个小时bug**】

  - 相当于利用中序和后序建树，但是不建，只是进行判断
  - 利用先序遍历 + 二叉搜索树左小右大的性质进行判断
  - 递归终止条件是左右子树都是空，而左右子树单独存在是子问题的情况之一，既然分不清就不要ran一起
  - 记得判空

  ```java
  
     	int[] postorder;
      int[] inorder;
      HashMap<Integer,Integer> inorderMap = new HashMap<>();
      public boolean verifyPostorder(int[] postorder) {
          if(postorder.length==0) return true;
          this.postorder = postorder;
  
          //得到中序遍历的列表
          inorder = new int[postorder.length];
          this.inorder = inorder;
          for(int i=0;i < postorder.length;i++){
              inorder[i] = postorder[i];
          }
  
          Arrays.sort(inorder);
  
          //把信息放入hashmap
          for(int i =0; i < inorder.length; i++){
              inorderMap.put(inorder[i],i);
          }
  
          return recur(postorder.length-1,0,inorder.length-1);
      }
  
      public boolean recur(int root,int left,int right){
          //左右节点都不存在的时候，可以直接返回true
          //建树的时候没有等是因为要给叶子节点创建空间
           if(left >= right || root < 0) return true;
          int inindex  = inorderMap.get(postorder[root]);
          // for(int i=left;i<=right;i++){
          //     System.out.print(inorder[i] + " ");
          // }
          // System.out.println("end arr");
          //  System.out.println("root: "+ root  + "left" + left + "right" + right);
  
          //left>=right 表示只有根节点，或者左右子树不存在
          //root-1 < 0 表示右子树不存在，但这个条件不全（有问题），因为在后序遍历【左右根】中存在，有左无右，root-1>0但没有右子树
          //right - inindex < 1 表示右子树不存在（上个条件的替换）
          //root-right+inindex-1 < 0 表示左子树不存在
          //if(left >= right || root < 1 || root-right+inindex-1 < 0 || right - inindex < 1) return true;
          //但是此处逻辑不对，没有右子树就返回true，不管有没有左 [4, 6, 7, 5]
          //没有左子树就返回true，不管有无右  [3,10,6,9,2]
          //应该分开判断
          int rootval = postorder[root];
          // System.out.println("root: "+ root +   " "   + postorder[root]);
          // System.out.println("inindex: "+ inindex);
          // int leftval = postorder[root-right+inindex-1];
          // System.out.println("leftindex: "+ (int)(root-right+inindex-1));
          // int rightval = postorder[root-1];
          // System.out.println("rigthindex: "+ (int)(root-1));
          // System.out.print(rootval + " "+ leftval + " "+ rightval);
          // System.out.println();
          
          //设置一个初始值，如果存在左子树，进行判断
          boolean f1 = true;
          if(root-right+inindex-1 >= 0){
              int leftval = postorder[root-right+inindex-1];
              if(leftval > rootval) f1 = false;
          }
          //设置一个初始值，如果存在右子树，进行判断
          boolean f2 = true;
          if(right - inindex >= 1){
              int rightval = postorder[root-1];
              if(rightval < rootval) f2 = false;
          }
  
          //剪枝
          // if(leftval > rootval || rightval < rootval) return false;
          if(!f1||!f2) return false;
  
          return recur(root-right+inindex-1,left,inindex-1)&&recur(root-1,inindex+1,right);
      }
  
  ```

  

#### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

- 递归套递归，其实就是遍历A的每个节点x, 判断以x为根的子树是否包含B

  ```java
      //先序遍历树A的每个节点
      public boolean isSubStructure(TreeNode A, TreeNode B) {
          if(A==null || B==null) return false;
  
          return recur(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);   
      }
  
      //判断以A为节点的子树是否包含B
      public boolean recur(TreeNode A,TreeNode B){
          //B树遍历完了，说明是
          if(B==null) return true;
          //两个节点不相等
          //A==null说明isSubStructure函数遍历到最后了
          if(A==null || A.val!=B.val) return false;
      
          return recur(A.left,B.left) && recur(A.right,B.right);
  
      }
  ```

#### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

- 利用中序遍历，维护全局的pre和head

  ```java
      Node pre,head;
      public Node treeToDoublyList(Node root) {
          if(root==null) return null;
          dfs(root);
          //链接头尾
          head.left = pre;
          pre.right = head;
          return head;
      }
  
      //利用中序遍历
      public void dfs(Node cur){
          if(cur==null) return;
  
          dfs(cur.left);
          //用一个判断确定是否是头
          if(pre!=null){
              pre.right = cur;
          }else{
              head = cur;
          }
          cur.left = pre;
          pre = cur;
  
          dfs(cur.right);
      }
  ```

#### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

- 先序遍历+记录path，遍历还是一样的遍历（递归终止条件没变），回溯指维护path中的节点

  ```java
      //先序遍历 + 记录
      LinkedList<List<Integer>> res = new LinkedList<>();
      LinkedList<Integer> path = new LinkedList<>(); 
      public List<List<Integer>> pathSum(TreeNode root, int target) {
          recur(root, target);
          return res;
      }
  
      void recur(TreeNode root,int target){
          if(root==null) return;
  
          path.add(root.val);
          target -= root.val;
  
          //和为target, 且当前节点为叶子节点
          if(target==0 && root.left==null && root.right==null){
              //因为path是全局，如果这样加入，后面改变则都改变了
              //res.add(path);
              //所以需要创建一个新的空间加入
              res.add(new LinkedList(path));
          }
  
          recur(root.left,target);
          recur(root.right,target);
  
          path.removeLast();  //path回溯返回上一层
  
      }
  ```

#### [剑指 Offer 37. 序列化二叉树  LCOF](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

分治

```java
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null){
            return "#!";
        }
        StringBuilder res = new StringBuilder();
        //以“！”做分割，以防止分不清是1和3还是13
        res.append(root.val + "!");
        res.append(serialize(root.left));
        res.append(serialize(root.right));
        // System.out.println(res);
        return res.toString();
    }

    // Decodes your encoded data to tree.
    Queue<String> queue;
    public TreeNode deserialize(String data) {
        String[] numbers = data.split("!");
        queue = new LinkedList<String>();

        //添加到队列
        for(int i=0; i<numbers.length;i++){
            queue.offer(numbers[i]);
        }

        return recur();
    }
    
    //先序遍历 + 分治
    public TreeNode recur(){
        //当头结点为空的时候，poll()选择返回null，pop()选择抛出异常
        //空不了
        String value = queue.poll();
		if (value.equals("#")) {
			return null;
		}
		TreeNode head = new TreeNode(Integer.valueOf(value));
        // System.out.println("b" + value);
		head.left = recur();
		head.right = recur();
		return head;
    }
```

### - 递归

#### [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

- 正常递归

  ```java
      //正常递归
      public int sumNums(int n) {
          if(n==1) return 1;
  
          return n + sumNums(n-1);
      }
  ```

  

- 利用短路构成语句代替if条件

  if(A && B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A && B 为 false

  if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true

  ```java
      //利用短路代替if条件判断
      public int sumNums(int n) {
          boolean x = n > 1 && (n += sumNums(n-1)) > 0;
  
          return n;
      }
  
  // Java 中，为构成语句，需加一个辅助布尔量 xxx ，否则会报错；
  // Java 中，开启递归函数需改写为 sumNums(n - 1) > 0 ，此整体作为一个布尔量输出，否则会报错；
  // 初始化变量 resresres 记录结果。（ Java 可使用上面的简洁写法，不用借助变量 resresres ）。
  
      int res = 0;
      public int sumNums(int n) {
          boolean x = n > 1 && sumNums(n-1) > 0;
  
          res += n;
  
          return res;
      }
  ```

#### [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

- 递归+快速幂

  ```java
      public double myPow(double x, int n) {
          long b = n;
          if (n < 0) {
              b = -b;
              x = 1 / x;
          }
          return culc(x, b);
      }
  
      public double culc(double base, long power) {
          if (power == 0) {
              return 1;
          }
  
          double t = culc(base, power >> 1);
  
          if ((power & 1) == 1) {
              return t * t * base;
          }
  
          return t * t;
      }
  ```

  

- 快速幂、二分、位运算、迭代

  向下整除 n//2 等价于 右移一位n>>1 ；
  取余数 n%2 等价于 判断二进制最右一位值 n&1 ；

  ```java
      public double myPow(double x, int n) {
          if(x == 0) return 0;
          long b = n;
          double res = 1.0;
          if(b < 0) {
              x = 1 / x;
              b = -b;
          }
          while(b > 0){
              if((b&1)==1) res = res*x;  //如果为奇数,多乘一个x
              x *= x; //x*x
              b >>= 1;  // b//=2;
          }
          return res;
      }
  ```

  注意：

  ```java
  Java 代码中 int32 变量 n∈[-2147483648, 2147483647]，因此当 n=−2147483648时执行 n=−n 会因越界而赋值出错。解决方法是先将 n 存入 long 变量b ，后面用 b 操作即可。
  ```

  

  

  二进制获取每一位：

  获取二进制各位 b1,b2,b3,...,bm 的值： 循环执行以下操作即可。

      n&n （与操作）： 判断 n 二进制最右一位是否为 111 ；
      n>>1 （移位操作）： n右移一位（可理解为删除最后一位）。


深度优先搜索类型的题可以分为主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否可以开始搜索，如果可以即在辅函数进行搜索。辅函数则负责深度优先搜索的递归调用。

base: 最后在边界的时候才返回

治：最后return 

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

- 深搜 + 递归
  - 技巧：控制搜索方向的数组，di和dj相对应着
  - 注意边界，以及已经搜过了的节点要进行标记

```java
    //该题不是回溯，是深搜，遍历最大的相邻为1的和
    //主函数：遍历所有搜索位置
    public int maxAreaOfIsland(int[][] grid) {
        int ans = 0;
        for(int i = 0;i < grid.length; i++){
            for(int j=0;j<grid[0].length;j++){
                ans = Math.max(ans,dfs(grid,i,j));
            }
        }
        return ans;
    }

    //辅函数：用于做深搜
    //当前的头节点位置
    public int dfs(int[][] grid,int i,int j){
        if(i < 0 || j < 0 || i==grid.length || j==grid[0].length){  //base:边界
            return 0;
        }
        //只有当前位置为1才进行搜索
        if(grid[i][j]==0){
            return 0;
        }

        //代表当前节点已经被搜索过了，之后不再进行搜索了
        grid[i][j] = 0;
        //由di和dj分别对应控制上下左右（往四个地方去做搜索）
        int[] di = {0,0,-1,1};
        int[] dj = {1,-1,0,0};

        int ans = 1;
        for(int index = 0;index < 4;index++){
            int next_i = i + di[index];
            int next_j = j + dj[index];
            //进行深搜
            ans += dfs(grid,next_i,next_j);
        }
        return ans;
    }
```

#### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

边界条件一定要想清楚

- 深度优先遍历+剪枝

  ```java
      public boolean exist(char[][] board, String word) {
  
          for(int i = 0;i < board.length;i++){
              for(int j=0;j < board[0].length;j++){
                  boolean[][] used = new boolean[board.length][board[0].length];
                  boolean res = dfs(board,i,j,word,0,used);
                  if(res){
                      return true;
                  }
              }
          }
          return false;
      }
  
      //二维数组，以当前（i,j）节点为头开始递归，word所求词，idx为遍历到word的第几个词,判断当前节点有无被访问过
      public boolean dfs(char[][]board, int i, int j, String word,int idx,boolean[][]used){
          //如果当前字符也不相等，则直接返回（剪枝）+ 边界
          //边界条件没有想清楚
          if(i < 0 || j < 0 || i == board.length || j==board[0].length || board[i][j]!=word.charAt(idx)){
              return false;
          }
          
          //排除遍历过的节点
          if(used[i][j]) return false;
  
          if(idx == word.length()-1 ) return true;
  
          //将当前节点标记为已访问
          used[i][j] = true;
  
          //定义上下左右四个方向 
          int[] di ={0,0,-1,1};
          int[] dj = {1,-1,0,0};
          
          //开始递归
          boolean res = false;
          for(int k = 0; k<4 ;k++){
              res |= dfs(board,i+di[k],j+dj[k],word,idx+1,used);
          } 
  
          //回溯
          // 因为只代表此次搜索过程中，该元素已访问过，当初始i j变化时，又开始了另一次搜索过程
          used[i][j] = false;
          return res;
  
      }
  ```

  

- 省时间省空间的做法

  ```java
      //省空间的做法，更改当前已访问过的元素，在结束此次搜索后还原
      public boolean exist(char[][] board, String word) {
          char[] words = word.toCharArray();
          for(int i = 0;i < board.length;i++){
              for(int j=0;j < board[0].length;j++){
                  boolean res = dfs(board,i,j,words,0);
                  if(res){
                      return true;
                  }
              }
          }
          return false;
      }
  
      //二维数组，以当前（i,j）节点为头开始递归，word所求词，idx为遍历到word的第几个词,
      public boolean dfs(char[][]board, int i, int j, char[] word,int idx){
          //如果当前字符也不相等，则直接返回（剪枝）+ 边界
          //边界条件没有想清楚
          if(i >= board.length || i < 0 || j>=board[0].length || j < 0 || board[i][j]!=word[idx]){
              return false;
          }
          
          //排除遍历过的节点
          // if(board[i][j]=='\0') return false;
  
          if(idx == word.length-1 ) return true;
  
          //将当前节点标记为已访问
          // char tmp = board[i][j];
          board[i][j]='\0';
  
          //定义上下左右四个方向 
          int[] di ={0,0,-1,1};
          int[] dj = {1,-1,0,0};
          
          //开使递归
          //只是针对此次搜索的res
          // boolean res = false;
          for(int k = 0; k<4 ;k++){
              if(dfs(board,i+di[k],j+dj[k],word,idx+1)) return true;  //再进行一次剪枝，直接返回
          } 
  
          //回溯
          // 因为只代表此次搜索过程中，该元素已访问过，当初始i j变化时，又开始了另一次搜索过程
          // board[i][j] = tmp;
          board[i][j] = word[idx];
          return false;
  
      }
  ```

#### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

- 暴力dfs + 剪枝 ，这个不用回溯，因为每个节点访问一次就可得出结论，并不是要路径什么的

  ```java
      public int movingCount(int m, int n, int k) {
          if(k==0) return 1;
  
          boolean[][] used = new boolean[m][n];
  
          return dfs(m,n,k,0,0,used);
          // return bitSum(k);
      }
  
      //i表示当前在i行，j列,标志位
      public int dfs(int m,int n,int k,int i,int j,boolean[][]used){
          if(i<0 || j<0 || i==m || j==n || bitSum(i)+bitSum(j) > k || used[i][j]){
              return 0;
          }
  
          used[i][j] = true;
  
          int[] di = {0,0,-1,1};
          int[] dj = {1,-1,0,0};
          int res = 0;
  
          res++;
          for(int idx = 0; idx < 4;idx++){
              res += dfs(m,n,k,i+di[idx],j+dj[idx],used); 
          }
  
          //不用回溯，每个节点遍历一遍即可
          // used[i][j] = false;
          return res;
      }
  
  
      public int bitSum(int num){
          int k = num;
          int res = 0;
          while(k!=0){
              res += k%10;
              k = k/10;
          }
          // int res = num%10 + num/10;
          return res;
      }
  ```

  



### - 回溯

感觉一部分用于优化深搜，免除浪费很多中间变量

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

- 优化前(太复杂了)

  ```java
      public List<List<Integer>> permute(int[] nums) {
          int len = nums.length;
          // 使用一个动态数组保存所有可能的全排列
          List<List<Integer>> res = new ArrayList<>();
          if (len == 0) {
              return res;
          }
  
          boolean[] used = new boolean[len];
          Deque<Integer> path = new ArrayDeque<>(len);
  
          dfs(nums, len, 0, path, used, res);
          return res;
      }
  
      private void dfs(int[] nums, int len, int depth,
                       Deque<Integer> path, boolean[] used,
                       List<List<Integer>> res) {
          if (depth == len) {
              //变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表,会使res为空
              res.add(new ArrayList<>(path));
              return;
          }
  
          for (int i = 0; i < len; i++) {
              if (!used[i]) {
                  path.addLast(nums[i]);
                  used[i] = true;
  
                  System.out.println("  递归之前 => " + path);
                  dfs(nums, len, depth + 1, path, used, res);
  
                  used[i] = false;
                  path.removeLast();
                  System.out.println("递归之后 => " + path);
              }
          }
      }
  ```

- 好理解的上个版本

  ```java
      public List<List<Integer>> permute(int[] nums) {
          List<List<Integer>> res = new ArrayList<>();
          List<Integer> path = new ArrayList<>();
          dfs(nums,path,res);
          return res;
      }
  
      public void dfs(int[] nums,List<Integer> path,List<List<Integer>> res){
          //叶子结点返回
          if(path.size()==nums.length){
              res.add(new ArrayList(path));
              return;
          }
  
          //控制分支，宽度
          for(int i=0;i <nums.length; i++){
              //操作
              if(path.contains(nums[i])){
                  continue;
              }
              path.add(nums[i]);
  
              //递归
              dfs(nums,path,res);
  
              //状态重置
              path.remove(path.size()-1);
          }
      }
  ```

- 创建新的中间变量则无需回溯

  每一次尝试都「复制」，则不需要回溯

  如果在每一个 非叶子结点 分支的尝试，都创建 新的变量 表示状态，那么
      在回到上一层结点的时候不需要「回溯」；
      在递归终止的时候也不需要做拷贝。
      这样的做法虽然可以得到解，但也会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。

  ```java
  public List<List<Integer>> permute(int[] nums) {
          // 首先是特判
          int len = nums.length;
          // 使用一个动态数组保存所有可能的全排列
          List<List<Integer>> res = new ArrayList<>();
  
          if (len == 0) {
              return res;
          }
  
          boolean[] used = new boolean[len];
          List<Integer> path = new ArrayList<>();
  
          dfs(nums, len, 0, path, used, res);
          return res;
      }
  
      private void dfs(int[] nums, int len, int depth,
                       List<Integer> path, boolean[] used,
                       List<List<Integer>> res) {
          if (depth == len) {
              // 3、不用拷贝，因为每一层传递下来的 path 变量都是新建的
              res.add(path);
              return;
          }
  
          for (int i = 0; i < len; i++) {
              if (!used[i]) {
                  // 1、每一次尝试都创建新的变量表示当前的"状态"
                  List<Integer> newPath = new ArrayList<>(path);
                  newPath.add(nums[i]);
  				
                  // 1、每一次尝试都创建新的变量表示当前的"状态"
                  boolean[] newUsed = new boolean[len];
                  System.arraycopy(used, 0, newUsed, 0, len);
                  newUsed[i] = true;
  
                  dfs(nums, len, depth + 1, newPath, newUsed, res);
                  // 2、无需回溯
              }
          }
      }
  ```

这就好比我们在实验室里做「对比实验」，每一个步骤的尝试都要保证使用的材料是一样的。我们有两种办法：

【全局】每做完一种尝试，都把实验材料恢复成做上一个实验之前的样子，只有这样做出的对比才有意义；

【局部】每一次尝试都使用同样的新的材料做实验

- 优化后(交换)

  ```java
      //相当于填nums.length长的数，不重不漏
      //注意刚开始为空
  
      //调用函数
      List<List<Integer>> res;
      public List<List<Integer>> permute(int[] nums) {
          res = new ArrayList<List<Integer>>();
          List<Integer> tmp = new ArrayList<>();
          for(int num:nums){
              tmp.add(num);
          }
          dfs(nums.length,0,tmp);
          return res;
      }
  
      //总共要填的数的数目，当前填到哪个数的下标，这一次的结果
      public void dfs(int length,int index, List<Integer> tmp){
          if(index == length){
              res.add(new ArrayList<Integer>(tmp));
              return;
          }
          //在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现
          //在当前位置，前面的数都排列好了，后面的数没有排列
          //在当前位置下，选定下一个数有多少种可能，就和二叉树一样，需要遍历左右孩子一样
          for(int i = index;i < length;i++){
              Collections.swap(tmp, index,i);
              dfs(length,index+1,tmp); //继续递归填下一个数
              Collections.swap(tmp, index,i); //状态重置
          }
      }
  ```

#### [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)（注意是包含可重复的字符）

平时used数组的作用是代表当前节点我是否选择过了，防止对同一位置上的节点重复选择

并不表示不同位置相同节点上的重复，当含有重复字符时，需要对结果去重

- 费空间的做法

```java
public String[] permutation(String s) {
        if (s==null) return new String[0];
        char[] cs = s.toCharArray();
        StringBuilder path = new StringBuilder();
        // List<String> res = new ArrayList<>();
        HashSet<String> res = new HashSet<>(); //最后结果去重
        boolean[] flag = new boolean[cs.length];  //代表当前节点我是否选择过了，防止对同一位置上的节点重复选择
        //重复，boolean类型的变量，默认是false
        //并不表示不同位置相同节点上的重复
        
        dfs(cs,path,res,flag);

        String[] ans = new String[res.size()];
        int idx = 0;
        for (String str : res) ans[idx++] = str;
        return ans;
    }

    public void dfs(char[]cs, StringBuilder path,HashSet<String> res,boolean[] flag){
        if(path.length()==cs.length){
            res.add(new String(path.toString()));
            return;
        }

        for(int i=0;i < cs.length;i++){
            //不能这么判断，如果里面有重复的字符的就会报错，且会使path.length()==cs.length长度永不相等
            //题目要求可以重复
            //path.toString().contains((String.valueOf(cs[i])))
            if(flag[i])
                continue;
            path.append(cs[i]);
            flag[i] = true;
            dfs(cs,path,res,flag);
            path.deleteCharAt(path.length()-1);
            flag[i] = false;
        }
    }

```

- 交换不费空间

```java
    //采用交换的方式
    public String[] permutation(String s) {
        if (s==null) return new String[0];
        char[] cs = s.toCharArray();
        HashSet<String> res = new HashSet<>(); //最后结果去重
        
        dfs(cs,0,res);

        String[] ans = new String[res.size()];
        int idx = 0;
        for (String str : res) ans[idx++] = str;
        return ans;
    }

    public void dfs(char[]cs, int index, HashSet<String> res){
        //注意此处length要减一
        if(index == cs.length-1){
            res.add(String.valueOf(cs));
            return;
        }

        for(int i = index;i < cs.length;i++){
            swap(cs,i,index);
            dfs(cs,index+1,res);
            swap(cs,i,index);
        }
    }

    public void swap(char[]cs,int i,int j){
        char tmp = cs[i];
        cs[i] = cs[j];
        cs[j] = tmp;
    }
```

- 如果是不包含重复字符可以这么写

```java
    // 感觉此题只能对结果去重了！不是
    //采用交换的方式+去重，不可行，如遇到重复，index无法到达
    public String[] permutation(String s) {
        if (s==null) return new String[0];
        char[] cs = s.toCharArray();
        List<String> res = new ArrayList<>(); 
        //保证没有重复的字符
        //如果只有小写的字母可以写成，boolean[] used =new boolean[26];
        HashSet<Character> used = new HashSet<>(); 
        
        dfs(cs,0,res,used);

        String[] ans = new String[res.size()];
        int idx = 0;
        for (String str : res) ans[idx++] = str;
        return ans;
    }

    public void dfs(char[]cs, int index, List<String> res,HashSet<Character> used){
        if(index == cs.length){
            res.add(String.valueOf(cs));
            return;
        }

        for(int i = index;i < cs.length;i++){
            if(used.contains(cs[i])){
                continue;
            }
            swap(cs,i,index);
            used.add(cs[i]);
            dfs(cs,index+1,res,used);
            swap(cs,i,index);
            used.remove(cs[i]);
        }
    }

    public void swap(char[]cs,int i,int j){
        char tmp = cs[i];
        cs[i] = cs[j];
        cs[j] = tmp;
    }
```

- 最优解：去重

   //交换是为了保证对当前位置index进行选择，不否空间
   

  //加hashset，是为了保证有重复字符是不进行多余的分支

```java

    //修改下剪枝条件
    //交换是为了保证对当前位置index，不重复
    //加hashset，是为了保证有重复字符是不进行多余的分支
    public String[] permutation(String s) {
        if (s==null) return new String[0];
        char[] cs = s.toCharArray();
        List<String> res = new ArrayList<>(); 
        //保证没有重复的字符
        //如果只有小写的字母可以写成，boolean[] used =new boolean[26];
        
        dfs(cs,0,res);

        String[] ans = new String[res.size()];
        int idx = 0;
        for (String str : res) ans[idx++] = str;
        return ans;
    }

    public void dfs(char[]cs, int index, List<String> res){
        if(index == cs.length-1){
            res.add(String.valueOf(cs));
            return;
        }

        //在此层时，需要判断重复，重复则不给分支（不交换）
        HashSet<Character> used = new HashSet<>();
        for(int i = index;i < cs.length;i++){
            if(used.contains(cs[i])){
                continue;
            }
            used.add(cs[i]);
            swap(cs,i,index);
            dfs(cs,index+1,res);
            swap(cs,i,index);
            // used.remove(cs[i]);
        }
    }

    public void swap(char[]cs,int i,int j){
        char tmp = cs[i];
        cs[i] = cs[j];
        cs[j] = tmp;
    }
```

### - 动态规划

#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

- 递归法：
  原理： 把 f(n)问题的计算拆分成 f(n-1)和 f(n-2)两个子问题的计算，并递归，以f(0) 和 f(1)为终止条件。
  缺点： 大量重复的递归计算，例如 f(n) 和 f(n - 1)两者向下递归需要 各自计算 f(n - 2)的值。

  ```java
      public int fib(int n) {
          if(n<=1) return n;
          return fib(n-1)+fib(n-2);
      }
  ```

  

- 记忆化递归法：
  原理： 在递归法的基础上，新建一个长度为 n 的数组，用于在递归时存储 f(0)至 f(n)的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。
  缺点： 记忆化存储需要使用 O(N) 的额外空间。

- 动态规划：
  原理： 以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1) 为转移方程。
  从计算效率、空间复杂度上看，动态规划是本题的最佳解法。

  ```java
      //动态优化
      public int fib(int n){
          if(n < 2) return n;
  
          int a = 0;
          int b = 1;
          int sum = 0;
          for(int i=2; i<=n; i++){
              sum = (a + b)%1000000007;
              a = b ;
              b = sum;
          }
          return sum;
      }
  ```

#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

- 动态规划

  ```java
      //动态优化
      public int numWays(int n){
          if(n == 0 || n == 1) {
              return 1;
          }
  
          int a = 1;
          int b = 1;
          int sum = 0;
          for(int i=2; i <= n; i++){
              sum = (a + b)%1000000007;
              a = b;
              b = sum;
          }
  
          return sum;
      }
  ```

- 深搜

  ```java
  
      int count;
      public int numWays(int n) {
          count = 0;
          dfs(n);
          return count % 1000000007;
      }
      
      public void dfs(int n){
          if(n == 0 || n==1) {
              count += 1;
              return;
          }
          if(n == 2) {
              count += 2;
              return;
          } 
  
          dfs(n-1);
          dfs(n-2);
      }
  ```

- 递归

  ```java
      //和数列一样   
      public int numWays(int n){
          if(n == 0 || n==1) {
              return 1;
          }
          if(n == 2) {
              return 2;
          } 
  
          return (numWays(n-1) + numWays(n-2))%1000000007;
      }
  ```

#### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

- 暴力模拟

  ```java
      //方法一，模拟
      //LinkedList会超时,ArrayList勉强可以通过
      public int lastRemaining(int n, int m) {
          ArrayList<Integer> list =  new ArrayList<>();
          for(int i=0; i<n ;i++){
              list.add(i);
          }
  
          int idx = 0;
          while(n > 1){
              idx = (idx + m - 1)%n;
              list.remove(idx);
              n--;
          }
          return list.get(0);
      }
  ```

  

- 递归

  ```java
      //约瑟夫环
      //递归
      public int lastRemaining(int n, int m) {
          if(n==1) return 0; //base
  
          //考虑x已知的情况的下,n-1个环所留下的数
          int x = lastRemaining(n-1,m);
  
          return (x + m)%n;
  
      }
  ```

  

- 动态规划

  ![](appendix\y1.png)

状态转移

![](appendix\y2.png)

```java
    //迭代
    //动态优化
    public int lastRemaining(int n, int m) {
        int x = 0;
        for (int i = 2; i <= n; i++) {
            x = (x + m) % i;
        }
        return x;
    }
```

#### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

- 暴力解法

  ```java
  //计算以0为开头的最大和
  //计算以....i为开头的最大和【从i到j】
  //最后求这些和里的最大和
  public int maxSubArray(int[] nums) {
          int max = Integer.MIN_VALUE;
          for(int i=0;i<nums.length;i++){
              int sum = 0;
              for(int j = i;j<nums.length;j++){
                  sum += nums[j];
                  if(sum > max){
                      max = sum;
                  } 
              }
          }
          return max;
      }
  ```

- 动态规划1:

  如果我们每次能在最右侧得到该行的最大值，然后再求这么多最大值的最大值，岂不就能在O(n)内计算出结果？		
  sum(0,0) 																 dp[0]
  sum(0,1) 	sum(1,1) 											 dp[1]
  sum(0,2) 	sum(1,2) 	sum(2,2) 						dp[2]
  sum(0,3) 	sum(1,3) 	sum(2,3) 	sum(3,3) 	dp[3]
  ..... 	... 	... 	.... 												   dp[j]

  表格每一行的子数组都是以某一值结尾，所以我们设dp[j]为以j结尾的子数组的最大值，如上面表格所示。dp[j]的最大值就是我们要的结果。

  （以某个数作为结尾，意思就是这个数一定会加上去，那么要看的就是这个数前面的部分要不要加上去。大于零就加，小于零就舍弃。）

  ![](appendix\42.png)

  ```java
      //动态优化
      public int maxSubArray(int[] nums) {
          if(nums.length==0) return Integer.MIN_VALUE;
          if(nums.length==1) return nums[0];
  
          int[] dp = new int[nums.length];
          dp[0] = nums[0];
          int max = dp[0];  //此处要设成dp[0],否则会没有检查到dp[0]
          for(int i=1; i< nums.length;i++){
              dp[i] = Math.max(dp[i-1],0) + nums[i];
              max = Math.max(dp[i],max);
          }
          return max;
      }
  ```

- 优化动态规划（原地存储）

  将dp的值存入原数组

  ```java
      //优化使用空间，原地存储
      public int maxSubArray(int[] nums) {
          if(nums.length==0) return Integer.MIN_VALUE;
          if(nums.length==1) return nums[0];
          
          int res = nums[0];
          //将当前dp的值存入原数组
          for(int i=1;i<nums.length;i++){
              nums[i] = Math.max(nums[i-1],0) + nums[i];
              res = Math.max(res,nums[i]);
          }
          return res;
      }
  ```

- 优化动态规划空间（滑动数组）

  ```java
      //使用滑动数组
      public int maxSubArray(int[] nums) {
          if(nums.length==0) return Integer.MIN_VALUE;
          if(nums.length==1) return nums[0];
  
          int dp = nums[0];
          int max = nums[0];
          for(int i=1;i<nums.length;i++){
              //以某个数作为结尾，意思就是这个数一定会加上去，那么要看的就是这个数前面的部分要不要加上去。
              dp = Math.max(dp + nums[i],nums[i]);
              max = Math.max(max,dp);
          }
  
          return max;
      }
  ```

#### [剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

- 动态规划

  ```java
      //动态规划
      //状态定义：dp[i],前i日能获得的最大利润
      //状态转移方程：dp[i] = max(dp[i-1],prices[i]-min(prices[0:i-1]))
      //初始状态：dp[0] = 0
      //结果：dp[len-1]
      //多开辟了一个空间
      public int maxProfit(int[] prices) {
          if(prices==null || prices.length < 2) return 0;
          
          int len = prices.length;
          int[] dp = new int[len+1];
          dp[0] = 0;
          int cost = Integer.MAX_VALUE;
          for(int i = 1;i <= len;i++ ){
              dp[i] = Math.max(dp[i-1],prices[i-1]-cost);
              cost = Math.min(cost,prices[i-1]);
          } 
  
          return dp[len];
      }
  ```

  

- 动态规划空间优化

  ```java
  
      //优化空间
      // 由于 dp[i]dp[i]dp[i] 只与 dp[i−1] , prices[i] , cost相关，因此可使用一个变量（记为利润 profit ）代替dp列表
      public int maxProfit(int[] prices) {
          if(prices==null || prices.length < 2) return 0;
          
          int profit = 0;
          int cost = Integer.MAX_VALUE;
          for(int price:prices){
              profit = Math.max(profit,price-cost);
              cost = Math.min(cost,price);
          }
          return profit;
      }
  ```

#### [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

丑数只包含因子 2,3,5，因此有 “丑数 = 某较小丑数 × 某因子” ！！！（注意是只包含）

- 错误解法：不理解丑数的性质

  ```java
      public int nthUglyNumber(int n) {
          if(n==0) return 0;
  
          int count  = 1;
          int i = 2;
          for(; count <= n-1 ; i++ ){
              //质因数不能这么判断 14不是丑数 他的质因数除了2还有7
              if( i%2==0 || i%3==0 || i%5==0){
                  count++;
                  // System.out.println("i:" + i +"\tcount:"+count);
              }
          }
          return i-1;
      }
  ```

- 动态优化:

  n2，n3, n5设计的比较巧妙

  ```java
      //利用丑数的性质
      //丑数只包含因子 2,3,5，因此有 “丑数 = 某较小丑数 × 某因子” 
      //状态：dp[i]，代表第i+1个丑数，因为1为丑数
      //状态转移方程：
          // dp[i] = min(dp[a]*2,dp[b]*3,dp[c]*5)
          // 其中，a,b,c满足以下条件
          // dp[a]×2>dp[i−1]≥dp[a−1]×2
          // dp[b]×3>dp[i−1]≥dp[b−1]×3
          // dp[c]×5>dp[i−1]≥dp[c−1]×5​
          // a,b,c可以理解为，分别对应的2,3,5的某较小丑数的最新的位置
      //初始值：dp[0]  = 1;
      //结果：dp[n-1]
      public int nthUglyNumber(int n) {
          if(n==0) return 0;
  
          int[] dp = new int[n];
          dp[0] = 1;
          int n2 = 0,n3 = 0, n5=0;
          for(int i = 1;i < n;i++){
              dp[i] = Math.min(Math.min(dp[n2]*2,dp[n3]*3),dp[n5]*5);
              if(dp[i]==dp[n2]*2) n2++;
              if(dp[i]==dp[n3]*3) n3++;
              if(dp[i]==dp[n5]*5) n5++;
          }
          return dp[n-1];
      }
  ```

#### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

- 状态要想清楚，最后dp[n]一般就是答案，可以从这推

  ```java
      //动态规划，数学推导和贪心还是暂时放弃吧
      //状态：dp[i]表示，长度为i的绳子剪成m段的最大长度
      //状态转移方程：
          //不剪：dp[i]
          //剪：
              //剪第一段，剪掉j的长度，j*dp[i-j]  (其中j要大于2,否则没有意义)
              //剪完第一段后不剪了，j*(i-j)
      //初始值：dp[2] = 1，j =2;
      //结果：dp[n]
      public int cuttingRope(int n) {
          //初始值
          int[] dp  = new int[n+1];
          dp[2] = 1;
  
          //表示绳子的长度
          for(int i = 3;i <= n; i++){
              //剪第一段的长度
              for(int j = 2; j < i ;j++){
                  dp[i] = Math.max(Math.max(j*dp[i-j],j*(i-j)),dp[i]);
              }
          }
  
          return dp[n];
      }
  ```

#### [剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

- 这题要考虑大数

  使用java的BigInteger类

  ```java
  
  import java.math.BigInteger;
  class Solution {
      //动态规划，数学推导和贪心还是暂时放弃吧
      //状态：dp[i]表示，长度为i的绳子剪成m段的最大长度
      //状态转移方程：
          //不剪：dp[i]
          //剪：
              //剪第一段，剪掉j的长度，j*dp[i-j]  (其中j要大于2,否则没有意义)
              //剪完第一段后不剪了，j*(i-j)
      //初始值：dp[2] = 1，j =2;
      //结果：dp[n]
  
      //大数越界： 剪绳子问题（不考虑取余）最终的结果是以3^a指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。
      public int cuttingRope(int n) {
          //初始值
          BigInteger[] dp = new BigInteger[n+1];
          //都得填充，否则不给计算
          Arrays.fill(dp, BigInteger.valueOf(1));
          // dp[2] = BigInteger.valueOf(1);
          //是dp[i]会越界，而不是仅仅答案会越界，所以不能只对答案进行处理
  
          //表示绳子的长度
          for(int i = 3;i <= n; i++){
              //剪第一段的长度
              for(int j = 2; j < i ;j++){
                  dp[i] = dp[i].max(BigInteger.valueOf(j * (i - j))).max(dp[i - j].multiply(BigInteger.valueOf(j)));
              }
          }
  
          return dp[n].mod(BigInteger.valueOf(1000000007)).intValue();
          }
  }
  ```

#### [剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

- 头大

  ```java
      //动态规划
      //p(k) = k出现的次数/总次数，总次数 = 6^n,所以现在要求k（和）出现的次数
      //考虑最终情况：dp[n][j],掷完n个骰子后，各个点数和出现的次数
          //假设已知 n−1个骰子的解 f(n−1) ，此时添加一枚骰子，求 n 个骰子的点数和为 x的概率 f(n,x) 
      //状态：dp[i][j],掷完i个骰子后，各个点数和j出现的次数
      //状态转移方程：
          // dp[n][j]:
          // for(int i = 1;i <= 6;i++){
          //     dp[n][j] += dp[n-1][j-i]
          // }
      //初始状态：
          // dp[1][j]:
          // for(int j = 1;i <= 6;i++){
          //     dp[1][j] = 1;
          // }
      //结果：dp[n]/6^n
      public double[] dicesProbability(int n) {
          //申请dp空间
          int[][] dp = new int[n+1][6*n+1];
          //初始化
          for(int i = 1;i <= 6; i++ ){
              dp[1][i] = 1;
          }
  
          //从掷两个骰子开始
          for(int i=2;i <= n;i++){
              //可能的和,最小为i,最大为i*6
              for(int j=i;j<=i*6;j++){
                  //掷完i个骰子后，各个点数和j出现的次数，把规模放小
                  //且要注意使得j-k有效，则要大于等于i-1个骰子的最小值
                  for(int k = 1;k<=6 && j >= i+k-1;k++){
                      dp[i][j] += dp[i-1][j-k];
                  }
              }
          }
  
          //这个长度是：最大值减最小值+1得到的
          double[] ans = new double[6*n-n+1];
          for(int i = n;i<=6*n;i++){
              ans[i-n] = (double)dp[n][i]/(Math.pow(6,n));
          }
          return ans;
      }
  ```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

- 动态规划（不优化空间）

  ```java
      // 状态：dp[i]表示偷到i家时能获取的最大数现金
      // 状态转移方程：dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i])
      // 初始值：dp[0] = nums[0],dp[1] = Math.max(nums[0],num[1])
      // 结果：dp[n-1]
      //不优化空间的普通做法
      public int rob(int[] nums) {
          if(nums.length < 2) return nums[0];
  
          int[] dp = new int[nums.length];
          dp[0] = nums[0];
          dp[1] = Math.max(nums[0],nums[1]);
          for(int i = 2;i < nums.length;i++){
              dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
          }
          return dp[nums.length-1];
      }
  ```

  

- 优化空间

  ```java
      //优化空间的普通做法
      public int rob(int[] nums) {
          if(nums.length < 2) return nums[0];
  
          int a = nums[0];
          int b = Math.max(nums[0],nums[1]);
          int c = Math.max(a,b);
          for(int i = 2;i < nums.length;i++){
              c = Math.max(b,a+nums[i]);
              a = b;
              b = c;
              // System.out.println("b:"+ b+" \tc:"+ c);
          }
          // return b;
          return c;
      }
  ```

#### [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

- 动态规划

  ```java
      // 状态：dp[i] 表示当前到i的子序列的数目
      // 状态转移方程：
      //     if(nums[i]-nums[i-1]==nums[i-1]-num[i-2])
      //         dp[i] = dp[i-1] + 1;
      // 初始值：
      //     dp[0] = 0, dp[1] = 0
      // 结果：sum (dp[i])
      public int numberOfArithmeticSlices(int[] nums) {
          if(nums.length < 3) return 0;
          int[] dp = new int[nums.length];
          dp[0] = 0;
          dp[1] = 0;
  
          for(int i = 2;i < nums.length;i++){
              if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])
              dp[i] = dp[i-1] + 1;
          }
  
          return Arrays.stream(dp).sum();
      }
  ```



#### [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

- 递归(后序)：错误解法，尽管答案没错

  ```java
      public int maxValue(int[][] grid) {
  
          return dfs(grid,0,0);
      }
  
      public int dfs(int[][] grid,int i,int j){
          if(i == grid.length || j == grid[0].length){
              return 0;
          }
          
          //此处少了边界条件的判断
          //因为此处返回值是0，即使在其他边界出来了，最后结果也只会加0，对结果不产生影响,因为求得最大值
          //如果求最小值，则应return Integer.MAX_VALUE,加到结果里就会产生影响
  
          int r = dfs(grid,i,j+1);
          int b = dfs(grid,i+1,j);
  
          return Math.max(r,b) + grid[i][j];
      }
  ```

- 正确的递归

  ```java
      //正常的递归应该是
      //递归会超时（不是回溯）(后序遍历)
      public int maxValue(int[][] grid) {
          return dfs(grid,0,0);
      }
  
      public int dfs(int[][] grid,int i,int j){
          if(i == grid.length || j == grid[0].length){
              return 0;
          }
  
          //base case, 最右下角又是边界，又是要拿出来单独判
          if(i == grid.length-1 && j == grid[0].length-1){
              return grid[i][j];
          }
  
          int r = dfs(grid,i,j+1);
          int b = dfs(grid,i+1,j);
  
          return Math.max(r,b) + grid[i][j];
      }
  ```

- 在后序递归的基础上+记忆会比dp还快

  ```java
      //剪枝+状态记录
      private int m;
      private int n;
      private int[][]memo;
  
      public int maxValue(int[][] grid) {
          this.m = grid.length;
          this.n = grid[0].length;
          this.memo = new int[m][n];
          for(int i= 0;i < m;i++){
              Arrays.fill(memo[i],-1);
          }
  
          return dfs_me(grid,0,0);
      }
  
      public int dfs_me(int[][] grid,int i, int j){
          if(i==m || j==n ) return 0;
  
          //剪枝+状态记录
          if(memo[i][j] > -1) return memo[i][j];
  
          if(i==m-1 && j==n-1) return grid[i][j];
          
          int r = dfs_me(grid,i,j+1);
          int b = dfs_me(grid,i+1,j);
  
          memo[i][j] = Math.max(r,b) + grid[i][j];
          return memo[i][j];
      }
  ```

  

- 深搜

  ```java
      //暴力递归（dfs）
      private int[][] grid;
      private int m;
      private int n;
      private int max = Integer.MIN_VALUE;
  
      public int maxValue (int[][] grid) {
          if (grid == null) return 0;
          if (grid.length == 0) return 0;
          this.grid = grid;
          this.m = grid.length;
          this.n = grid[0].length;
          int sum = 0;
          dfs(0,0,sum);
          return max;
      }
  
      public void dfs (int i,int j,int sum) {
          //base case:已到达
          if (i == m - 1 && j == n - 1) {
              sum += grid[i][j];
              max = Math.max(max,sum);
              return;
          }
          //越界
          if (i == m || j == n) {
              return;
          }
          sum += grid[i][j];
          dfs (i + 1,j,sum);
          dfs (i,j + 1,sum);
      }
  ```

- 暴力递归

  ```java
      //暴力递归
      public int maxValue (int[][] grid) {
          return path(grid,0,0);
      }
  
      //参数和返回值代表：当前i,j位置上的礼物最大值，向更大的位置看（更进一步）
      public int path(int[][]grid, int i,int j){
          if(i==grid.length-1 && j==grid[0].length-1) return grid[i][j];
          else if(i==grid.length-1) return grid[i][j] + path(grid,i,j+1);
          else if(j==grid[0].length-1) return grid[i][j] + path(grid,i+1,j);
  
          return grid[i][j] + Math.max(path(grid,i,j+1),path(grid,i+1,j));
      }
  ```

  

- 动态规划

  ![](appendix\礼物.png)

  为了弱化边界条件，可以多增一行和一列

  空间可以使用原地

  ```java
      //动态规划
      //状态：dp[i][j]表示0~i-1,0~j-1,的最大礼物数
      //状态转移方程：dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1]
      //注意此处是多开了一行一列空间，弱化边界条件，使转移方程更加简洁
      //初始状态：dp[1][1]= grid[0][0]
      //结果返回dp[n][m]
      public int maxValue(int[][] grid) {
          int n = grid.length;
          int m = grid[0].length;
  
          int[][] dp = new int[n+1][m+1];
  
          for(int i=1;i <= n;i++){
              for(int j=1;j<=m;j++){
                  dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1];
              }
          }
          return dp[n][m];
      }
  ```



#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)（重要）

可以和最大礼物和的题一起对比着看

- 动态规划1:错误解法

  ```java
      // 动态规划：（错误方式）
      // 增加一行一列(不能用这种方式，因为求的是最小值，新增加的行和列最小值都为0，在求取运算的时候会影响当前值（因为当前值总大于0）)
      // 状态：dp[i][j]表示当前i-1,j-1位置的最小和
      // 转移方程：
      //     dp[i][j] =  Math.min(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1];
      // 初始条件：
      //     dp[0][0] = grid[0][0]
      // 结果：
      //     dp[n][n] 
      public int minPathSum(int[][] grid) {
          int m = grid.length;
          int n = grid[0].length;
  
          int[][] dp = new int[m+1][n+1];
          dp[1][1] = grid[0][0];
          for(int i=1; i<=m;i++){
              for(int j=1;j<=n;j++){
                  dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1];
              }
          }
  
          return dp[m][n];
      }
  ```

- 动态规划：正确解法

  ```java
      // 动态规划：
      // 状态：dp[i][j]表示当前i,j位置的最小和
      // 转移方程：
      //      if(i==0 && j==0) dp[i][j] = grid[i][j];
      //      if(i==0) dp[i][j] = dp[i][j-1] + grid[i][j]
      //      if(j==0) dp[i][j] = dp[i-1][j] + grid[i][j]
      //      else: Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
      // 初始条件：
      //     dp[0][0] = grid[0][0]
      // 结果：
      //     dp[m-1][n-1] 
      public int minPathSum(int[][] grid) {
          int m = grid.length;
          int n = grid[0].length;
  
          int[][] dp = new int[m][n];
          for(int i=0; i<m;i++){
              for(int j=0;j<n;j++){
                  if(i==0 && j==0) dp[i][j] = grid[i][j];
                  else if(i==0) dp[i][j] = dp[i][j-1] + grid[i][j];
                  else if(j==0) dp[i][j] = dp[i-1][j] + grid[i][j];
                  else dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
              }
          }
  
          return dp[m-1][n-1];
      }
  ```

- 动态规划，可用原地空间

  ```java
      // 可用原地空间
      // Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
      // 因为grid[i][j]与之前的grid值无关
      public int minPathSum(int[][] grid) {
          for(int i = 0; i < grid.length; i++) {
              for(int j = 0; j < grid[0].length; j++) {
                  if(i == 0 && j == 0) grid[i][j]=grid[i][j];
                  else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];
                  else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];
                  else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
              }
          }
          return grid[grid.length - 1][grid[0].length - 1];
      }
  ```

- 暴力递归（深搜）(先序)

  ```java
      //暴力递归（dfs）
      private int m;
      private int n;
      private int min;
  
      public int minPathSum(int[][] grid) {
          this.m = grid.length;
          this.n = grid[0].length;
          this.min = Integer.MAX_VALUE;
  
          int sum = 0;
          dfs(grid,0,0,sum);
          return min;
      }
  
      public void dfs(int[][]grid,int i,int j,int sum){
          if(i==m-1 &&j==n-1) {
              sum += grid[i][j];
              min = Math.min(sum,min);
              return;
          }
  
          if(i==m || j==n) return;
  
          sum += grid[i][j];
          dfs(grid,i+1,j,sum);
          dfs(grid,i,j+1,sum);
      }
  ```

- 暴力递归（后序）

  ```java
      // 暴力递归 后序遍历
      public int minPathSum(int[][] grid) {
          return recur(grid,0,0);
      }
  
      public int recur(int[][] grid,int i,int j){
          //因为求最小值，所以没用的要写最大值才不会影响
          if(i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;
          //之前少了个条件判断
          if(i==grid.length-1 && j==grid[0].length-1) return grid[i][j];
      
          int r = recur(grid,i,j+1);
          int b = recur(grid,i+1,j);
  
          return Math.min(r,b) + grid[i][j];
      }
  ```

- 递归后序 + 剪枝记忆

  ```java
      // 递归 + 记忆 后序遍历
      private int[][]memo;
      public int minPathSum(int[][] grid) {
          memo = new int[grid.length][grid[0].length];
          for(int i= 0;i < grid.length;i++){
              Arrays.fill(memo[i],-1);
          }
          return recur(grid,0,0);
      }
  
      public int recur(int[][] grid,int i,int j){
          //因为求最小值，所以没用的要写最大值才不会影响
          if(i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;
          //之前少了个base case条件
          //自底向上，此时的值就是当前位置的最小路径和，因为在最低了
          if(i==grid.length-1 && j==grid[0].length-1) return grid[i][j];
  
          //剪枝，记忆状态
          if(memo[i][j]>-1) return memo[i][j];
  
          int r = recur(grid,i,j+1);
          int b = recur(grid,i+1,j);
  
          memo[i][j] = Math.min(r,b) + grid[i][j];
          return memo[i][j];
      }
  ```

- 另一种递归

  ```java
      //递归
      private int m;
      private int n;
      private int min;
      public int minPathSum(int[][] grid) {
          this.m = grid.length;
          this.n = grid[0].length;
          return recur(grid,0,0);
      }
  
      public int recur(int[][] grid, int i, int j) {
          if(i==m-1 && j==n-1) return grid[i][j];
          else if(i==m-1) return grid[i][j] + recur(grid,i,j+1);
          else if(j==n-1) return grid[i][j] + recur(grid,i+1,j);
  
          return grid[i][j] + Math.min(recur(grid,i,j+1),recur(grid,i+1,j));
      }
  ```

**由47和64题可得，其后序递归可以加状态保存，以空间换时间，速度会比dp还快**



 ### -找规律

#### [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

思路：(有点难受)

根据以上分析，可将求解分为三步：

    确定n所在数字的位数 ，记为digit；
    确定n所在的数字，记为num；
    确定n是num中的哪一数位，并返回结果。

![44](\appendix\44_1.png)

![44](\appendix\44_2.png)

![44](\appendix\44_3.png)

![44](\appendix\44_4.png)

![44](\appendix\44_5.png)

![44](\appendix\44_6.png)

```java
    public int findNthDigit(int n) {
        //1.求位数
        int digit = 1; //位数
        long start = 1; //首位数
        long count = 9; //digit有多少位数
        while (n > count) { // 1.
            n -= count;
            //下一轮的
            digit += 1;
            start *= 10;
            count = digit * start * 9;
        }

        //2.求是哪个数字
        long num = start + (n - 1) / digit; // 2.

        //3.求数字中的第几位
        return Long.toString(num).charAt((n - 1) % digit) - '0'; // 3.
    }
```

#### [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

- 步骤：

  - 不能用除法的情况下，将乘积分为两个部分，当前数之前（左），当前数之后（右），当前数看为1

  - 先将所求空间列出，发现，左半部分是下三角区，右半部分是上三角区，分别计算进行累乘

  - 计算下三角区：b[i] = b[i-1]*a[i-1]

    计算上三角区（从下向上计算，可以将小数的结果复用）：tmp *= a[i+1]; b[i]*= tmp;

  ```java
      //分组进行计算
      //当前下标i的值当做为1
      //分为上下两个三角，分别进行计算，再累乘
      public int[] constructArr(int[] a) {
          if(a==null || a.length < 2) return new int[0];
  
          int[] b = new int[a.length];
          b[0] = 1;
          int index = 1;
          //累乘计算下三角，这循环写得太牛了
          for(int i = 1;i < a.length;i++ ){
              b[i] = b[i-1] * a[i-1];  
          }
          //累乘计算上三角
          //从下往上累乘可以复用结果
          int tmp = 1;
          for(int i=a.length-2;i>=0;i--){
              tmp *= a[i+1];
              b[i] *= tmp;
          }
          return b;
      }
  ```

  

  







### - 栈、队列

#### [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```java
 LinkedList<Integer> s1, s2;
    public CQueue() {
        s1 = new LinkedList<Integer>();
        s2 = new LinkedList<Integer>();

    }
    
    public void appendTail(int value) {
        s1.addLast(value);
    }
    
    public int deleteHead() {
        if(!s2.isEmpty()){
            return s2.removeLast();
        }else if(s1.isEmpty()&&s2.isEmpty()){
            return -1;
        }else{
            while(!s1.isEmpty()){
                s2.addLast(s1.removeLast());
            }
            return s2.removeLast();
        }
    }
```

#### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

```java
    Stack<Integer> s1;
    Stack<Integer> s2;
    public MinStack() {
        s1 = new Stack<>(); //正常栈
        s2 = new Stack<>(); //辅助栈，要求最小值在栈顶,不用所有元素都进辅助栈，找到最小就好

    }
    
    public void push(int x) {
        s1.add(x);
        if(s2.empty() || x <= s2.peek()){
            s2.add(x);
        }
    }
    
    public void pop() {
        //注意此处stack里放的是Integer，
        int x = s1.pop();
        if(!s2.empty() && x==s2.peek()){
            s2.pop();
        }
    }
    
    public int top() {
        return s1.peek();
    }
    
    public int min() {
        return s2.peek();
    }
```

#### [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

- 遍历popped数组，快

  ```java
          Stack<Integer> s = new Stack<>();
          int index = 0; //控制pushed
          int i = 0; //控制popped
          while(i < popped.length){
              if(s.empty() || (!s.empty() && s.peek()!=popped[i])){
                  while(index < pushed.length && pushed[index]!=popped[i] ){
                      s.push(pushed[index]);
                      index++;
                  }
              }
              if(index < pushed.length && pushed[index]==popped[i]){
                  s.push(pushed[index]);
                  index++;
              }
              if(popped[i]==s.peek()){
                  s.pop();
                  i++;
              }else{
                  return false;
              }
          }
          return true;
      }
  ```

- 遍历pushed数组,慢

  ```java
      public boolean validateStackSequences(int[] pushed, int[] popped) {
          Stack<Integer> s = new Stack<>();
          int i = 0;//控制popped的下标
          for(int num:pushed){
              s.push(num);
              while(!s.empty() && s.peek() == popped[i]){
                  s.pop();
                  i++;
              }
          }
          return s.empty();
      }
  ```

#### [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

- 双端队列，保持辅助队列中，队头为最大

  ```java
      LinkedList<Integer> q1;
      LinkedList<Integer> q2;
      public MaxQueue() {
          q1 = new LinkedList<>(); //队列，队尾为最大值getLast()，从队头出
          q2 = new LinkedList<>(); //正常队列
      }
      
      public int max_value() {
          if(q2.isEmpty()){
              return -1;
          }else{
              return q2.getLast();
          }
      }
      
      public void push_back(int value) {
          q2.add(value);
          if(!q1.isEmpty() && value > q1.getLast()){
              q1.add(value);
          }else if(q1.isEmpty()){
              q1.add(value);
          }
      }
      
      public int pop_front() {
          if(q2.isEmpty()){
              return -1;
          }
          int cur = q2.removeFirst();
          if(!q1.isEmpty() && cur==q1.getFirst()){
              q1.removeFirst();
          }
          return cur; 
      }
  ```

#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

- 暴力

  ```java
      public int[] maxSlidingWindow(int[] nums, int k) {
          if(nums==null||nums.length < 1 ) return new int[0];
          int[] res = new int[nums.length-k+1];
          int start = 0, end = k-1;
          while(start <= nums.length-k){
              int tmp[] = Arrays.copyOfRange(nums, start, end+1);
              res[start] = Arrays.stream(tmp).max().getAsInt();
              start++;
              end++;
          }
          return res;
      }
  ```

- 单调队列

  其使用 单调栈 实现了随意入栈、出栈情况下的 O(1)时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素” 。

  窗口对应的数据结构为 双端队列 ，本题使用 单调队列 即可解决以上问题。遍历数组时，每轮保证单调队列 deque ：

  - deque内 仅包含窗口内的元素 
  - deque内的元素 非严格递减 

  ```java
      public int[] maxSlidingWindow(int[] nums, int k) {
          if(nums.length == 0 || k == 0) return new int[0];
          LinkedList<Integer> q = new LinkedList<>(); //定义一个双端队列，维护非严格递减序列（队头为最大）
          int[] res = new int[nums.length - k + 1];
  
          //当没有形成窗口前
          for(int i=0;i < k;i++){
              while(!q.isEmpty() && q.getLast() < nums[i]){
                  q.removeLast();
              }
              q.addLast(nums[i]);
          }
  
          //形成窗口后
          res[0] = q.getFirst();
          for(int i = k;i < nums.length;i++){
              if(q.getFirst()==nums[i-k]){ //第一个被移除的元素
                  q.removeFirst();
              }
              while(!q.isEmpty() && q.getLast() < nums[i]){
                  q.removeLast();
              }
              q.addLast(nums[i]);
              res[i-k+1] = q.getFirst();
          }
          return res;
      }
  ```

- 时间复杂度分析

  **暴力：** O((n−k+1)k)≈O(nk) 。

  设数组 nums的长度为 n，则共有 (n-k+1)个窗口；
  获取每个窗口最大值需线性遍历，时间复杂度为 O(k) 。

  **单调双端队列：**O(2n) 

  其中 n为数组 nums长度；线性遍历 nums 占用 O(n；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O(2n) 

  



### - 其他

#### [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

分析：

![](appendix\求1.png)

```java
    public int countDigitOne(int n) {
        int res = 0, digit = 1;//digit表示位数，1为个数，10为十位，100为百位
        int low = 0;
        int cur = n%10; //求n的个位
        int high = n/10; //求n的十位
        //计算当前位为1的可能性
        while(high!=0 || cur!=0 ){   //high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出
            if(cur > 1){
                res += (high + 1)*digit;  //每种情况进行分析
            }else if(cur == 1){
                res += high*digit + low+1;
            }else{
                res += high*digit;
            }

            //下一轮变量的值
            low = cur * digit + low;
            cur = high % 10; //目前高位的个位
            high /= 10; //求目前高位的十位
            digit *= 10;
        }
        return res;
    }
```

#### [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

- 无符号右移

  ```java
      public int hammingWeight(int n) {
          int res = 0;
          while(n!=0){
              res += n&1;
              n>>>=1;  //无符号右移
          }
          return res;
      }
  ```

  

- 消除最右边的1

  ```java
      public int hammingWeight(int n) {
          int res = 0;
          while(n!=0){    //每一次循环都能消除最右边的1
              res++;
              n = n&(n-1);  //消除最右边的1
          }
          return res;
      }
  ```

#### [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

- 不考虑大数

  ```java
   public int[] printNumbers(int n) {
          int i = 0;
          int len = (int)Math.pow(10,n)-1;
          int[] res = new int[len];
          
          while(i < len){
              res[i] = i + 1;
              i++;
          }
  
          return res;
          
      }
  ```

- 考虑大数,全排列，递归回溯问题

  ```java
      //大数，要当做字符串处理，全排列问题
      //利用了额外空间，不用回溯
      int res[];
      int count = 0; //控制res
      char[] num;
      int n;
      public int[] printNumbers(int n) {
          this.n = n;
          res = new int[(int)Math.pow(10,n)-1];
          num = new char[n];
          dfs(0);
          return res;
      }
  
      //x表示当前位置
      public void dfs(int x){  //x表示当前位置
          if(x == n){
              String s = String.valueOf(num);
              int curNum = Integer.parseInt(s); //会自动把字符串前面无效的0去掉
              if(curNum!=0) res[count++] = curNum;
              return;
          }
  
          for(char i='0';i <='9';i++){
              num[x] = i;
              dfs(x+1);
          }
      }
  ```

### - 位运算

#### [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

利用位运算：将问题分解为【无进位加法+进位】

无进位加法：异或

进位：与运算后左移1（只是进位）

（和 s ）=（非进位和 n ）+（进位 c）。即可将 s=a+b转化为：s=a+b⇒s=n+c

循环求 n和 c ，直至进位 c=0；此时 s=n，返回 n 即可

不用考虑负数，负数是一样的

- 递归

  ```java
      public int add(int a, int b) {
          if(b==0) return a;
  
          return add(a^b, (a&b) << 1);
      }
  ```

- 迭代

  ```java
      //迭代
      public int add(int a, int b) {
          while(b != 0) { // 当进位为 0 时跳出
              int c = (a & b) << 1;  // c = 进位
              a ^= b; // a = 非进位和
              b = c; // b = 进位
          }
          return a;
      }
  ```

#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

- 寻找最右侧的1进行分组

  注意避坑：只是用了位运算但没有位移操作，得出的结果不是0或1

  ```java
      public int[] singleNumbers(int[] nums) {
          int n = 0; 
          int m = 1; //寻找最右侧的1
          int a = 0,b=0; //表示那两个数
          //n = a^b
          for(int num:nums){
              n ^= num;
          }
                  
          //由于a!=b!=0（等于0是必须每一位都为0），则必然有一位是1，我们可以先找到最右侧的1，将a和b进行分组
          //(a=1&&b=0)  || (a=0&&b=1)
  
          //m为找到最右侧的1的位置（a或者b中）
          while((n&m)==0){
              m <<= 1;
          }
  
          for(int num:nums){
              if((num&m)!=0){   
              // 没有位移操作，不能直接比1
              // 此处判断的两种情况相当于 num&m==m 和 num&m==0 而不是0和1
              // if((num&m)==1){
                  a ^= num; 
              }else{
                  b^=num;
              }
          }
  
          return new int[]{a,b};
      }
  ```

#### [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

- 遍历：统计每个位上1的个数count[]，对count模3，剩下的数即为所求

  ![](appendix\模3.png)

  ```java
      public int singleNumber(int[] nums) {
          int[] count = new int[32];
          //统计好每一位为1的数量
          for(int num:nums){
              for(int i=0;i<32;i++){
                  count[i] += num&1;
                  //num右移
                  num >>>=1; //此时在最低位,为了判断下一个高位，需要右移
              }
          }
  
          int res = 0,m=3;
          for(int i= 0;i<32;i++){
              res <<= 1;   //是因为下面的语句最先变的，为了不影响res
              res |= count[31-i] % m;  //或等 4|1 = 5;
          }
          return res;
      }
  ```

#### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

- 定义上下左右四个边界， “从左向右、从上向下、从右向左、从下向上” 四个方向循环

  ![](appendix\模拟打印.jpg)

  ```java
      public int[] spiralOrder(int[][] matrix) {
          if(matrix.length==0) return new int[0];
  
          //定义上下左右四个边界
          int l = 0,r = matrix[0].length-1, t = 0, b = matrix.length-1;
          int[] res = new int[(r+1)*(b+1)];
          int idx = 0;
          
          while(true){
              for(int i = l;i <= r;i++) res[idx++] = matrix[t][i];
              if(++t > b) break;
              for(int i = t;i <= b;i++) res[idx++] = matrix[i][r];
              if(--r < l) break;
              for(int i = r;i >=l ;i--) res[idx++] = matrix[b][i];
              if(--b < t) break;
              for(int i = b;i >=t ;i--) res[idx++] = matrix[i][l];
              if(++l > r) break;
          }
  
          return res;
      }
  ```

  



### -字符串

#### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

- 中心扩展法

  ```java
      //中心扩展法
      //从左到右，依次以字符为中心轴进行判断，双指针
      //但是要注意偶数长度的子串的遍历，并不是以某个字符为轴对称，需要将中心点由一个扩展到2个
      //例如：ababa
      //abab这个字符串并不是某个字符的中心点，无法遍历到，则无法判断是否是回文
  
      public int countSubstrings(String s) {
          int l = 0,r = 0;
          int count = 0;
          for(int i=0;i < s.length();i++){
              count += help(s,i,i);   //中心轴为一个字符（子串为奇数的长度）
              count += help(s,i,i+1); //中心轴为两个字符（子串为偶数的长度）
          }
          return count;
      }
  
      public int help(String s, int l, int r){
          int count = 0;
          while(l>=0 && r< s.length() && s.charAt(l)==s.charAt(r)){
              count++;
              l--;
              r++;
          }
          return count;
      }
  ```

#### [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

- 对字符进行分组

  我们可以将字符串 s按照 000 和 111 的连续段分组，存在 counts 数组中，例如 s=00111011，可以得到这样的 counts 数组：counts={2,3,1,2}。

  这里 counts 数组中两个相邻的数一定代表的是两种不同的字符。假设 counts 数组中两个相邻的数字为 u或者 v，它们对应着 u个 0和 v个 1，或者 u个 1 和 v个 0。它们能组成的满足条件的子串数目为 min⁡{u,v}，即一对相邻的数字对答案的贡献。

  ```java
   public int countBinarySubstrings(String s) {
          List<Integer> counts = new ArrayList<>();
          int index = 0;
          char pre = s.charAt(index);
          
          //先对连续的字符串进行分组
          //记录pre的方式
          int count = 0;
          // while(index < s.length()){
          //     char cur = s.charAt(index);
          //     if(pre==cur){
          //         count++;
          //     }else{
          //         counts.add(count);
          //         count = 1;
          //     }
          //     pre = cur;
          //     index++;
          // }
          // counts.add(count);
  
          //先对连续的字符串进行分组
          //双层循环的方式
          while(index < s.length()){
              char cur = s.charAt(index);
              count = 0;
              while(index < s.length() && s.charAt(index)==cur){
                  count++;
                  index++;
              }
              counts.add(count);
          }
  
          //再对分组数组取最小
          index = 0;
          int res = 0;
          while(index < counts.size()-1){
              res += Math.min(counts.get(index),counts.get(index + 1));
              index++;
          }
          return res;
  
      }
  ```

- 针对上一种方式的优化，利用滑动数组的思想

  ```java
      //优化：只关注上一个和当前的count的数目的最小值
      public int countBinarySubstrings(String s) {    
          int index = 0;
          int preCount = 0;
          int res = 0;
          while(index < s.length()){
              int count = 0; 
              char cur = s.charAt(index);
              while(index < s.length() && s.charAt(index)==cur){
                  count++;
                  index++;
              }
              res += Math.min(count,preCount);
              preCount=count;
          }
          return res;
           
      }
  ```

#### [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

- 利用双栈，操作栈，数字栈

- 两个坑：要注意加入和pop操作栈的时候，需要用循环的方式，因为这是保证从左往右的方式，而不是同级的放在最后从右向左计算，就会发生错误；第二个坑，要注意判断连续数字的时候，出循环后i会多1，要减掉。

  ```java
      public int calculate(String s) {
          //定义优先级
          HashMap<Character,Integer> priority = new HashMap<>();
          //定义数字栈和操作栈
          Stack<Integer> nums = new Stack<>();
          Stack<Character> ops = new Stack<>();
  
          //添加优先级
          priority.put('+',1);
          priority.put('-',1);
          priority.put('*',2);
          priority.put('/',2);
  
          //进行运算
          //处理字符串开头有负号的情况
          //题目要求非负，可以不加
          // s = '0' + s;
          //保证了同级运算中**从左到右**的顺序，不然会出错
          int i = 0;
          while(i < s.length()){
              // char cur = s.charAt(i);
  
              //处理空格
              if(s.charAt(i)==' ')  {
                  i++;
                  continue;
              }
              //读取一个连续的数字,并转为数字
              String tmp = "";
              // System.out.println("i"+ i+ "\tcur:"+ s.charAt(i));
              while(i<s.length() && s.charAt(i) >='0' && s.charAt(i) <='9'){
                  tmp += s.charAt(i);
                  // System.out.println("cur:"+ s.charAt(i) + "tmp:"+tmp +"\t");
                  i++;
                  //可能会多加一个1
              }
              // System.out.println("i"+ i + "tmp" + tmp);
              // System.out.println(nums + "  " + ops);
  
              if(!tmp.isEmpty()){
                  int num = Integer.parseInt(tmp);
                  nums.add(num);
                  // System.out.println("num:"+ num + "nums:"+nums +"\t");
              }else{ //操作符
                  // System.out.println("i: "+ i + "tmp: "+ tmp + " ops: " + ops + " cur:"+s.charAt(i) + "nums"+nums);
              //此处有大坑！！！注意，当操作符为统一级的时候，为了保证从左到右依次计算，应该用循环，将等于的操作都做完，再入栈
              //而不是简单的if判断，这样会导致同级运算一直被留在栈里，最后出栈的时候，同级运算变成从右向左了
                  // if(s.charAt(i)==' ')  {
                  //     i++;
                  //     continue;
                  // }
                  // // System.out.println("i: "+ i + "tmp: "+ tmp + " ops: " + ops + " cur:"+s.charAt(i) + "nums"+nums);
  
                  // if(!ops.isEmpty()){
                  //     if(priority.get(ops.peek()) < priority.get(s.charAt(i))){  //操作栈的优先级低
                  //         ops.add(s.charAt(i));
                  //     }else{  //操作栈的优先级高
                  //         operate(nums,ops);
                  //         ops.add(s.charAt(i));
                  //     }
                  // }else{ //操作栈为空直接加
                  //     ops.push(s.charAt(i));
  
                  while(!ops.isEmpty() && priority.get(ops.peek()) >= priority.get(s.charAt(i))){
                      operate(nums,ops);
                  }
                  ops.add(s.charAt(i));
              }
              if(tmp.isEmpty()){
                  i++;
              }
          }
  
          // System.out.println(nums + "  " + ops);
          while(!ops.isEmpty()){
              operate(nums,ops);
              // System.out.println(nums + "  " + ops);
          }
          return nums.pop();
      }
  
  
      //从双栈取数进行操作
      public void operate(Stack<Integer> nums,Stack<Character> ops){
          int num1 = nums.pop();
          int num2 = nums.pop();
          char op = ops.pop();
  
          if(op=='+'){
              nums.push(num2 + num1);
          }else if(op=='-'){
              nums.push(num2 - num1);
          }else if(op=='*'){
              nums.push(num2 * num1);
          }else{
              nums.push(num2 / num1);
          }
      }
  ```

#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

- KMP

  ```java
  // O(N)
      public int strStr(String haystack, String needle) {
          if(needle.isEmpty()) return 0;
  
          if (haystack == null ||  needle.length() < 1 || haystack.length() < needle.length()) {
              return -1;
          }
          
  
          char[] h = haystack.toCharArray(); //母串
          char[] n = needle.toCharArray(); //子串
  
          int x = 0; //母串下标
          int y = 0; //子串下标
          
          //O(N)
          int[] next = getNext(n);
          while(x < h.length && y < n.length){
              if(h[x] == n[y]){
                  x++;
                  y++;
              }else if(next[y]==-1){  //y = 0;
                  x++; 
              }else{
                  y = next[y];
              }
          }
  
          return y==n.length? x-y : -1;
  
      }
  
      //只和子串有关
      public int[] getNext(char[] n){
          if(n.length==1) return new int[]{-1};
  
          int[] next = new int[n.length];
          next[0] = -1;
          next[1] = 0;
          int index = 2;
          int cn = 0;  //当前需要比较的位置，同时也是值
          while(index < n.length){
              if(n[index-1] == n[cn]){   //注意此处是index-1,因为前一个就不包含他本身
                  next[index++] = ++cn;  //此处是++cn
              }else if(cn > 0){  //为什么没有等  cn=0的时候是-1
                  cn = next[cn];
              }else{
                  next[index++] = 0;  //没有前后缀是0
              }
          }
          
          return next;
      }
  
  ```

#### [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

- 从左向右递归

  ```java
      public int translateNum(int num) {
          if(num==0) return 1;
          String str = String.valueOf(num);
          char[] strs = str.toCharArray();
          return dfs(strs,0);
      }
  
      //i之前的位置，如何转化已经做过决定了
  	//i...有多少种转化结果
      public int dfs(char[] nums, int i){
          if(i==nums.length)  //最后一位的下一位
              return 1;
      
          if(nums[i]=='0'){
              return dfs(nums,i+1);
          }else if(nums[i]=='1'){
              int res = dfs(nums,i+1);
              if(i+1 < nums.length){
                  res += dfs(nums,i+2);
              }
              return res;
          }else if(nums[i]=='2'){
              int res = dfs(nums,i+1);
              if(i+1<nums.length && nums[i+1] <= '5' ){
                  res += dfs(nums,i+2);
              }
              return res;
          }else{//‘3’-‘9’的情况
              return dfs(nums,i+1);
          }
      }
  ```

- 动态规划

  ```java
      //动态规划
      //滑动数组
      public int translateNum(int num) {
          if(num==0) return 1;
          String str = String.valueOf(num);
          int a = 1; //记录i-1
          int b = 1; //记录i-2
          for(int i=2;i < str.length();i++){
              String tmp = str.substring(i-2,i);
              int c = tmp.compareTo("10")>=0 && tmp.compareTo("25")<=0? a+b:a;  //compareTo返回的是前-后的值
              b=a;
              a=c;
          }
          return a;
      }
  ```

#### [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

- 暴力

  ```java
      public int lengthOfLongestSubstring(String s) {
          if(s.isEmpty()) return 0;
          if(s.length()==1) return 1;
  
          char[] str = s.toCharArray();
          int max = Integer.MIN_VALUE;
          //控制窗口左
          for(int i=0; i < str.length;i++){
              int res = 0;
              int flag = 0;
              //控制右
              for(int j = i+1;j < str.length;j++){
                  //判断当前数是否能加入窗口
                  for(int k = j-1;k>=i;k--){
                      if(str[k]==str[j] ){
                          flag = 1;
                          break;
                      }
                  }
                  if(flag==1) {
                      break;
                  }else {
                      res++;
                  }
              }
              max = Math.max(max,res+1);
  
          }
          return max;
      }
  ```

  

- 可变滑动窗口

  ```java
      //可变滑动窗口，左开右闭！！！
      //(start,i]
      public int lengthOfLongestSubstring(String s) {
          int start = -1; //滑动窗口起始
          int max = 0;
  
          //定义hashmap，用于存放该字符最后一个索引值
          HashMap<Character,Integer> map = new HashMap<>();
  
          for(int i=0;i<s.length();i++){
              char cur = s.charAt(i);
              if(map.containsKey(cur)){
                  //取最大是因为会出现abba的情况，不取大，则start又等于0了
                  start = Math.max(map.get(cur),start);
              }
              map.put(cur,i);
              max = Math.max(max,i-start);
          }
          return max;
      }
  ```

#### [剑指 Offer 67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

- 大数越界处理

  思路：

  - 首部空格： 删除之即可；

  - 符号位： 三种情况，即 ''+++'' , ''−-−'' , ''无符号" ；新建一个变量保存符号位，返回前判断正负即可。

  - 非数字字符： 遇到首个非数字的字符时，应立即返回。
    数字字符：
  
  - 数字字符：
  
    - 字符转数字： “此数字的 ASCII 码” 与 “ 000 的 ASCII 码” 相减即可；
            
  
    - 数字拼接： 若从左向右遍历数字，设当前位字符为 c ，当前位数字为 x ，数字结果为 res ，则数字拼接公式为：
  
      x =  c - '0';
  
      res = res *10 + x;
  
  - 大数越界处理：int合理范围是
  
    -2147483648~2147483647
  
    在判断是否越界时，不能直接用这种方式（if(res *10 + (cs[idx]-'0') > Integer.MAX_VALUE)），当输入为2147483648，系统会判定为res *10 + (cs[idx]-'0') = -2147483648, 成负的

  ```java
      public int strToInt(String str) {
          char[] cs = str.trim().toCharArray();
          if(cs.length==0) return 0;
  
          int idx = 0, sign = 1; //下标和符号位
          if(cs[0]=='-'){
              sign = -1;
              idx =1;
          }else if(cs[0]=='+'){
              idx++;
          }
          int res = 0;
          int max_int_boundary = Integer.MAX_VALUE/10;
          while(idx < cs.length){
              if(cs[idx] < '0' || cs[idx] > '9'){
                  break;
              }
              //到这的res还没有加 
              //注意这个边界条件
              //此处其实也考虑了负数
              if(res > max_int_boundary || (res==max_int_boundary && cs[idx] > '7')){
              //不能直接用这种方式，系统会判定为res *10 + (cs[idx]-'0') = -2147483648,成负的
              // if(res *10 + (cs[idx]-'0') > Integer.MAX_VALUE){
                  if(sign==1){
                      return Integer.MAX_VALUE;
                  }else{
                      return Integer.MIN_VALUE;
                  }
              }
  
              res = res *10 + (cs[idx]-'0');
              idx++;
          }
          return sign*res;
      }
  ```

#### [剑指 Offer 20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

- 多条件判断

  ```java
   public boolean isNumber(String s) {
          //base case
          if(s==null || s.length()==0) return false;
          //标志位
          boolean isDot = false,isE = false, isNum = false;
          //去空格，转为数组
          char[] arr = s.trim().toCharArray();
          //从左往右遍历开始判断
          for(int i = 0;i < arr.length;i++){
              char tmp = arr[i];
              //遇到了数字
              if(tmp >= '0' && tmp <= '9'){
                  isNum = true;
              //遇到了点，注意点和e不能同时出现，e只能和整数一起
              }else if(tmp == '.'){
                  if(isDot || isE) {
                      return false;
                  }
                  isDot = true;
              //出现E，则前面必须有整数，不能重复出现e
              }else if(tmp=='e'||tmp=='E'){
                  if(!isNum || isE) {
                      return false;
                  }
                  isE = true;
                  //e的后面需要一个整数，所以重置
                  isNum = false;
              }else if(tmp == '+' || tmp == '-'){
                  //出现正负号，如果不是在首位，则必须在e之后，否则不符合
                  if(i != 0 && arr[i-1] != 'e' && arr[i-1] != 'E'){
                      return false;
                  }
              //出现其他的奇怪的字符
              }else{
                  return false;
              }
          }
          //其他情况返回isNum,而不是true,比如12e的情况
          return isNum;
      }
  ```

#### [剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

- [动态规划](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/)

  - 解题思路

  假设主串为 A，模式串为 B 从最后一步出发，需要关注最后进来的字符。假设 A的长度为 n ，B 的长度为 m ，关注正则表达式 B的最后一个字符是谁，它有三种可能，正常字符、∗ 和 .（点），那针对这三种情况讨论即可，如下：

      如果 B的最后一个字符是正常字符，那就是看 A[n−1]是否等于 B[m−1]B，相等则看A_{0..n-2} 与B_{0..m-2}，不等则是不能匹配，这就是子问题。
      
      如果 B的最后一个字符是.，它能匹配任意字符，直接看 A_{0..n-2}与 B_{0..m-2}
      
      如果 B 的最后一个字符是*它代表 B[m−2]=c,可以重复0次或多次，它们是一个整体 c∗
          情况一：A[n−1]是 0个 c，B最后两个字符废了，能否匹配取决于 A_{0..n-1}和 B_{0..m-3}是否匹配
          情况二：A[n−1] 是多个 c中的最后一个（这种情况必须 A[n−1]=c 或者 c=′.′），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A_{0..n-2} 和B_{0..m-1}是否匹配。

  - 转移方程

  f[i] [j]代表 A 的前 i个和 B的前 j个能否匹配

      对于前面两个情况，可以合并成一种情况 f[i][j]=f[i−1][j−1]
      
      对于第三种情况，对于 c∗ 分为看和不看两种情况
          不看：直接砍掉正则串的后面两个， f[i][j]=f[i][j−2]
          看：正则串不动，主串前移一个，f[i][j]=f[i−1][j]

  - 初始条件

  特判：需要考虑空串空正则

      空串和空正则是匹配的，f[0][0]=true
      空串和非空正则，不能直接定义 true和 false，必须要计算出来。（比如A= '' ,B=a∗b∗c∗）
      非空串和空正则必不匹配，f[1][0]=...=f[n][0]=false
      非空串和非空正则，那肯定是需要计算的了。

  大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 ∗ 和不是 ∗ 两种情况了。
  结果

  我们开数组要开 n+1 ，这样对于空串的处理十分方便。结果就是f\[n\]\[m\]
  
  - 代码
  
  ```java
      //动态规划
      //只关注最后进来的字符
      //注意区别方程和本身索引的差别
      public boolean isMatch(String s, String p) {
          int n = s.length(); 
          int m = p.length();
          //矩阵默认值为false
          boolean[][] f = new boolean[n+1][m+1];   //f[i][j]表示，s[0...i-1]和p[0...j-1]是否匹配
  
          //加等于时为了处理空串
          for(int i = 0;i <= n; i++){
              for(int j = 0;j <= m; j++){
                  //空正则
                  if(j==0){
                      f[i][j] = i==0 ;  //true
                  }else{
                      //非空正则分为两个情况，*和非*
                      if(p.charAt(j-1)!='*'){ //当正则的最后一个字符不是*时
                          if(i > 0 && (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1)=='.')){
                              f[i][j] = f[i-1][j-1]; //结果取决于s[0..i-2]和p[0...j-2]
                          }
                      }else{  //是*
                          //不看，当没有
                          if(j >= 2){
                              f[i][j] |= f[i][j-2];   //用或等是因为f[i][j]有两种情况，只要有一种情况为true，结果就会为true
                          }
                          //看
                          if(i>=1 && j>=2 && (s.charAt(i-1)==p.charAt(j-2) || p.charAt(j-2)=='.'))
                              f[i][j] |= f[i-1][j]; 
                      }
                       
                  }
              }
          }
          //如果写成return f[n-1][m-1]，则为空串时不好处理，越界
          return f[n][m];
      }
  ```



### - BFS

#### [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)(多源最短路模板)

- bfs

  多源最短路问题：添加超级源点，将多源最短路转为单源最短路

  （1）多次单源BFS
  通过对每个water进行BFS搜索，得到一组nearest lands，然后从中寻找max。

  （2）一次多源BFS
  在多次单源BFS中，每个water都是相互独立的，那么能否通过添加一个超级节点将所有单源节点连接起来，这样就是的问题转换成了一次单源BFS。

  注意：当添加了超级节点后，超级节点的扩散方式并不是上下左右，而是相连的都扩散出去，且距离=0。这在算法如何实现？
  只要手动完成即可，即让超级节点连接的所有节点，先都进入队列中，就完成了扩散。


  套路：（反着来就行了，反正我搞不懂了）

  求每个位置到最近的0的距离，超级源点是1，把所有0入队列，则第一步就都会到达最近的0

  求每个位置到最近的1的距离，超级源点是0，把所有1入队列，则第一步就都会到达最近的1

  ```java
      public int[][] updateMatrix(int[][] mat) {
          LinkedList<int[]> q = new LinkedList<>();
  
          //遍历矩阵，将0的全部由超级源点链接起来，向四周扩散
          //并标志原本的1的位置为-1，和之后的距离值区别开来
          //因为这部分是要用源空间进行保存
          for(int i = 0 ; i < mat.length;i++){
              for(int j = 0; j < mat[0].length;j++){
                  if(mat[i][j]==0){
                      q.add(new int[]{i,j});
                  }else{
                      mat[i][j] = -1;
                  }
              }
          }
  
          //进行单源最短路径的搜索
          //bfs，并记录距离，层级
          int[] x = {-1,1,0,0};
          int[] y = {0,0,-1,1};
          int step = 1;
          while(!q.isEmpty()){
              int size = q.size();  //每一轮都会变
              for(int i = 0;i < size; i++){
                  int[] cur = q.remove();
                  for(int j = 0;j < 4;j++){
                      int newx = cur[0] + x[j];
                      int newy = cur[1] + y[j];
                      //摆脱边界
                      //以及记录过的就不再进行记录 >0
                      //step为0 的情况不用处理
                      if(newx < 0|| newy < 0 || newx >= mat.length || newy >= mat[0].length  || mat[newx][newy] >= 0 ){
                          continue;
                      } 
                      mat[newx][newy] = step;
                      q.add(new int[]{newx,newy});
                  }
              }
              //下次遍历到的-1相比前一次的距离step+1
              step++;
          }
          return mat;
      }
  ```

- 动态规划

  ```java
      //动态规划
      // 状态：dp[i][j]，表示i,j位置上距离0的最小值
      // 状态转移方程：
      //     从左上到右下（往下和往右）+ 从右下到坐上（往上和往左），四个方向都搜索到了
      //     if(mat[i][j]==0) dp[i][j] = 0;
  
      //     从左上到右下（往下和往右）
  	//	   相当于是把min记录下来了
      //     if (i-1 >= 0) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1);
      //     if (j-1 >= 0) dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);
          
      //     从右下到坐上（往上和往左）
      //     if (i+1 < mat.length) dp[i][j] = Math.min(dp[i][j], dp[i+1][j] + 1);
      //     if (j+1 < mat[0].length) dp[i][j] = Math.min(dp[i][j], dp[i][j+1] + 1);
  
      // 初始状态：dp[i][j] = 0;
      // 结果：dp
  
      static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
  
      public int[][] updateMatrix(int[][] matrix) {
          int m = matrix.length, n = matrix[0].length;
          // 初始化动态规划的数组，所有的距离值都设置为一个很大的数
          int[][] dist = new int[m][n];
          for (int i = 0; i < m; ++i) {
              Arrays.fill(dist[i], Integer.MAX_VALUE / 2);
          }
          // 如果 (i, j) 的元素为 0，那么距离为 0
          for (int i = 0; i < m; ++i) {
              for (int j = 0; j < n; ++j) {
                  if (matrix[i][j] == 0) {
                      dist[i][j] = 0;
                  }
              }
          }
          // 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序
          for (int i = 0; i < m; ++i) {
              for (int j = 0; j < n; ++j) {
                  if (i - 1 >= 0) {
                      dist[i][j] = Math.min(dist[i][j], dist[i - 1][j] + 1);
                  }
                  if (j - 1 >= 0) {
                      dist[i][j] = Math.min(dist[i][j], dist[i][j - 1] + 1);
                  }
              }
          }
          // 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序
          for (int i = m - 1; i >= 0; --i) {
              for (int j = n - 1; j >= 0; --j) {
                  if (i + 1 < m) {
                      dist[i][j] = Math.min(dist[i][j], dist[i + 1][j] + 1);
                  }
                  if (j + 1 < n) {
                      dist[i][j] = Math.min(dist[i][j], dist[i][j + 1] + 1);
                  }
              }
          }
          return dist;
      }
  ```

  



## Leetcode

### - 排序

- [148.排序链表](https://leetcode-cn.com/problems/sort-list/submissions/)

  ```java
  class Solution {
      public ListNode sortList(ListNode head) {
          //注意处理特殊情况
          if(head==null || head.next == null)
              return head;
  
          //定义快慢指针，慢指针走1，快指针走2，快指针指向最后一个node，慢指针走到中点
          ListNode slow = head;
          ListNode fast = head.next;
          
          //找中点
          while(fast!=null && fast.next!=null){  //因为要保证fast和fast.next不会访问出错
              slow = slow.next;
              fast = fast.next.next;
          }
  
          // ListNode mid = slow;
          ListNode mid = slow.next;
  
          //断成两个链
          slow.next = null;
  
          //递归分
          ListNode l1 = sortList(head);
          ListNode l2 = sortList(mid);
  
          //合并
          //新建一个链表
          ListNode mergeList = new ListNode();
          //定义头结点
          ListNode cur = mergeList;
  
          while(l1!=null && l2!=null){
              if(l1.val<l2.val){
                  cur.next = l1;
                  l1= l1.next;
              }else{
                  cur.next = l2;
                  l2 = l2.next;
              }
              //cur指针的更新
              cur = cur.next;
          }
          if(l1!=null){
              cur.next = l1;
          }else{
              cur.next = l2;
          }
      //链表是链，只用链头就可以
      //     while(l1!=null){
      //         cur.next = l1;
      //         l1 = l1.next;
      //     }
  
      //     while(l2!=null){
      //         cur.next = l2;
      //         l2 = l2.next;
      //     }
  
          return mergeList.next;
  
      }
  ```

  

- [56.合并区间](https://leetcode-cn.com/problems/merge-intervals/)

  ```java
  public int[][] merge(int[][] intervals) {
          if(intervals==null || intervals.length < 2)
              return intervals;
  
          //将intervals用升序进行排序,定义比较器
          Arrays.sort(intervals,new Comparator<int[]>(){
              public int compare(int[] intervals0,int[] intervals1){
                  return intervals0[0]-intervals1[0];
              }
          });
  
          //定义可变数组
          // List list = new ArrayList();这句创建了一个ArrayList实现类的对象后把它上溯到了List接口。此时它就是一个List对
          // 象了，它有些ArrayList类具有的，但是List接口没有的属性和方法，它就不能再用了。 
          // ArrayList list=newArrayList();
          // 创建一对象则保留了ArrayList的所有属性和方法。 
          List <int[]> merged = new ArrayList<int[]>();
  
          //解法：判断merge[1]和当前cur[0]的大小，决定是更新还是添加
          //更新则选merge[1]和cur[1]的最大值
          for(int i = 0; i < intervals.length;  ++i){
              int L = intervals[i][0],R = intervals[i][1];
              if(merged.size()==0 || merged.get(merged.size()-1)[1] < L){
                  merged.add(intervals[i]);
              }else{
                  merged.get(merged.size()-1)[1] = Math.max(merged.get(merged.size()-1)[1],R);
              }
          }
  
          //将可变数组变为普通数组
          return merged.toArray(new int[merged.size()][]);   
      }
  ```

- 215.数组中第K个最大元素

  - 快速选择

  **快速选择**一般用于求解 k-th Element 问题，可以在 *O*(*n*) 时间复杂度，*O*(1) 空间复杂度完成求解工作。快速选择的实现和快速排序相似，不过只需要找到第 *k* 大的枢（pivot）即可，不需要对其左右再进行排序。与快速排序一样，快速选择一般需要先打乱数组。

  由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置

  所以只要某次划分的 q\*q\* 为倒数第 k\*k\* 个下标的时候，我们就已经找到了答案

  分解的过程当中，我们会对子数组进行划分，如果划分得到的 q正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。

  ```java
  //利用快速选择
      public int findKthLargest(int[] nums, int k){
          return quickSelect(nums,0,nums.length-1,nums.length-k);
      }
  
      public int quickSelect(int[] nums, int L, int R, int index){
          //随机交换值，保证最快的速度
          swap(nums,(int)(L + Math.random()*(R-L+1)),R);
          int res = partition(nums,L,R);
          if(res==index){
              return nums[index];
          }else if (res < index) {
              return quickSelect(nums,res+1,R,index);
          }else{
              return quickSelect(nums,L,res-1,index);
          }
      }
  
      public int partition(int[] nums, int L , int R){
          int less = L-1;
          int pivot = nums[R];
          int index = L;
          while(index < R){
              if(nums[index] < pivot){
                  swap(nums,++less,index);
              }
              index++;
          }
          swap(nums,++less,R);
          return less;
      }
  
      public void swap(int[] nums,int i,int j){
          int tmp = nums[i];
          nums[i] = nums[j];
          nums[j] = tmp;
      }
  ```

  - 堆排序：做k次堆调整就可以

    ```java
    public void swap(int[] nums,int i,int j){
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    
        //堆排
        public int findKthLargest(int[] nums, int k){
            int heapSize = nums.length;
            //建堆，建成完全二叉树
            buildHeap(nums,heapSize);
    
            //调整堆,排序
            for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
                swap(nums, 0, i);
                --heapSize;
                heapify(nums, 0, heapSize);
            }
            return nums[0];
        }
    
        //根节点,向下,选出最大得数
    	//循环的写法
        public void heapify(int[] nums,int i,int heapSize){
            int L = 2*i + 1,R = L + 1;
            int largest = i;
            //当下方还有孩子的时候
            while(i < heapSize){
                if (L < heapSize && nums[L] > nums[largest]){
                    largest = L;
                 }
                 if (R < heapSize && nums[R] > nums[largest]){
                     largest = R;
                 }
    
                if(largest==i)  //如果本来就是自己大，就停止
                    break;
                //不断向下的过程
                swap(nums,largest,i);
                i = largest;
                L = 2*i+1;
                R = L + 1;
            }
        }
    	
    	//递归的写法
        // public void heapify(int[] a, int i, int heapSize) {
        //     int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        //     if (l < heapSize && a[l] > a[largest]) {
        //         largest = l;
        //     } 
        //     if (r < heapSize && a[r] > a[largest]) {
        //         largest = r;
        //     }
        //     if (largest != i) {
        //         swap(a, i, largest);
        //         heapify(a, largest, heapSize);
        //     }
        // }
    
    
        //建堆，下沉的方法
        public void buildHeap(int[] nums,int heapSize){
            for (int i = heapSize - 1; i >= 0; i--) {
    			heapify(nums, i, heapSize);
    		}
        }
    ```

- 347.前k个高频元素

  - 维护k值的最小堆

    ```java
    public int[] topKFrequent(int[] nums, int k) {
            // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
            HashMap<Integer,Integer> map = new HashMap();
            for(int num: nums){
                if(map.containsKey(num)){
                    map.put(num,map.get(num) + 1);
                }else{
                    map.put(num,1);
                }
            }
    
            //创建小根堆
            PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>(){
                public int compare(Integer a, Integer b){
                    return map.get(a)- map.get(b);
                }
            });
    
            //维护k大小的小根堆
            //获取哈希表中的所有key值
            for(Integer key:map.keySet()){
                if (heap.size() < k){
                    heap.add(key);
                //更新最小值，确保是频数最高的k个
                }else if (map.get(key) > map.get(heap.peek())){
                    heap.remove();
                    heap.add(key);
                }
            }
    
            //取出最小堆的元素
            List<Integer> res = new ArrayList<>();
            while(!heap.isEmpty())
            {
                res.add(heap.remove());
            }
    
            int[] array = new int[res.size()];
    
            //使用for循环得到数组
            for(int i = 0; i < res.size();i++){
                array[i] = res.get(i);
            }
    
            return array;
        }
    ```

  - 桶排序

    ![桶](\appendix\桶排.png)

    ```java
    
        //桶排序的方法
        public int[] topKFrequent(int[] nums, int k) {
            //创建哈希表
            HashMap<Integer,Integer> map = new HashMap();
            for (int num : nums){
                if(map.containsKey(num)){
                    map.put(num,map.get(num)+1);
                }else{
                    map.put(num,1);
                }
            }
    
            //桶排序
            //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
            List<Integer>[] bucket = new List[nums.length + 1];
            for(int key: map.keySet()){
                int i = map.get(key);
                //要申请空间
                if(bucket[i]==null){
                    //因为可能存在频数一样多的数字，要用数组存放
                    bucket[i] = new ArrayList();
                }
                bucket[i].add(key);
            }
    
            List<Integer> res = new ArrayList();
            //使用for循环得到数组
            for(int i = bucket.length-1; i >=0 && res.size() < k ;i--){
                if(bucket[i] == null) continue;
                res.addAll(bucket[i]);
            }
    
            int[] array = new int[res.size()];
    
            //使用for循环得到数组
            for(int i = 0; i < res.size();i++){
                array[i] = res.get(i);
            }
            return array;
        }
    ```

- #### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

  - 桶排序

    ```java
    //桶排序
        public String frequencySort(String s) {
            //创建哈希表
            Map<Character,Integer> map = new HashMap<Character,Integer>();
            char[] cs = s.toCharArray();
            //记录最大频数，以确定桶的数量
            int max = 0;
            for(char c:cs){
                map.put(c,map.getOrDefault(c,0) + 1);
                max = Math.max(map.getOrDefault(c,0) + 1,max);
            }   
    
            //创建桶
            StringBuilder[] bucket = new StringBuilder[max + 1];
            for(int i = 0; i <= max ; i++){
                bucket[i] = new StringBuilder();
            }
            //遍历哈希表，并进桶
            for(Map.Entry<Character,Integer> entry: map.entrySet()){
                char c = entry.getKey();
                int frequency = entry.getValue();
                bucket[frequency].append(c);
            }
    
            //创建字符串
            StringBuilder res = new StringBuilder();
            for(int i = max; i> 0 ;i--){
                StringBuilder b = bucket[i];
                int size = b.length();
                for(int j = 0; j< size; j++){
                    for(int k = 0; k < i;k++)
                        res.append(b.charAt(j));
                }
            }
    
            return res.toString();
    
        }
    ```

    

  - 哈希+优先队列

    ```java
        //定义存入优先队列的数据结构
        class Node{
            char c;
            int v;
            Node (char _c,int _v){
                c = _c;
                v = _v;
            }
        }
        //按照出现频率排序
        public String frequencySort(String s) {
    
            //创建哈希表
            Map<Character,Integer> map = new HashMap<Character,Integer>();
            char[] cs = s.toCharArray();
            for(char c: cs){
                // if(map.containsKey(c)){
                //     map.put(c,map.get(c) + 1);
                // }else{
                //     map.put(c,1);
                // }
                map.put(c, map.getOrDefault(c, 0) + 1);
            }
    
            //存入优先级队列，并构造排序规则
            PriorityQueue<Node> q = new PriorityQueue<>(new Comparator<Node>(){
                public int compare(Node a, Node b){
                    //分词频
                    if (a.v != b.v)
                        return b.v-a.v;
                    return a.v- b.c;
                }
            });
    
            //将hashmap存入优先级队列
            for(char c:map.keySet()){
                q.add(new Node(c,map.get(c)));
            }
    
            //打印
            StringBuilder sb = new StringBuilder();
            while(!q.isEmpty()){
                Node poll = q.poll();
                int count = poll.v;
                while(count > 0){
                    sb.append(poll.c);
                    count--;
                }
            }
            return sb.toString();
    
        }
    ```

- #### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

  - 一次partition

    ```java
    //一次快排的partition
        public void sortColors(int[] nums) {
            if(nums.length < 2){
                return;
            }
    
            int less = 0, more = nums.length;
            int i = 0;
            while(i < more){
                if(nums[i]==0){
                    swap(nums,i++,less++);
                }
                else if (nums[i] == 1){
                    i++;
                }
                else{
                    swap(nums,i,--more);
                }
            }
        }
    
        public void swap(int[]nums,int i,int j){
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    ```

    

