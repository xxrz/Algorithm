# 刷题

## 剑指offer

### - 排序

#### [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

- 暴力解法: 复制数组，计算奇数的个数

  时间复杂度：O(n)，空间复杂度：O(n)

  ```java
  public int[] reOrderArray(int[] array){
          // 奇数个数
          int oddCnt = 0;
          for (int x : array)
              if (!isEven(x))
                  oddCnt++;
          
          int[] help = array.clone();
          int i = 0;
          for (int num : help) {
              if (!isEven(num))
                  //奇数
                  array[i++] = num;
              else
                  //偶数
                  array[oddCnt++] = num;
          }
          return array;
      }
  ```

- 冒泡法:利用冒泡排序的想法，为偶数则向后冒

  时间复杂度：O(n^2)，空间复杂度：O(1)
  
  ```java
  public class Solution {
      //利用冒泡排序的想法，为偶数则向后冒
      public int[] reOrderArray (int[] array) {
          // write code here
          if(array==null || array.length<2){
              return array;
          }
          
          for(int i = 0;i < array.length;i++){
              for(int j = 1;j<array.length-i;j++){
                  if(isEven(array[j-1])&&!isEven(array[j])){
                      swap(array,j-1,j);
                  }
              }
          }
          return array;
      }
      
      public static void swap(int[] arr,int i,int j){
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
      }
      
  //     public static boolean isEven(int num){
  //         if( num % 2 == 0){
  //             return true;
  //         }
  //         else
  //             return false;
  //     }
      public static boolean isEven(int num){
          return num % 2 == 0;
      }
  }
  ```
  
  

- 双指针

  ```java
      public int[] exchange(int[] nums) {
          if(nums==null || nums.length < 2){
              return nums;
          }
  
          int i = 0,j = nums.length-1;
          while(i < j){
              //i和j发生变化时，需要在控制条件里也限制一下
              while(i<j && nums[i]%2==1) i++; //前面是奇数++
              while(i<j && nums[j]%2==0) j--;//后面是偶数--
              int tmp = nums[i];
              nums[i] = nums[j];
              nums[j] = tmp;
          }
  
          return nums;
      }
  ```


-   partition

    ```java
        public void swap(int[] nums,int i,int j){
            // System.out.println("i:"+i+"\tj:"+j);
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    
        //partition
        public int[] exchange(int[] nums){
            int odd = -1;
            int idx = 0;
            while(idx < nums.length){
                if(odd<nums.length-1 && nums[idx]%2!=0){
                    swap(nums,idx,++odd);
                }
                idx++;    
            }
            return nums;
        }
    ```

    

#### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

- 快排+利用比较器

```java
//利用快排的思想,划分成左右两个部分
    //找一个基准，左边放拼接起来小的数，右边放拼接起来大的数
    public String PrintMinNumber(int [] numbers) {
        if(numbers==null ||numbers.length<1)
            return "";
        //转为字符串数组
        String [] stringArr = new String[numbers.length];
        for(int i=0;i<numbers.length;i++){
            stringArr[i] = String.valueOf(numbers[i]);
        }
        
        //利用快排
        quickSort(stringArr,0,stringArr.length-1);
        
        //转为字符串，StringBuilder比String更通用，可变，快速且节省空间
        StringBuilder res = new StringBuilder();
        for(String s:stringArr){
            res.append(s);
        }
        
        return res.toString();
    }
    
    public void quickSort(String [] numbers,int L,int R) {
        //递归停止条件
        if(L>=R){
            return;
        }
        int mid = partition(numbers,L,R);
        quickSort(numbers, L , mid-1);
        quickSort(numbers, mid + 1 ,R);
        
    } 
    
    public static int partition(String []numbers,int L,int R){
        if(L>R)
            return -1;
        if(L==R)
            return L;
        int less = L-1;
        int i = L;
        
        String p = numbers[R];
        while(i < R){
            if((numbers[i]+p).compareTo(p+numbers[i]) < 0){
                swap(numbers,i,++less);
            }
            i++;
        }
        swap(numbers,R,++less);
        return less;
    }
   
    public static void swap(String[] numbers,int i,int j){
        String tmp = numbers[i];
        numbers[i] = numbers[j];
        numbers[j] = tmp;
    }
```

- 调用

```java
public String PrintMinNumber(int [] numbers) {
        if(numbers==null || numbers.length<1 ){
            return "";
        }
        
        //转为字符串
        String[] strs =  new String[numbers.length];
        for(int i = 0;i<numbers.length;i++){
            strs[i] = numbers[i] + "";
        }
        
        //定义字符串排序,比较器
        Arrays.sort(strs,(s1,s2)->(s1+s2).compareTo(s2+s1));
        String res = "";
        for(String str:strs){
            res = res + str;
        }
        return res;
    }
```

#### [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

利用归并排序，遍历一次知道所有数据状况

- 正着来：nums[i] > nums[j]，说明 nums[i...mid] 都大于 nums[j]

```java
    
// nums[i] > nums[j]，说明 nums[i...mid] 都大于 nums[j]
	int cnt=0;
    public int InversePairs(int [] array) {
        if(array.length != 0){
            divide(array,0,array.length-1);
        }
        return cnt;
    }
    public void divide(int[] array,int start,int end){
        //递归终止条件
        if(start >= end)   return;
        //取中
        int mid=start+(end-start)/2;
        //分
        divide(array,start,mid);
        divide(array,mid+1,end);
        //治
        merge(array,start,mid,end);
    }
    public void merge(int[] array,int start,int mid,int end){
        //临时数组
        int[] tmp=new int[end-start+1];
        //i和j表示两个分数组的左下标，k表示临时数组的当前下标
        int i=start,j=mid+1,k=0;
        while(i<=mid && j<= end){
            //如果前小于后，则存前，前右移
            if(array[i]<=array[j]){
                tmp[k++]=array[i++];
            }
            //如果前大于后，则存后，后右移-------***此时存在逆序对，要进行比较
            else{
                tmp[k++]=array[j++];
                //如果此时前大于后，那么现有前到最后的元素都会大于后
                cnt=(cnt+mid-i+1)%1000000007;
            }
        }
        //未遍历完的直接放在右侧
        while(i<=mid){
            //这块不用加，前面的情况已经包含进去了
            tmp[k++]=array[i++];
        }
        while(j<=end){
            tmp[k++]=array[j++];
        }
        //将临时数组的值覆盖原来数组
        for( k=0;k<tmp.length;k++){
            array[start+k]=tmp[k];
        }
    }
```

- 反着来：

  nums[i] > nums[j]，说明 nums[mid...j] 都小于 nums[j]

  ```java
  int count = 0;
  public int InversePairs(int [] array) {
          if(array != null)
              mergeSort(array,0,array.length-1);
          return count;
      }
      
  public void mergeSort(int []array,int L,int R){
      if(L>=R)
          return;
      int mid = L + ((R-L)>>1);
      mergeSort(array,L,mid);
      mergeSort(array,mid+1,R);
      merge(array,L,mid,R);
  }
  
  public void merge(int [] array,int L,int mid,int R){
      //要反着来，因为选择的是比当前值小的数，从大到小排，最后下标好减
      // nums[i] > nums[j]，说明 nums[mid...j] 都小于 nums[j]
      int p1 = mid,p2 = R ;
      int[] help = new int[R-L+1];
      int index = help.length-1;
      while(p1>=L && p2 >= mid+1){
          if(array[p1] > array[p2]){
              help[index--] = array[p1--];
             //不能写在最后的返回，会出错
              count = (count + p2-mid)%1000000007;
          }else{
              help[index--] = array[p2--];
          }
          
      }
      
      while(p1>=L){
          help[index--] = array[p1--];
      }
      
      while(p2>=mid+1){
          help[index--] = array[p2--];
      }
      
      for(int i=0;i < help.length;i++){
          array[L+i] = help[i];
      }
  }
  ```

#### [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

- 数组

```java
public int duplicate (int[] numbers) {
        // write code here
        int[] res = new int[numbers.length];
        //由于所有数字在0-n-1内，可将原数组中每一个数组当做新数组的下标
        //新数组存次数
        for(int num:numbers){
            res[num]++;
            if(res[num]==2)
                return num;
        }
        return -1;
    }
```

- HashSet

```java
//利用hashSet
    public int duplicate (int[] numbers) {
        // write code here
        HashSet<Integer> hashset = new HashSet<>();
        for(int num:numbers){
            if(hashset.contains(num))
                return num;
            else
                hashset.add(num);
        }
        return -1;
    }

```

-   排序+比较

```java
    //排序+比较
    public int findRepeatNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i = 0;i < nums.length-1;i++){
            if(nums[i]==nums[i+1]){
                return nums[i];
            }
        }
        return nums[0];
    }
```



#### [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

```java
public static boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix==null || matrix.length < 1)
            return false;
        //行
        int hlength  = matrix.length;
        //列
        int llength = matrix[0].length;

        int i = 0,j = llength-1;
        while(i < hlength && j>=0){
            if (j >=0 && matrix[i][j] < target){
                i++;
            }
            if (i < hlength && matrix[i][j] > target){
                j--;
            }
            if (j >=0 && i < hlength && matrix[i][j] == target){
                return true;
            }
        }
        return false;
    }
```

#### [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

- StringBuilder遍历添加

```java
public String replaceSpace(String s) {
        StringBuilder tmp = new StringBuilder();
        char[] cs = s.toCharArray();
        for(int i = 0; i < cs.length; i++ ){
            if(!Character.isSpace(cs[i])){
                tmp.append(cs[i]);
            }else{
                tmp.append("%20");
            }
        }
        return tmp.toString();
    }
```

```java
    public String replaceSpace(String s) {
        StringBuilder res = new StringBuilder();
        for(int i = 0;i < s.length();i++){
            char c = s.charAt(i);
            if(c==' '){
                res.append("%20");
            }else{
                res.append(c);
            }
        }
        return res.toString();
    }
```



- 剑指的做法：

```java
    public String replaceSpace(String s) {
        char[] strs = s.toCharArray();
		
        //计算空格
        int cnt = 0;
        for(int i = 0;i < strs.length;i++){
            if(strs[i]==' ') cnt++;
        }
        // System.out.println("cnt:"+cnt);
        // System.out.println(Arrays.toString(strs));
		
        //定义新旧指针
        char[] res = new char[strs.length + cnt*2];
        int p1 = strs.length-1;
        int p2 = res.length-1;
		
        //赋值
        while(p1 >=0 ){
            if(strs[p1]!=' '){
                // System.out.println("p1 "+p1+" ");
                res[p2--] = strs[p1--];
            }else{
                // System.out.println("p1==== "+p1+" ");
                p1--;
                res[p2--] = '0';
                res[p2--] = '2';
                res[p2--] = '%';
            }
        }

        String newStr = new String(res, 0, res.length);

        return newStr;
    }
```



#### [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

 - 哈希表

   ```java
       public int majorityElement(int[] nums) {
           if(nums==null || nums.length < 1)
               return 0;
   
   
           int cnt = nums.length / 2;
           Map<Integer,Integer> hashmap = new HashMap<Integer,Integer>();
           for(int num:nums){
               if(hashmap.containsKey(num)){
                   if(hashmap.get(num)==cnt){
                       return num;
                   }else{
                       hashmap.put(num,hashmap.get(num) + 1);
                   }
               }
               else{
                   hashmap.put(num,1);
               }
           }
           return nums[cnt];
       }
   ```

   

 - 众数算法

   ```java
   public int majorityElement(int[] nums) {
           if(nums==null || nums.length < 1)
               return 0;
           Arrays.sort(nums);
           return nums[nums.length/2];
       }
   ```

- 摩尔投票法

      设输入数组 nums 的众数为 x ，数组长度为 n。

  推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 >0 。

  推论二： 若数组的前 a个数字的 票数和 =0，则 数组剩余 (n−a)个数字的 票数和一定仍 >0，即后 (n−a)个数字的 众数仍为 x 。（发生 **票数和 =0时，**剩余数组的众数一定不变）

  算法流程:

      初始化： 票数统计 votes = 0 ， 众数 x；
      循环： 遍历数组 nums 中的每个数字 num ；
          当 票数 votes 等于 0 ，则假设当前数字 num 是众数；
          当 num = x 时，票数 votes 自增 1 ；当 num != x 时，票数 votes 自减 1 ；
      返回值： 返回 x 即可；

  ```java
  //摩尔投票
      public int majorityElement(int[] nums) {
          int cnt = 0;
          int pivot = nums[0];
          for(int i = 0;i<nums.length;i++){
              // System.out.println("i:"+i+"\tpivot:"+pivot+"\tcnt:"+cnt);
              if(cnt==0){
                  pivot = nums[i];
              }
              if(nums[i]!=pivot){
                  cnt--;
              }else{
                  cnt++;
              }
          }
          return pivot;
      }
  ```

  
  
  

#### [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

为什么是大根堆：用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1个数开始遍历

```java
    public static int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length <1) {
            return new int[0];
        }

        //创建大根堆
        PriorityQueue<Integer> q = new PriorityQueue<Integer>(new Comparator<Integer>(){
            public int compare(Integer a, Integer b){
                return b - a;
            }
        });

        //维护k个大小的大根堆
        for(int num:arr){
            if(q.size() < k){
                q.offer(num);
            }else if(num < q.peek()){
                q.poll();
                q.offer(num);
            }
        }

        //返回堆元素
        int[] res = new int[q.size()];
        int idx = 0;
        for(int num: q) {
            res[idx++] = num;
        }
        return res;
    }
```

- **快速选择**：绝妙的思路

  ```java
  public int[] getLeastNumbers(int[] arr, int k) {
          if (k == 0 || arr.length == 0) {
              return new int[0];
          }
          // 最后一个参数表示我们要找的是下标为k-1的数，也就是前k个数，因为下标从0开始
          return quickSearch(arr, 0, arr.length - 1, k - 1);
      }
  
      //[L,R]
      public int[] quickSearch(int[] arr, int L, int R, int k) {      
          //快速选择
          int res = partition(arr,L,R);
  
          if(res==k) return Arrays.copyOf(arr,res+1);
  
          if(res < k){
              //k一定在res的右边
              return quickSearch(arr,res+1,R,k);
          }else{
              return quickSearch(arr,L,res-1,k);
          }
      }
  
      //[L,R]
      public int partition(int[] arr,int L,int R){
          //随机交换
          swap(arr,L+(int)Math.random()*(R-L+1),R);
  
          int pivot = arr[R];
          int less = L-1;
          for(int i = L;i <= R;i++){
              if(arr[i] < pivot){
                  swap(arr,++less,i);
              }
          }
          swap(arr,++less,R);
          return less;
      }
  
      public void swap(int[] arr, int i, int j){
          int tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
      }
  ```
  
  

#### [剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

- 排序 + 规则

  ```java
      public boolean isStraight(int[] nums) {
          if(nums==null || nums.length < 5){
              return false;
          }
          Arrays.sort(nums);
          int zeroCnt = 0;
          int diff = 0;
          int i = 0;
          while(i < nums.length-1){
              if (nums[i]==0) {
                  zeroCnt++;
                  i++;
              }else if(nums[i]==nums[i+1] + 1){
                  i++;
              }else if(nums[i] != nums[i+1] +1){
                  diff = nums[i+1]-(nums[i]+1);
                  if(diff==-1 || diff > zeroCnt){
                      return false;
                  }else{
                      i++;
                      zeroCnt = zeroCnt - diff;
                  }
              }
          }
          return true;
      }
  ```

  

- 优化（排序 + 规则）

  优化原则：存在顺子的条件：1.除零外没有任何重复的数字；2.最大值-最小值<5（除0外）

  ```java
      //排序 + 除零外<5
      public boolean isStraight(int[] nums){
          if(nums==null || nums.length < 5){
              return false;
          }
          Arrays.sort(nums);
          int min = 0;
          int i = 0;
          while(i < nums.length-1){
              //
              if(nums[i]==0)
                  min++;
              //注意此处是else if 不是if 
              else if(nums[i]==nums[i+1])
                  return false;
              i++;
          }
          return nums[nums.length-1]-nums[min]<5;
      }
  ```

  

- set + 遍历

  ```java
      //set + 遍历
      //原则：存在顺子的条件：1.除零外没有任何重复的数字；2.最大值-最下值<5（除0外）
      public boolean isStraight(int[] nums) {
          if(nums==null || nums.length < 5){
              return false;
          }
          //min的初始值要注意，不能仅初始化为0，如果数组中没有0就出错了
          int max = 0,min = 14;
          Set<Integer> set = new HashSet<Integer>();
          for(int num:nums){
              if(num==0)
                  continue;
              if(set.contains(num))
                  return false;
              max = Math.max(num,max);
              min = Math.min(num,min);
              set.add(num);
          }
          return max-min < 5;
      }
  ```

#### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

- 字符串构造器

```java
 //原则：利用字符串构造器，和系统排序
    public String minNumber(int[] nums) {
        if(nums ==null || nums.length < 1){
            return "";
        }

        String[] s = new String[nums.length];
        //将数据转为字符串
        for(int i = 0;i < nums.length; i++){
            s[i] = nums[i] +"";
        }
        
        //字符串compareTo的比较器
        Arrays.sort(s,(s1,s2)->(s1+s2).compareTo(s2+s1));

            StringBuilder确实会快一点
        StringBuilder res = new StringBuilder();
        for(String str:s){
            res.append(str);
        }

        // String res = "";
        // for(String str:s){
        //     res += str;
        // }

        return res.toString();
        // return res;
    }
```

- 快排

```java
public String minNumber(int[] nums) {
        if(nums ==null || nums.length < 1){
            return "";
        }

        String[] str = new String[nums.length];
        //将数据转为字符串
        for(int i = 0;i < nums.length; i++){
            str[i] = nums[i] +"";
        }
        quickSort(str,0,nums.length-1);

        StringBuilder res = new StringBuilder();
        for(String s:str){
            res.append(s);
        }

        return res.toString();
    }

    public void quickSort(String[] nums, int L,int R){
        if(L>=R)
            return;
        int mid = partition(nums,L,R);
        quickSort(nums,L,mid);
        quickSort(nums,mid+1,R);
    }

    public int partition(String[] nums,int L,int R){
        swap(nums,(int)(Math.random()*(R-L+1)+L),R);
        String pivot = nums[R];
        int less = L-1;
        int index =L;
        while(index < R){
            //注意字符串的比较的写法
            if((nums[index]+pivot).compareTo(pivot+nums[index]) < 0){
                swap(nums,++less,index++);
            }else{
                index++;
            }
        }
        swap(nums,++less,R);
        return less;
    }

    public void swap(String[] nums,int i,int j){
        String tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
```

#### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

- 构建两个堆，一个大根堆，一个小根堆

  <img src="appendix\二堆.png" alt="二堆" style="zoom:150%;" />

  ```java
  class MedianFinder {
  
      /** initialize your data structure here. */
  
      //建两个堆
      Queue<Integer> A, B;
  
      //算法：
      public MedianFinder() {
          A = new PriorityQueue<>(); // 小顶堆，保存较大的一半，保存较多的一般，A
          B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半,B
      }
      
      public void addNum(int num) {
          //说明是奇数，向B添加元素
          //先插入A，再向B中添加A的堆顶
          if(A.size()!=B.size()){
              A.add(num);
              B.add(A.poll());
          //说明是偶数，向A添加元素
          //先插入B，再向A中添加B的堆顶
          }else{
              B.add(num);
              A.add(B.poll());
          }
      }
      
      public double findMedian() {
  //注意写成2.0
          return A.size()!=B.size()? A.peek():(A.peek()+B.peek())/2.0;
      }
  }
  ```

#### [148.排序链表](https://leetcode-cn.com/problems/sort-list/submissions/)

先找中点，断成两个链

归并排序

时间复杂度：NlogN

```java
class Solution {
    public ListNode sortList(ListNode head) {
        //注意处理特殊情况
        if(head==null || head.next == null)
            return head;

        //定义快慢指针，慢指针走1，快指针走2，快指针指向最后一个node，慢指针走到中点
        ListNode slow = head;
        ListNode fast = head.next;
        
        //找中点
        while(fast!=null && fast.next!=null){  //因为要保证fast和fast.next不会访问出错
            slow = slow.next;
            fast = fast.next.next;
        }

        // ListNode mid = slow;
        ListNode mid = slow.next;

        //断成两个链
        slow.next = null;

        //递归分
        ListNode l1 = sortList(head);
        ListNode l2 = sortList(mid);

        //合并
        //新建一个链表
        ListNode mergeList = new ListNode();
        //定义头结点
        ListNode cur = mergeList;

        while(l1!=null && l2!=null){
            if(l1.val<l2.val){
                cur.next = l1;
                l1= l1.next;
            }else{
                cur.next = l2;
                l2 = l2.next;
            }
            //cur指针的更新
            cur = cur.next;
        }
        if(l1!=null){
            cur.next = l1;
        }else{
            cur.next = l2;
        }
    //链表是链，只用链头就可以
    //     while(l1!=null){
    //         cur.next = l1;
    //         l1 = l1.next;
    //     }

    //     while(l2!=null){
    //         cur.next = l2;
    //         l2 = l2.next;
    //     }

        return mergeList.next;

    }
```

-   分开写，逻辑清晰

```java
    //利用归并排序
    public ListNode sortList(ListNode head) {
        if(head==null) return head;

        return mergeSort(head);
    }

    public ListNode mergeSort(ListNode head){
        if(head.next==null){
            return head;
        }

        ListNode slow = head, fast = head.next;
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
        }

        //断成两个链
        ListNode p1,p2;
        p1 = head;
        p2 = slow.next;
        slow.next = null;

        ListNode l1 = mergeSort(p1);
        ListNode l2 = mergeSort(p2);
        return merge(l1,l2);
        
    }

    public ListNode merge(ListNode l1, ListNode l2){
        //这是假头
        ListNode mergeList = new ListNode(-1);
        ListNode cur = mergeList;

        ListNode p1 = l1,p2 = l2;
        while(p1!=null && p2!=null){
            if(p1.val <= p2.val){
                cur.next = p1;
                p1 = p1.next;
                cur.next.next = null; 
            }else{
                cur.next = p2;
                p2 = p2.next;
                cur.next.next = null; 
            }
            cur = cur.next;
        }

        if(p1!=null){
            cur.next = p1;
        }

        if(p2!=null){
            cur.next = p2;
        }

        //返回值为假头的.next
        return mergeList.next;
    }
```



#### *[56.合并区间](https://leetcode-cn.com/problems/merge-intervals/)

```java
public int[][] merge(int[][] intervals) {
        if(intervals==null || intervals.length < 2)
            return intervals;

        //将intervals用升序进行排序,定义比较器
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] intervals0,int[] intervals1){
                return intervals0[0]-intervals1[0];
            }
        });

        //定义可变数组
        // List list = new ArrayList();这句创建了一个ArrayList实现类的对象后把它上溯到了List接口。此时它就是一个List对
        // 象了，它有些ArrayList类具有的，但是List接口没有的属性和方法，它就不能再用了。 
        // ArrayList list=newArrayList();
        // 创建一对象则保留了ArrayList的所有属性和方法。 
        List <int[]> merged = new ArrayList<int[]>();

        //解法：判断merge[1]和当前cur[0]的大小，决定是更新还是添加
        //更新则选merge[1]intervals[1]的最大值
        for(int i = 0; i < intervals.length;  ++i){
            int L = intervals[i][0],R = intervals[i][1];
            if(merged.size()==0 || merged.get(merged.size()-1)[1] < L){
                merged.add(intervals[i]);
            }else{
                merged.get(merged.size()-1)[1] = Math.max(merged.get(merged.size()-1)[1],R);
            }
        }

        //将可变数组变为普通数组
        return merged.toArray(new int[merged.size()][]);   
    }
```

-   自己写

```java
    public int[][] merge(int[][] intervals) {
        if(intervals==null || intervals.length < 2) return intervals;
        ArrayList<int[]> res = new ArrayList<>();

        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[0]-b[0];
            }
        });

        for(int i =0;i < intervals.length-1;i = i + 2){
            int[] cur = intervals[i];
            int[] next = intervals[i+1];
            int[] tmp = new int[2];
            if(next[0] <= cur[1]){
                tmp[0] = cur[0];
                tmp[1] = Math.max(cur[1],next[1]);
                res.add(tmp);
            }else{
                res.add(cur);
                res.add(next);
            }
        }

        return res.toArray(new int[res.size()][]);
    }
```



#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

- 快速选择

**快速选择**一般用于求解 k-th Element 问题，可以在 *O*(*n*) 时间复杂度，*O*(1) 空间复杂度完成求解工作。快速选择的实现和快速排序相似，不过只需要找到第 *k* 大的枢（pivot）即可，不需要对其左右再进行排序。与快速排序一样，快速选择一般需要先打乱数组。

由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置

所以只要某次划分的 q\*q\* 为倒数第 k\*k\* 个下标的时候，我们就已经找到了答案

分解的过程当中，我们会对子数组进行划分，如果划分得到的 q正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。

```java
//利用快速选择
    public int findKthLargest(int[] nums, int k){
        return quickSelect(nums,0,nums.length-1,nums.length-k);
    }

    public int quickSelect(int[] nums, int L, int R, int index){
        //随机交换值，保证最快的速度
        swap(nums,(int)(L + Math.random()*(R-L+1)),R);
        int res = partition(nums,L,R);
        if(res==index){
            return nums[index];
        }else if (res < index) {
            return quickSelect(nums,res+1,R,index);
        }else{
            return quickSelect(nums,L,res-1,index);
        }
    }

    public int partition(int[] nums, int L , int R){
        int less = L-1;
        int pivot = nums[R];
        int index = L;
        while(index < R){
            if(nums[index] < pivot){
                swap(nums,++less,index);
            }
            index++;
            //注意如果写成这样，务必把index++
            //if(nums[index] < pivot){
            //    swap(nums,++less,index++);
            //}else{
            //    index++;
            //}
            
        }
        swap(nums,++less,R);
        return less;
    }

    public void swap(int[] nums,int i,int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
```

- 堆排序：做k次堆调整就可以

  ```java
  public void swap(int[] nums,int i,int j){
          int tmp = nums[i];
          nums[i] = nums[j];
          nums[j] = tmp;
      }
  
      //堆排
      public int findKthLargest(int[] nums, int k){
          int heapSize = nums.length;
          //建堆，建成完全二叉树
          buildHeap(nums,heapSize);
  
          //调整堆,排序
          for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
              swap(nums, 0, i);
              --heapSize;
              heapify(nums, 0, heapSize);
          }
          return nums[0];
      }
  
      //根节点,向下,选出最大得数
  	//循环的写法
      public void heapify(int[] nums,int i,int heapSize){
          int L = 2*i + 1,R = L + 1;
          int largest = i;
          //当下方还有孩子的时候
          while(i < heapSize){
              if (L < heapSize && nums[L] > nums[largest]){
                  largest = L;
               }
               if (R < heapSize && nums[R] > nums[largest]){
                   largest = R;
               }
  
              if(largest==i)  //如果本来就是自己大，就停止
                  break;
              //不断向下的过程
              swap(nums,largest,i);
              i = largest;
              L = 2*i+1;
              R = L + 1;
          }
      }
  	
  	//递归的写法
      // public void heapify(int[] a, int i, int heapSize) {
      //     int l = i * 2 + 1, r = i * 2 + 2, largest = i;
      //     if (l < heapSize && a[l] > a[largest]) {
      //         largest = l;
      //     } 
      //     if (r < heapSize && a[r] > a[largest]) {
      //         largest = r;
      //     }
      //     if (largest != i) {
      //         swap(a, i, largest);
      //         heapify(a, largest, heapSize);
      //     }
      // }
  
  
      //建堆，下沉的方法
      public void buildHeap(int[] nums,int heapSize){
          for (int i = heapSize - 1; i >= 0; i--) {
  			heapify(nums, i, heapSize);
  		}
      }
  ```

#### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

- 维护k值的最小堆

```java
public int[] topKFrequent(int[] nums, int k) {
        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap<Integer,Integer> map = new HashMap();
        for(int num: nums){
            if(map.containsKey(num)){
                map.put(num,map.get(num) + 1);
            }else{
                map.put(num,1);
            }
        }

         //最大的k个数
        //小根堆
        //存元素，不存次数，次数只用于排序
        PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer a, Integer b){
                return map.get(a)- map.get(b);
            }
        });

        //维护k大小的小根堆
        //获取哈希表中的所有key值
        for(Integer key:map.keySet()){
            if (heap.size() < k){
                heap.add(key);
            //更新最小值，确保是频数最高的k个
            //不要忘记map.get()
            }else if (map.get(key) > map.get(heap.peek())){
                heap.remove();
                heap.add(key);
            }
        }

        //取出最小堆的元素
        List<Integer> res = new ArrayList<>();
        while(!heap.isEmpty())
        {
            res.add(heap.remove());
        }

        int[] array = new int[res.size()];

        //使用for循环得到数组
        for(int i = 0; i < res.size();i++){
            array[i] = res.get(i);
        }

        return array;
    }
```

- 桶排序

  ![桶](\appendix\桶排.png)

  ```java
      //桶排序的方法
      public int[] topKFrequent(int[] nums, int k) {
          //创建哈希表
          HashMap<Integer,Integer> map = new HashMap();
          for (int num : nums){
              if(map.containsKey(num)){
                  map.put(num,map.get(num)+1);
              }else{
                  map.put(num,1);
              }
          }
  
          //桶排序
          //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
          List<Integer>[] bucket = new List[nums.length + 1];
          for(int key: map.keySet()){
              int i = map.get(key);
              //要申请空间
              if(bucket[i]==null){
                  //因为可能存在频数一样多的数字，要用数组存放
                  bucket[i] = new ArrayList();
              }
              bucket[i].add(key);
          }
  
          List<Integer> res = new ArrayList();
          //使用for循环得到数组
          for(int i = bucket.length-1; i >=0 && res.size() < k ;i--){
              if(bucket[i] == null) continue;
              res.addAll(bucket[i]);
          }
  
          int[] array = new int[res.size()];
  
          //使用for循环得到数组
          for(int i = 0; i < res.size();i++){
              array[i] = res.get(i);
          }
          return array;
      }
  ```

#### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

- 桶排序

  ```java
  //桶排序
      public String frequencySort(String s) {
          //创建哈希表
          Map<Character,Integer> map = new HashMap<Character,Integer>();
          char[] cs = s.toCharArray();
          //记录最大频数，以确定桶的数量
          int max = 0;
          for(char c:cs){
              map.put(c,map.getOrDefault(c,0) + 1);
              max = Math.max(map.getOrDefault(c,0) + 1,max);
          }   
  
          //创建桶
          StringBuilder[] bucket = new StringBuilder[max + 1];
          for(int i = 0; i <= max ; i++){
              bucket[i] = new StringBuilder();
          }
          //遍历哈希表，并进桶
          for(Map.Entry<Character,Integer> entry: map.entrySet()){
              char c = entry.getKey();
              int frequency = entry.getValue();
              bucket[frequency].append(c);
          }
  
          //创建字符串
          StringBuilder res = new StringBuilder();
          for(int i = max; i> 0 ;i--){
              StringBuilder b = bucket[i];
              int size = b.length();
              for(int j = 0; j< size; j++){
                  for(int k = 0; k < i;k++)
                      res.append(b.charAt(j));
              }
          }
  
          return res.toString();
  
      }
  ```

  

- 哈希+优先队列

  ```java
      //定义存入优先队列的数据结构
      class Node{
          char c;
          int v;
          Node (char _c,int _v){
              c = _c;
              v = _v;
          }
      }
      //按照出现频率排序
      public String frequencySort(String s) {
  
          //创建哈希表
          Map<Character,Integer> map = new HashMap<Character,Integer>();
          char[] cs = s.toCharArray();
          for(char c: cs){
              // if(map.containsKey(c)){
              //     map.put(c,map.get(c) + 1);
              // }else{
              //     map.put(c,1);
              // }
              map.put(c, map.getOrDefault(c, 0) + 1);
          }
  
          //存入优先级队列，并构造排序规则
          PriorityQueue<Node> q = new PriorityQueue<>(new Comparator<Node>(){
              public int compare(Node a, Node b){
                  //分词频
                  if (a.v != b.v)
                      return b.v-a.v;
                  return a.v- b.c;
              }
          });
  
          //将hashmap存入优先级队列
          for(char c:map.keySet()){
              q.add(new Node(c,map.get(c)));
          }
  
          //打印
          StringBuilder sb = new StringBuilder();
          while(!q.isEmpty()){
              Node poll = q.poll();
              int count = poll.v;
              while(count > 0){
                  sb.append(poll.c);
                  count--;
              }
          }
          return sb.toString();
  
      }
  ```

-   不用定义Node

    ```java
        //哈希 + 堆
        public String frequencySort(String s) {
            char[] cs = s.toCharArray();
            HashMap<Character,Integer> map = new HashMap<>();
    
            for(int i = 0;i < cs.length;i++){
                map.put(cs[i],map.getOrDefault(cs[i],0) + 1);
            }
    
            //大根堆
            //按照频数进行排序
            //但里面存的还是字符
            PriorityQueue<Character> heap = new PriorityQueue<>(new Comparator<Character>(){
                public int compare(Character a, Character b){
                    return map.get(b)-map.get(a);
                }
            });
    
    
            //加入堆
            for(char key : map.keySet()){
                heap.offer(key);
            }
    
    
            StringBuilder res = new StringBuilder();
    
            //堆顶是最大的，此处不能迭代遍历，应该使用poll，从而进行堆调整
            while(!heap.isEmpty()){
                char c = heap.poll();
                for(int i = 0;i < map.get(c);i++){
                    res.append(c);
                }
            }
     
            return res.toString();
        
    ```



#### *[75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

- 一次partition

  ```java
  //一次快排的partition
      public void sortColors(int[] nums) {
          //记录less和more的界限
  
          if(nums.length < 2) return;
  
          int less = -1;
          int more = nums.length;
          int idx = 0;
  
          while(idx < more){
              if(nums[idx]==0){
                  swap(nums,++less,idx++);
              }else if(nums[idx]==1){
                  idx++;
              }else{
                  //注意此处i不能++，否则就会跳过一个数据
                  swap(nums,--more,idx);
              }
          }
  
      }
  
      public void swap(int[] nums,int i, int j){
          int tmp = nums[i];
          nums[i] = nums[j];
          nums[j] = tmp;
      }
  ```
  
  




### -哈希表

#### [面试题50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

- 暴力：两次遍历

  ```java
  public char firstUniqChar(String s) {
          //进入hashmap
          HashMap<Character,Integer> map = new HashMap<Character,Integer>();
          char[] cs = s.toCharArray();
          for(char str:cs){
              map.put(str,map.getOrDefault(str,0)+1);
          }
  
          //遍历，确定第一个
          for(char str:cs){
              if(map.get(str)==1){
                  return str;
              }
          }
          //注意单空格（char），单引号
          return ' ';
      }
  ```

- 优化上一种方法

  ```java
      //优化方法一
      //键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 -1−1（如果该字符出现多次）
      public char firstUniqChar(String s) {
          HashMap<Character,Integer> map = new HashMap<Character,Integer>();
          for(int i = 0;i < s.length();i++){
              if(map.containsKey(s.charAt(i))){
                  map.put(s.charAt(i),-1);
              }else{
                  map.put(s.charAt(i),i);
              }
          }
  
          //找出其中不为 -1−1 的最小值，即为第一个不重复字符的索引，然后返回该索引对应的字符
          
          //注意哈希表示无序的，遍历哈希表也无序
          int min = s.length();
          for(Map.Entry<Character,Integer> entry:map.entrySet()){
              int v = entry.getValue();
              if(v!=-1 && v < min){
                  min = v;
              }
          }
  
          return min==s.length()? ' ':s.charAt(min);
      }
  ```

- 有序哈希表

  ```java
  public char firstUniqChar(String s) {
          Map<Character,Boolean> dic = new LinkedHashMap<>();
          char[] cs = s.toCharArray();
          for (char c :cs){
              dic.put(c,!dic.containsKey(c));
          }
  
          for(Map.Entry<Character,Boolean> entry:dic.entrySet()){
              if(entry.getValue())
                  return entry.getKey();
          }
  
          return ' ';
      }
  ```
  
  ```java
      public char firstUniqChar(String s) {
          LinkedHashMap<Character,Integer> map = new LinkedHashMap<>();
          for(int i = 0;i < s.length();i++){
              char c = s.charAt(i);
              if(map.containsKey(c)){
                  map.put(c,map.get(c)+1);
              }else{
                  map.put(c,1);
              }
          }
  
          // System.out.println(map);
  
          for(char key: map.keySet()){
              if(map.get(key)==1) return key;
          }
  
          return ' ';
      }
  ```
  
  

### - 二分

​	[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```java
public int missingNumber(int[] nums) {
        //思路：利用二分+值和下标对应关系
        //不缺失：nums[i]=i
        //缺失：nums[i]!=i
        int p1 = 0;
        int p2 = nums.length-1;
        int mid;
        while(p1 <= p2){
            mid = (p1 + p2)/2;
            //说明缺失的在后半段
            if (nums[mid]==mid){
                p1 = mid + 1;
            //说明缺失的在前半段
            }else{
                p2 = mid - 1;
            }
        }
        return p1;

    }
```

#### [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

```java
    public int[] twoSum(int[] nums, int target) {
        //对撞双指针（理论性证明）
        int p1 = 0,p2 = nums.length-1;
        int[] res = new int[2];
        //对撞 所以不能相等
        while(p1 < p2){
            if(nums[p1]+nums[p2] == target){
                return  new int[] { nums[p1], nums[p2] };
            }else if(nums[p1]+nums[p2] < target){
                p1++;
            }else{
                p2--;
            }
        }
        return new int[0];
    }
```

```java
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        
        if(nums.length < 2) return res;
        
        int low = 0,high = nums.length-1;
        while(low < high){
            int sum = nums[low] + nums[high];
            if(sum > target){
                high--;
            }else if(sum < target){
                low++;
            }else{
                res[0] = nums[low];
                res[1] = nums[high];
                break;
            }
        }
        return res;
    }
```



#### *[剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

- ```java
  //使用二分法分别找到 左边界 left和 右边界 right
      //清晰一些，确认边界条件或者返回值，自己走一个例子
      public int search(int[] nums,int target){
          int L = 0,R  = nums.length-1;
          int right ,left;
          //查找右边界
          while(L<=R){
              int mid = L+(R-L)/2;
              //考虑相等时，右边界应该在[mid+1,R]
              if(nums[mid] <= target){
                  L = mid + 1; 
              }
              else{
                  R = mid - 1;
              }
          }
          right  =  L;
  
          //优化提前返回,如果右边界在最左边，则该数不存在
          if(R >= 0 && nums[R] != target) return 0;
  
          L = 0;
          R  = nums.length-1;
          //查找左边界
          while(L<=R){
              int mid = L+(R-L)/2;
              //考虑相等时，做边界应该在[L,mid-1]
              if(nums[mid] < target){
                  L = mid + 1; 
              }
              else{
                  R = mid - 1;
              }
          }
          left = R;
  
          return right-left-1;
  
      }
  ```

- 优化

  ```java
      //使用二分法分别找到 左边界 left和 右边界 right
      public int search(int[] nums, int target) {
          int R = helper(nums,target);
          int L = helper(nums,target-1);
          return R-L;
  
      }
  
      //二分查找
      public int helper(int[]nums, int target){
          int L = 0;
          int R = nums.length-1;
          while(L<=R){
              int mid = L + (R-L)/2;
              if(nums[mid] <= target){
                  L = mid +1;
              }else{
                  R = mid -1;
              }
          }
          //此数大1
          return L;
      }
  ```

-   暴力+剪枝

    ```java
    //笑死 还不如暴力    
    public int search(int[] nums, int target) {
            
            int cnt = 0; 
            int s = 0,e =0;
            boolean flag = false;
            for(int i = 0;i < nums.length;i++){
                if(nums[i]==target){
                    if(flag==false){
                        s = i;
                    }
                    flag=true;
                }
                if(flag==true && (nums[i]!=target || i==nums.length-1)){
                    if(nums[i]!=target) e = i;
                    else e = i + 1;
                    break;
                }
    
            }
    
            //处理数组长度为1的情况
            if(flag==true && (e-s)==0) return 1;
    
            return e-s;
        }
    ```

-   纯暴力

    ```java
        public int search(int[] nums, int target) {
            
            int cnt = 0; 
        
            for(int i = 0;i < nums.length;i++){
                if(nums[i]==target){
                    cnt++;
                }
            }
    
            return cnt;
        }
    ```

-   清晰：二分！左右边界！

    ```java
    //找target的左右边界
        //这个左右边界是闭包的
        public int search(int[] nums, int target) {
            if(nums.length==0) return 0;
            int left = left_bound(nums,0,nums.length-1,target);
            int right = right_bound(nums,0,nums.length-1,target);
    //        System.out.println("left:"+left+"" +"\tright:"+right);
            //排除掉-1 -1的情况，也就是不包含元素
            //0 0 表示还有一个元素
            return right==-1 && right==left?0 : right-left+1;
        }
    
        //闭区间[low,high]
        public int left_bound(int[] nums,int low,int high, int target){
            while(low <= high){
                int mid = low + (high-low)/2;
                if(nums[mid] < target){
                    low = mid + 1;
                }else if(nums[mid] > target){
                    high = mid-1;
                }else{
                    high = mid-1;
                }
            }
            //越界
            //low >= nums.length: [1,2,2,2,4] 5
            //nums[left] != target : [5,7,7,8,8,10] 6
            if(low >= nums.length || nums[low] != target) return -1;
    
            return low;
        }
    
        //闭区间[low,high]
        public int right_bound(int[] nums,int low,int high, int target){
            while(low <= high){
                int mid = low + (high-low)/2;
                if(nums[mid] < target){
                    low = mid + 1;
                }else if(nums[mid] > target){
                    high = mid-1;
                }else{
                    low = mid + 1;
                }
            }
            
            //越界：
            //high < 0: [1,2,2,2,4] 0
            //nums[high]!=target:[2,2] 3
            if(high < 0 || nums[high]!=target) return -1;
    
            return high;
        }
    ```

    





#### [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

- 暴力

  ```java
  
      // 暴力
      public int minArray(int[] numbers) {
          int i = 0;
          while(i < numbers.length-1){
              if(numbers[i]<=numbers[i+1] ) i++;
              else return numbers[i + 1];
          }
          return numbers[0];
      }
  ```

- 双指针

  ```java
      // 双指针
      public int minArray(int[] numbers) {
          int i = 0,j = numbers.length-1;
          while(i < j && i<numbers.length &&j>=0){
              if(numbers[i]<=numbers[i+1] ) i++;
              else return numbers[i + 1];
              if(numbers[j]>=numbers[j-1]) j--;
              else return numbers[j];
          }
          return numbers[0];
      }
  ```

- 二分

  ```java
      //二分
      //思路：旋转数组旋转点左侧比大于右侧
      //旋转点一定在右侧，一定会比最右侧值小
      //i = 0,j = length-1
      //mid < j :旋转点在左
      //mid > j :旋转点在右
      //mid = j :无法判断，但根据性质可以顺序查找
      public int minArray(int[] numbers){
          if(numbers==null ||numbers.length < 1){
              return -1;
          }
  
          int i = 0,j = numbers.length-1;
          while(i<j){
              int mid = i + ((j-i)>>1);
              if(numbers[mid] < numbers[j]){
                  //注意：4,5,1,2,3
                  j = mid;
              }else if(numbers[mid] > numbers[j]){
                  i = mid + 1;
              }else{
                  j--;
              }
          }
          return numbers[i];
      }
  ```

	```java
    public int minArray(int[] numbers) {
        int low = 0,high = numbers.length-1;
        while(low < high){
            int mid = low + (high-low)/2;
            if(numbers[mid] < numbers[high]){
                high = mid;
            }else if(numbers[mid] > numbers[high]){
                low = mid + 1;
            }else{//相等的情况下
                high--;
            }
        }
	
        return numbers[low];
    }
	```



####  [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

-   双指针

    ```java
        public boolean isSubsequence(String s, String t) {
            int i=0,j=0;
            while(i < s.length() && j < t.length()){
                if(s.charAt(i)==t.charAt(j)){
                    i++;
                }
                j++;
            }
            return i==s.length();
        }
    ```

    

-   二分

    分思路主要是对 `t` 进行预处理，用一个字典 `index` 将每个字符出现的索引位置按顺序存储下来

    ![image-20220508133900943](appendix/0刷题/image-20220508133900943.png)

    按照之前的解法，我们需要 `j` 线性前进扫描字符 “c”，但借助 `index` 中记录的信息，**可以二分搜索 `index[c]` 中比 j 大的那个索引**，在上图的例子中，就是在 `[0,2,6]` 中搜索比 4 大的那个索引。

    如何用二分查找计算那个恰好比 4 大的索引呢？答案是，寻找左侧边界的二分搜索就可以做到。

​		对于搜索**左侧边界**的二分查找，有一个特殊性质：

​		当 `val` 不存在时，得到的索引恰好是比 `val` 大的最小元素索引

```java
    //二分法
    public boolean isSubsequence(String s, String t) {
        int m = s.length(),n = t.length();
        ArrayList<Integer>[] index = new ArrayList[256];
        //对t进行处理
        //按256个序列，将对应字符的索引按顺序依次加入
        for(int i=0;i<n;i++){
            char c = t.charAt(i);
            if(index[c]==null){
                index[c] = new ArrayList<>();
            }
            index[c].add(i);
        }

        //t的指针
        //当 val 不存在时，得到的索引恰好是比 val 大的最小元素索引。
        int j = 0;
        for(int i = 0;i < m;i++){
            char c = s.charAt(i);
            //就没有字符
            if(index[c]==null) return false;
            //pos是index[c]区间中的位置
            int pos = left_bound(index[c],j);
            //二分区间上没有字符c 比如[0,1,3]上找4
            if(pos==index[c].size()) return false;
            //在t中的位置
            j = index[c].get(pos) + 1;
        }

        return true;
    }

    //返回左边tar
    public int left_bound(ArrayList<Integer> arr,int tar){
        int low = 0,high = arr.size();
        int idx = 0;
        while(low < high){
            int mid = low + (high-low)/2;
            if(arr.get(mid) < tar) low = mid + 1;
            else high = mid;
        }
        return low;
    }
```

-   自己写的更好理解的方式（HashMap + 二分）

```java
    public boolean isSubsequence(String s, String t) {
        if(s.length()==0 ) return true;
        if(t.length()==0 ) return false;


        HashMap<Character,ArrayList<Integer>> map = new HashMap<>();

        //把t对应的入map
        for(int i = 0;i < t.length();i++){
            char c = t.charAt(i);
            if(map.containsKey(c)){
                map.get(c).add(i);
            }else{
                ArrayList<Integer> tmp = new ArrayList<>();
                tmp.add(i);
                map.put(c,tmp);
            }
        }

        System.out.println(map);

        //开始二分查找
        int pre = -1;
        for(int i = 0;i < s.length();i++){
            char c = s.charAt(i);
            if(!map.containsKey(c)) return false;

            pre = left_bound(map.get(c), pre);

            System.out.println("pre:" + pre);

            if(pre==-1) return false;

        }
        return true;
    }

    public int left_bound(ArrayList<Integer> idx, int target){
        int low = 0,high = idx.size()-1;

        while(low<=high){
            int mid = low + (high-low)/2;
            if(idx.get(mid) < target){
                low = mid + 1;
            }else if(idx.get(mid) > target){
                high = mid - 1;
            }else{
                //在左边界的基础上进行了修改
                //当相等的时候，更新low
                //"aaaaaa"
                //"bbaaaa"
                low = mid + 1;
            }
        }

        if(low >= idx.size()) return -1;

        return idx.get(low);
    }
```



### -双指针

#### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

- 倒着遍历字符串，确认每个单词的左右边界（双指针），加入Res

  还要注意多个空格的问题

  ```java
      public String reverseWords(String s) {
          //先去掉多余的空格
          s = s.trim();
          int L = s.length()-1,R = L;
          StringBuilder res = new StringBuilder();
          while(L >= 0){
              //找左边界
              while(L>=0 && s.charAt(L)!=' '){
                  L--;
              }
              //添加单词
              res.append(s.substring(L+1,R+1)+" ");
              //跳过空格
              while(L>=0 && s.charAt(L)==' '){
                  L--;
              }
              R= L;// R 指向下个单词的尾字符
          }
          return res.toString().trim();
      }
  
  ```

- 利用系统库

  ```java
  //利用系统库
      public String reverseWords(String s) {
          String[] s1 = s.trim().split(" ");
          StringBuilder res = new StringBuilder();
          for(int i = s1.length-1; i>=0 ;i--){
              //查看是否是空格
              //因为会有多个空格！
              if(s1[i].equals("")) continue;
              res.append(s1[i]+" ");
          }
          return res.toString().trim();
      }
  ```

#### *[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

取余操作给忘了 ，挺巧妙的

```java
    //暴力
    public String reverseLeftWords(String s, int n) {
        StringBuilder tmp = new StringBuilder();
        StringBuilder res = new StringBuilder();
        char[] cs = s.toCharArray();
        for(int i = 0;i < cs.length; i++){
            if(i < n){
                tmp.append(cs[i]);
            }
            else{
                res.append(cs[i]);
            }
        }
        res.append(tmp);
        return res.toString();

    }

    //字符串切片
    public String reverseLeftWords(String s, int n) {
        return s.substring(n,s.length())+ s.substring(0,n);
    }

    //空间优化
    public String reverseLeftWords(String s, int n) {
        StringBuilder res = new StringBuilder();
        for(int i = n; i < s.length(); i++)
            res.append(s.charAt(i));
        for(int i = 0; i < n; i++)
            res.append(s.charAt(i));
        return res.toString();
    }

    //取余操作简化代码
    public String reverseLeftWords(String s, int n) {
        StringBuilder res = new StringBuilder();
        for(int i = n; i < n + s.length(); i++)
            res.append(s.charAt(i % s.length()));
        return res.toString();
    }
```

#### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

- 求和公式+求根公式

  ![57](appendix\57_求和公式.png)

  ```java
      //求和公式法
      //i<j 且j为整数
      public int[][] findContinuousSequence(int target) {
           int i = 1;
           //j为数组中最大的数,要保留小数
           double j = 2.0;
           List<int []> res = new ArrayList<>();
           //注意条件，不是i < target
           while(i < j){
               j = (-1 + Math.sqrt(1+4*(2*target + (long)i*i-i)))/2;
               if(i < j && j == (int)j){
                   int[] ans = new int[(int)j-i+1];
                   //注意此处的写法
                   for(int k = i;k <= (int)j;k++){
                       ans[k-i] = k;
                   }
                   res.add(ans);
               }
               i++;
           }
           return res.toArray(new int[0][]);
      }
  ```

- 滑动窗口：最大的特点是只能向右滑（双指针）

  ```java
      //滑动窗口
      //左边界，右边界，只往右边滑，而不是来回滑
      //滑动窗口只有 右边界向右移动（扩大窗口） 和 左边界向右移动（缩小窗口）
      //时间复杂度：只向右滑，O(N)
      public int[][] findContinuousSequence(int target) {
          int l = 1,r = 2;
          int sum = l + r;
          List<int []> res = new ArrayList<>();
          while(l < r){
              if(sum==target){
                  int[] ans = new int[r-l+1];
                  for(int k = l;k <= r;k++){
                      ans[k-l] = k;
                  }
                  res.add(ans);
              }
              if(sum >= target){
                  sum = sum - l;
                  l++;
              }else{
                  r++;
                  sum = sum + r;
              }
          } 
          return res.toArray(new int[0][]);
      }
  ```

  ```java
      public int[][] findContinuousSequence(int target) {
          List<int[]> res = new ArrayList<>();
          int left = 1,right = 1;
          int sum = 0;
  
          while(left <= target/2){
              int c = right;
              right++;
  
              sum+=c;
  
              while(sum >= target){
                  if(sum==target){
                      int[] ans = new int[c-left+1];
                      for(int k = left;k <= c;k++){
                          ans[k-left] = k;
                  }
                  res.add(ans);
                  }
                  int d = left;
                  left++;
                  sum = sum-d;
              }
          }
  
          return res.toArray(new int[0][]);
      }
  ```
  
  自己写的，更容易理解吧~
  
  ```java
      public int[][] findContinuousSequence(int target) {
          //滑动窗口
          int low = 1,high = 1;
          int sum = 1;
          ArrayList<int[]> res = new ArrayList<>();
  
          while(high <= (target/2 + 1) ){
              if(sum < target){
                  high++;
                  sum = sum + high;
              }else if(sum > target){
                  sum = sum -low;
                  low++;
              }else{
                  int[] tmp = new int[high-low+1];
                  for(int i = low;i<=high;i++) {
                      tmp[i - low] = i;
                  }
                  res.add(tmp);
                  high++;
                  sum = sum + high;
              }
          }
  
          return res.toArray(new int[res.size()][]);
      }
  ```
  
  



### - 链表

总结：栈，双指针，递归

#### **[剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

**注意迭代的非递归的方式！**还有非递归的方式(要明确递归函数的定义 + 按base case往回推一个通常的情况)

- 双指针（迭代）

  断成两个链，插入排序，链1是反转好的，链2的头要插入链1

  ![image-20220514112343783](appendix/0刷题/image-20220514112343783.png)

  ```java
  class Solution {
      //非递归
      public ListNode reverseList(ListNode head) {
          ListNode pre = null, cur = head, tmp = null;
          while(cur!=null){
              tmp = cur.next;
              cur.next = pre;
              pre = cur;
              cur = tmp;
          }
  
          return pre;
      }
  }
  ```

- **递归**

  1） 如果一个问题 A 可以分解为若干子问题 B、C、D，**你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A*

  2） 所有的递归问题都可以用递推公式来表示

  

  **example**1

  - 问题：逆序打印一个数组
  - 递推公式：

  ```reasonml
  假设令F(n)=逆序遍历长度为n的数组
  那么F(n)= 打印数组中下标为n的元素 + F(n-1)
  ```

  - 终止条件：

  ```kotlin
  if (n <0) return ;
  ```

  - 递归代码：

  ```reasonml
  public void Print(int[] nums,int n){
      if(n<0) return;
      System.out.println(nums[n]);
      Print(nums,n-1);
  }
  ```

  **example2**

  - 问题：二叉树的先序遍历
  - 递推公式：

  ```reasonml
  令F(Root)为问题:遍历以Root为根节点的二叉树，
  令F(Root.left)为问题:遍历以F(Root.left)为根节点的二叉树
  令F(Root.right)为问题:遍历以F(Root.right)为根节点的二叉树
  那么其递推公式为：
  F(Root)=遍历Root节点+F(Root.left)+F(Root.right)
  ```

  - 递归代码：

  ```reasonml
  public void preOrder(TreeNode node){
      if(node==null) return;
      System.out.println(node.val);
      preOrder(node.left);
      preOrder(node.righr);
  }
  ```

  **example3**(此题)

  - 问题：单向链表的反转
  - 递推公式：

  ```reasonml
  令F(node)为问题:反转以node为头节点的单向链表；
  一般，我们需要考虑F(n)和F(n-1)的关系，那么这里，如果n代表以node为头节点的单向链表，那么n-1就代表以node.next为头节点的单向链表.
  所以，我们令F(node.next)为问题：反转以node.next为头节点的单向链表；
  那么，F(node)和F(node.next)之间的关系是？这里我们来简单画个图，假设我们反转3个节点的链表：
  1 -> 2 -> 3
  那么，F(node=1)=F(node=2)+?
  
  这里假设子问题F(node=2)已经解决，那么我们如何解决F(node=1)
  
  很明显，我们需要反转node=2和node=1， 即 node.next.next=node; 同时 node.next=null;
  所以，这个问题就可以是：F(node=1)=F(node=2)+ 反转node=2和node=1
  ```

  - 递归代码：

      明确递归函数的定义：反转一个以head为头的链表，返回值是反转后的链表的头
  
      思考一个中间过程：
  
      ```tex
      起始：
      1->2->3->4->5->null
      base case:
      1->2->3 ->4<-5
      中间状态：
      1->2-> 3<-4<-5
      则head = 2, head.next.next = head, head.next = null;
      => 1-> 2<-3<-4<-5
      ```
  
      
  
      
  
  ```java
  //递归
  //1. 返回值：反转后链表的头
  //2. 递推关系：head是当前节点，node是除head以外反转好的子链的头（不再是head.next），试着1->2->3->4走下就明白了
  //head.next.next = head,head.next=null
  //3. base case: head==null || head.next==null(没有办法链接了)
      public ListNode reverseList(ListNode head){
          //base case
          if(head==null || head.next==null){
              return head;
          }
  
          //递推关系
          ListNode node = reverseList(head.next);
  
          //反转操作
          head.next.next = head;
          head.next = null;
  		
          //返回值
          return node;
      }
  ```

#### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

- 先反转链表 再打印（太麻烦了）

  ```java
      //先反转链表，再打印
      public int[] reversePrint(ListNode head) {
          List<Integer> list = new ArrayList<Integer>();
          ListNode res = reverseList(head);
          for(ListNode cur = res;cur!=null;cur = cur.next){
              list.add(cur.val);
          }
  
          //可变数组转数组
          int[] arrs = new int[list.size()];
          for(int i = 0;i < list.size();i++){
              arrs[i] = list.get(i);
          }
          return arrs;
  
      }
  
      public ListNode reverseList(ListNode head){
          if(head ==null ||head.next==null)
              return head;
          
          ListNode node = reverseList(head.next);
          head.next.next = head;
          head.next = null;
  
          return node;
      }
  ```

- 直接递归打印(分解问题，注意递归条件)

  ```java
      //递归
      List<Integer> tmp = new ArrayList<Integer>();
      public int[] reversePrint(ListNode head) {
          recur(head);
          int[] arrs = new int[tmp.size()];
          for(int i = 0;i < tmp.size();i++){
              arrs[i] = tmp.get(i);
          }
          return arrs;
      }
  
      public void recur(ListNode head){
          if(head==null)
              return;
          recur(head.next);
          tmp.add(head.val);
      }
  ```

- 辅助栈

  ```java
  //链表特点： 只能从前至后访问每个节点。
  //题目要求： 倒序输出节点值。
  //这种 先入后出 的需求可以借助 栈 来实现。
  ```

  ```java
      public int[] reversePrint(ListNode head){
          LinkedList<Integer> stack = new LinkedList<Integer>();
          ListNode cur = head;
          while(cur!=null){
              stack.addLast(cur.val);
              cur = cur.next;
          }
  
          int[] res = new int[stack.size()];
          for(int i=0;i<res.length;i++){
              res[i] = stack.removeLast();
          }
          return res;
      }
  ```

#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

- 辅助栈

  ```java
  //辅助栈
      public ListNode getKthFromEnd(ListNode head, int k) {
          LinkedList<ListNode> stack = new LinkedList<ListNode>();
          while(head!=null){
              stack.addLast(head);
              head = head.next;
          }
  
          ListNode newhead = head;
          //因为长度会变,所以该值要放在外面
          int length = stack.size();
          for(int i = stack.size()-1; i >= 0;i--){
              int index = length-i;
              // System.out.println("i"+i);
              // System.out.println("index"+index);
              if(length-i==k){
                  return stack.removeLast();
              }else{
                  stack.removeLast();
              }
          }
  
          return new ListNode();
      }
  ```

- 快慢指针

  ```java
      //双指针
      public ListNode getKthFromEnd(ListNode head, int k) {
          ListNode slow = head,fast = head;
          //快指针先走K步
          for(int i = 0; i<k;i++){
              fast = fast.next;
          }
          //快慢指针一起走，直到快指针为NULL
          while(fast!=null){
              slow = slow.next;
              fast = fast.next;
          }
          return slow;
      }
  ```

#### [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

- 迭代，伪链头

  ```java
  
     public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
          //创建伪代码头,否则无法用next
          ListNode dum = new ListNode(0);
          ListNode cur = dum;
          while(l1!=null && l2!=null){
              if(l1.val <= l2.val){
                  cur.next = l1;
                  l1 = l1.next;
              }else{
                  cur.next = l2;
                  l2 = l2.next;
              }
              //注意新链表的当前指针也要移动
              cur = cur.next;
          }
          if(l1!=null){
              cur.next = l1;
          }
  
          if(l2!=null){
              cur.next = l2;
          }
  
          return dum.next;
      }
  ```

- 递归(不是特别好理解)

  ```java
      //递归,不是很好理解
  // 特判：如果有一个链表为空，返回另一个链表
  // 如果l1节点值比l2小，下一个节点应该是l1，应该return l1，在return之前，指定l1的下一个节点应该是l1.next和l2俩链表的合并后的头结点
  // 如果l1节点值比l2大，下一个节点应该是l2，应该return l2，在return之前，指定l2的下一个节点应该是l1和l2.next俩链表的合并后的头结点
  
  //递归
  //1. 返回值：合并后的链的尾
  //2. 递推关系：
  //- p1 < p2: 返回p1; p1.next = p1.next和p2的合并的头
  //- p2 < p1: 返回p2; p2.next = p2.next和p1的合并的头
  //3. base case: 
  //- p1==null return p2
  //- p2==null return p1
      public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
          if(l1==null ||l2==null){
              return l1!=null?l1:l2;
          }
  
          if(l1.val <= l2.val){
              l1.next = mergeTwoLists(l1.next,l2);
              return l1;
          }else{
              l2.next = mergeTwoLists(l2.next,l1);
              return l2;
          }
  
      }
  ```

#### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

```java
    public ListNode deleteNode(ListNode head, int val) {
        //考虑可能会删除第一个节点，所以用了伪头
        ListNode dum = new ListNode(0);
        dum.next = head;
        ListNode cur = head,parent = dum;
        while(cur!=null){
            if(cur.val!=val){
                parent.next = cur;
                cur = cur.next;
                parent = parent.next;
            }else{
                parent.next = cur.next;
                cur = null;
                break;
            }
        }
        return dum.next;
    }
```

#### [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

- 哈希表法

  ```java
      // 哈希集合法
      // 首先遍历链表 \textit{headA}headA，并将链表 \textit{headA}headA 中的每个节点加入哈希集合中。然后遍历链表 \textit{headB}headB，对于遍历到的每个节点，判断该节点是否在哈希集合中
      public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
          Set<ListNode> tmp = new HashSet<ListNode>();
          ListNode p1 = headA, p2 = headB;
          while(p1!=null){
              tmp.add(p1);
              p1 = p1.next;
          }
          while(p2!=null){
              if(tmp.contains(p2)){
                  return p2;
              }else{
                  p2 = p2.next;
              }
          }
          return null;
      }
  ```

- 双指针相遇法

  ```java
  //双指针浪漫相遇法
      //两个链表长度分别为L1+C、L2+C， C为公共部分的长度
      // 第一个人走了L1+C步后，回到第二个人起点走L2步；
      // 第2个人走了L2+C步后，回到第一个人起点走L1步。 
      // 当两个人走的步数都为L1+L2+C时就两个人就相爱了
      public ListNode getIntersectionNode(ListNode headA,ListNode headB){
          //处理特殊情况
          if(headA==null || headB==null){
              return null;
          }
  
          ListNode p1 = headA, p2 = headB;
          while(p1!=p2){
              //注意条件，如果是 p1.next!=null，就相当于跳了一步
              if(p1!=null){
                  p1 = p1.next;
              }else{
                  p1 = headB;
              }
  
              if(p2!=null){
                  p2 = p2.next;
              }else{
                  p2 = headA;
              }
  
          }
  
          return p1;
          
      }
  ```

#### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

- 普通链表的复制,同时说明问题难度

  ```java
      //普通链表的复制
      public Node copyList(Node head) {
          Node dum = new Node(0);
          Node pre = dum;
          Node cur = head;
          while(cur!=null){
              Node node = new Node(cur.val);
              pre.next = node;
              //random? 存在问题
              pre = node;
              cur = cur.next;
          }
  
          return dum.next;
      }
  ```

- 哈希表法

  ```java
  //利用哈希表
      //思路：先利用哈希表创建新节点 + 保留old,new之间的关系
      //遍历old的关系，同时赋值给new
      时间复杂度：O(N)
      空间复杂度：O(N)，哈希表
      public Node copyRandomList(Node head) {
          if(head==null)
              return null;
  
          Map<Node,Node> nodeMap = new HashMap<Node,Node>();
          Node cur = head;
  
          //先利用哈希表创建新节点 + 保留old,new之间的关系
          while(cur!=null){
              Node node = new Node(cur.val);
              nodeMap.put(cur, node);
              cur = cur.next;
          }
  
          //遍历old
          cur = head;
          Node newHead =  nodeMap.get(head);
          while(cur!=null){
              Node newCur = nodeMap.get(cur);
              //注意此处是nodeMap.get(cur.next),链向的是新空间，而不是原来的引用
              newCur.next = nodeMap.get(cur.next);
              newCur.random  = nodeMap.get(cur.random);
              cur = cur.next;
          }
          return newHead;
      }
  ```

-   自己写的更好理解的hashmap解法

    ```java
        public Node copyRandomList(Node head) {
            Node p1 = head;
            //(old,new)
            HashMap<Node,Node> map = new HashMap<>(); 
    
            while(p1!=null){
                Node cur = new Node(p1.val);
                map.put(p1,cur);
                p1 = p1.next;
            }
    
            p1 = head;
            while(p1!=null){
                map.get(p1).next = map.get(p1.next);
                map.get(p1).random = map.get(p1.random);
                p1 = p1.next;
            }
    
            return map.get(head);
        }
    ```

    

- 混合链表

  ```java
  //链接链表的方式
      //思路：分三个阶段，第一阶段，创建空间，并让新节点跟着老节点后面，形成合成链表
      //第二阶段，链接新节点的random
      //第三阶段，分割新老链
      //时间复杂度：O(N)
      //空间复杂度：O(1)
      public Node copyRandomList(Node head) {
          if(head==null)
              return null;
  
          //创建空间，形成合成链表
          Node cur = head;
          while(cur!=null){
              Node tmp = new Node(cur.val);
              tmp.next = cur.next;
              cur.next = tmp;
              cur = tmp.next;
          }
  
          //链接random
          cur = head;
          while(cur!=null){
              //注意条件的设置
              if(cur.random!=null){
                  cur.next.random = cur.random.next;
              }
              cur = cur.next.next;
          }
  
          //拆分链表
          cur = head.next;
          Node pre = head, res = head.next;
          while(cur.next!=null){
              pre.next = pre.next.next;
              cur.next = cur.next.next;
              pre = pre.next;
              cur = cur.next;
          }
          //单独处理原链表尾节点
          pre.next = null;
          return res;
      }
  ```

#### * [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

**注意递归：链表的递归多为自下往上，所以在想base case和模拟中间场景的时候需要从下面拿的返回值**

- 递归（典型的递归）

  ![image-20220514165809119](appendix/0刷题/image-20220514165809119.png)

  ```java
      //递归解法:
      //1. 返回值：交换完成后子链表的头
      //2. 递推关系：p1(head),p2(head.next)。p1连p2后面交换完成的链表的值，p2连p1
      //3. base case : 当p1或者p2为空的时候停止递归（也就是head、head.next）
      public ListNode swapPairs(ListNode head) {
          if(head==null || head.next==null){
              return head;
          }
  
          ListNode next = head.next;
          head.next = swapPairs(next.next);
          next.next = head;
  
          return next;
          
      }
  ```

- 非递归

  注意：

  在迭代的时候，每次处理两个节点，于是第一轮 a 指向 1，b 指向 2。
  第二轮的时候 a 指向 3，b 指向 4。第三轮的时候 a 指向 5，b 指向 6。

  我们通过 a.next = b.next，以及b.next=a就把两个指针的位置反转了，于是1->2就变成2->1。

  但这里有一个细节需要处理，当我们第二轮迭代的时候，a 指向 3，b 指向 4。按照题目要求，最终应该是2->1->4->3。**也就是节点 1 需要跟节点 4 串起来**，只有两个指针就没法弄了，所以需要第三个指针 tmp，用来记录上一轮 a 的位置，然后下一轮迭代的时候，将原先的 a(也就是节点 1)指向 4。

  ```java
      public ListNode swapPairs(ListNode head) {
          if(head==null) return null;
  
          if(head.next==null) return head;
  
          //假头
          ListNode dummy = new ListNode(-1);
          dummy.next = head;
          
          ListNode tmp = dummy;
  
          while(tmp.next!=null && tmp.next.next!=null){
              ListNode start = tmp.next;
              ListNode end = tmp.next.next;
  
              //链接上一轮的a和这一轮的最终的头
              tmp.next = end;
  
              //交换
              start.next = end.next;
              end.next = start;
  
              //tmp记录a的上一轮的位置
              tmp = start;
          }
          return dummy.next;
      }
  ```

-   自己写了一遍非递归

    ```java
        public ListNode swapPairs(ListNode head) {
            if(head==null) return head;
            ListNode cur = head;
            ListNode tmp = null,pre = null;
            ListNode x = head.next;
    
            while(cur!=null && cur.next!=null){
                if(pre!=null){
                    pre.next = cur.next;
                }
                
                tmp = cur.next.next;
                cur.next.next = cur;
                cur.next = tmp;
                pre = cur; 
                cur = cur.next;
            }
    
            return x==null? head:x;
        }
    ```

    





#### *[234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

注意优化后的方式。先找到中点，在把链表切成两半；再把后半部分反转；比较是否相等。

得保证形成的是单链表，且考虑奇数和偶数，并明确逆转的头。应该是mid.next

- 好麻烦,但好得是自己写的

    就是对比反转前后的序列化字符是否相同

    ```java
        public boolean isPalindrome(ListNode head) {
            StringBuilder data1 = new StringBuilder();
            StringBuilder data2 = new StringBuilder();
    
            travel(head,data1);
            ListNode newHead = reserve(head);
            travel(newHead,data2);
    
            System.out.println(data1);
            System.out.println(data2);
    
            if(data1.toString().equals(data2.toString())) return true;
            else return false;
        }
    
        //返回逆转以后的头
        public ListNode reserve(ListNode head){
            if(head==null || head.next==null){
                return head;
            }
    
            ListNode node = reserve(head.next);
            head.next.next = head;
            head.next = null;
            return node;
    
        }
    
        public void travel(ListNode head,StringBuilder str){
            if(head==null) return;
    
            str.append(head.val);
            travel(head.next,str);
            // while(head!=null){
            //     str.append(head.val);
            //     head = head.next;
            // }
        }
    ```

    

- 迭代

```java
    public boolean isPalindrome(ListNode head) {
        //先找到中点，在把链表切成两半；再把后半部分反转；比较是否相等

        //base case
        if(head==null || head.next==null) return true;

        //找中点
        ListNode slow = head, fast = head;
        while(fast.next!=null && fast.next.next!=null){
            slow = slow.next;
            fast = fast.next.next;
        }

        //反转
        //得保证形成的是单链表，不然中间就得断开
        slow.next = reverse(slow.next);

        //比较
        //1. 当为奇数的时候
        // 前半段长为3，后半段长为2，比较到2的时候，完全相等就可以确定是回文了，不用管前半段的最后一个
        //2. 当为偶数的时候
        // 前半段长为2，后半段长为2，比较就可以
        slow = slow.next;
        while(slow!=null){
            if(head.val!=slow.val){
                return false;
            }
            head = head.next;
            slow = slow.next;
        }
        return true;
    }

    //反转链表函数
    public ListNode reverse(ListNode head){
        if(head==null ||head.next==null){
            return head;
        }

        ListNode node = reverse(head.next);

        head.next.next = head;
        head.next = null;

        return node;
    }
```

- 递归

```java
//模拟双指针实现回文
//实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的，只不过我们利用的是递归函数的堆栈而已
//左侧
//1. 返回值：该串的左右指针是否相等
//2. 递推：res = 之前的结果res & 当前左右指针是否相等；left = left.next;
//3. base case：right==null

ListNode left;

boolean isPalindrome(ListNode head){
	left = head;
    return traverse(head);
}

boolean traverse(ListNode right){
	if(right==null) return true;
    
    boolean res = traverse(right.next);
    //后序
    res = res && (left.val==right.val);
    left = left.next;
    
    return res;
}
```



### -二叉树

#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

- 递归

  ```java
      public TreeNode mirrorTree(TreeNode root) {
          if(root==null) return null;
  
          //处理当前
          TreeNode tmp = mirrorTree(root.left);
          root.left = mirrorTree(root.right);
          root.right = tmp;
  
          return root;
      }
  ```

- 非递归（栈）

  ```java
      public TreeNode mirrorTree(TreeNode root) {
          //非递归，利用栈，中左右入栈
          //然后交换了左右孩子
  
          if(root==null) return null;
          Stack<TreeNode> stack = new Stack<TreeNode>();
          stack.add(root);
  
          while(!stack.isEmpty()){
              TreeNode cur = stack.pop();
              if(cur.left!=null) stack.add(cur.left);
              if(cur.right!=null) stack.add(cur.right);
  
              TreeNode tmp = cur.left;
              cur.left = cur.right;
              cur.right = tmp;
          }
  
          return root;
          
      }
  ```

#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

- 根据后序遍历

  ```java
      //根据后序遍历
      public int maxDepth(TreeNode root) {
          if(root==null) return 0;
  
          int left = maxDepth(root.left);
          int right = maxDepth(root.right);
          return Math.max(left,right) + 1;
      }
  ```

- 回溯

  ```java
      //1，遍历二叉树 + 变量=》回溯
      //先序遍历
      int depth;
      int res;
      public int maxDepth(TreeNode root) {
          depth = 0;
          res = 0;
          if(root==null) return 0;
          
          recur(root);
          return res;
      }
  
      public void recur(TreeNode root){
          //base case 叶子节点
          if(root==null){
              res = Math.max(res,depth);
              return;
          }
  
          //当前节点
          depth++;
          recur(root.left);
          recur(root.right);
          depth--;
      }
  ```

  -   三刷写的

  ```java
      //回溯法
      int max = Integer.MIN_VALUE;
      int high = 0;
      public int maxDepth(TreeNode root) {
          recur(root);
          return max;
      }
  
      public void recur(TreeNode root){
          if(root==null){
              if(max < high){
                  max = high;
              }
              return;
          }
  
          high++;
          recur(root.left);
          recur(root.right);
          high--;
      }
  ```

  

- 根据找信息

  ```java
      // 找信息的方式
      // 左右两树的层数
      public static int max;  //在此初始化无用
      public int maxDepth(TreeNode root) {
          if(root==null) return 0;
          //注意使用前对全局变量的初始化
          max = 0;
          return maxDepthRecur(root,1) + 1;
      }
      
      public int maxDepthRecur(TreeNode root, int height){
          int left = 0;
          if(root.left!=null){
              left = maxDepthRecur(root.left,height + 1);
              max = Math.max(left, height);
          }
          int right = 0;
          if(root.right!=null){
              right = maxDepthRecur(root.right,height + 1);
              max = Math.max(right ,height);
          }
          return max;
      }
  ```

- 根据层次遍历(队列)

  ```java
      //根据层次遍历
      public int maxDepth(TreeNode root) {
          if(root==null) return 0;
          List<TreeNode> parent = new LinkedList<>(); //存当前层的节点
          List<TreeNode> child; //存上一层节点的所有的孩子
          int res = 0;
          parent.add(root);
          //控制有多少层，从上到下
          while(!parent.isEmpty()){
              //child初始化的位置很重要...，每一层都是一个新的队列
              child = new LinkedList<>();
              //控制当前层的每个节点，从左往右
              for(TreeNode cur : parent){
                  if(cur.left!=null) child.add(cur.left);
                  if(cur.right!=null) child.add(cur.right);
                  
              }
              //巧妙
              parent = child;
              res ++;
          }
          return res;
      
  ```

  -   三刷写的

  ```java
      //层序遍历
      public int maxDepth(TreeNode root) {
          Deque<TreeNode> q = new LinkedList<>();
          if(root!=null) q.offer(root);
          int high = 0;
          while(!q.isEmpty()){
              int len = q.size();
              for(int i = 0;i < len;i++){
                  TreeNode cur = q.poll();
                  if(cur.left!=null) q.offer(cur.left);
                  if(cur.right!=null) q.offer(cur.right);
              }
              high++;
          }
          return high;
      }
  ```

  

- 错误遍历

  ```java
  
      //错误代码
      public int maxDepthRecur(TreeNode root, int height){
          //实际max的值从来都没有变化过，只会返回0，应该在后序进行比较，因为max写在这一句会递归进行
          //max没有+1，当前节点的高度应该等于max(left+right) + 1,且只加一次
          if(root.left!=null){
              left = maxDepthRecur(root.left,height + 1);
              max = Math.max(left, max);
          }
          if(root.right!=null){
              right = maxDepthRecur(root.right,height + 1);
              max = Math.max(right ,max);
          }
          return max;
      }
  ```

#### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

![1](\appendix\二叉树10.png)

- 递归

  **(注意传递到是 L, R)**

  ```java
      // 递归方法二
      // 罗列：
      //         L.val=R.val ：即此两对称节点值相等。
      //         L.left.val = R.right.valL.left.val=R.right.val
      //         L.right.val = R.left.valL.right.val=R.left.val 
      // 信息：
      //         L,R 其实和递归方法一一样
  
  
      //递归方法一
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return true;
          return recur(root.left,root.right);
      }
  
      public boolean recur(TreeNode L,TreeNode R){
          //黑盒判断当前左右节点，并处理特殊情况
          if(L==null && R == null) return true;
          
          //剪枝
          if(L==null || R==null || L.val!=R.val) return false;
  
          //返回最基础的类型
          return recur(L.left,R.right) && recur(L.right,R.left); 
      }
  ```

  - 复杂度分析

    ![1](appendix\二叉树11.png)

- 镜像：但要注意只能比较先序和后序，中序不可以

  ```java
  //先镜像，再对比先序或者后序，中序不可以
      //[1,2,2,2,null,2]中序镜像前后一致
      public static List<Integer> pre1,pre2;
  
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return true;
          //初始化
          pre1 = new ArrayList<>();
          pre2 = new ArrayList<>();
  
          preOrderRecur(root,pre1);
          preOrderRecur(mirrorTree(root),pre2);
          System.out.println("pre1: " + pre1);
          System.out.println("pre2: " + pre2);
          if(pre1.equals(pre2)){
              return true;
          }
          return false;   
      }
  
      public void preOrderRecur(TreeNode root,List<Integer> list){
          if(root==null){
              list.add(-1);
              return;
          }
  
          list.add(root.val);
          preOrderRecur(root.left,list);
          preOrderRecur(root.right,list);
          
      }
  
      public TreeNode mirrorTree(TreeNode root) {
          if(root==null) return null;
  
          //处理当前
          TreeNode tmp = mirrorTree(root.left);
          root.left = mirrorTree(root.right);
          root.right = tmp;
  
          return root;
      }
  ```
  
  
  
- 错误解法：左根右 = 右根左的遍历

  ```java
     //左根右 = 右根左的遍历
      //[1,2,2,2,null,2] 过不了,除了根节点，所有节点的val都一一样
  	//插入特殊值的情况下也不可以
      public static List<Integer> in1,in2;
  
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return true;
          //初始化
          in1 = new ArrayList<>();
          in2 = new ArrayList<>();
  
          inOrder1Recur(root);
          inOrder2Recur(root);
          System.out.println("in1: " + in1);
          System.out.println("in2: " + in2);
          if(in1.equals(in2)){
              return true;
          }
          return false;
      }
  
      public void inOrder1Recur(TreeNode root){
          if(root==null) return;
          inOrder1Recur(root.left);
          in1.add(root.val);
          inOrder1Recur(root.right);
          
      }
  
      public void inOrder2Recur(TreeNode root){
          if(root==null) return;
          inOrder2Recur(root.right);
          in2.add(root.val);
          inOrder2Recur(root.left);
      }
  ```

#### [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

- 层次遍历

  ```java
      public List<List<Integer>> levelOrder(TreeNode root) {
          //层次遍历
          //可变二维数组
          List<List<Integer>> res = new ArrayList<>();
          //队列,存储某一层的所有节点
          LinkedList<TreeNode> queue = new LinkedList<>();  
          
          //先添加头结点
          if(root!=null) queue.add(root);
  
          //处理
          while(!queue.isEmpty()){
              //新建一个当前层的打印结果
              List<Integer> tmp = new ArrayList<>();
              //遍历当前层的节点
              for(int i = queue.size();i > 0;i--){
                  //先出队列
                  TreeNode node  = queue.poll();
                  tmp.add(node.val);
  
                  if(node.left!=null) queue.add(node.left);
                  if(node.right!=null) queue.add(node.right);
              }
              res.add(tmp);
          }
          return res;
      }
  ```

#### [面试题32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

```java
    public int[] levelOrder(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        LinkedList<TreeNode> queue = new LinkedList<>();

        if(root!=null) queue.add(root);

        while(!queue.isEmpty()){
            for(int i = queue.size();i > 0;i--){
                TreeNode cur = queue.poll();
                res.add(cur.val);
                if(cur.left!=null) queue.add(cur.left);
                if(cur.right!=null) queue.add(cur.right);
            }
        }

        int[] res1 = new int[res.size()];
        for(int i=0;i<res.size();i++){
            res1[i] = res.get(i);
        }

        return res1;
    }
```

#### [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

- 错误解法

  ```java
      // 单队列会出错，因为队列，先进的会先处理，那么这一层和下一层的顺序就一样了
  	//所以要么queue变成双端队列，要么tmp变成双端队列（这个方便）
      public List<List<Integer>> levelOrder(TreeNode root) {
          List<List<Integer>> res = new ArrayList<>();
          //定义队列
          LinkedList<TreeNode> queue = new LinkedList<>();
          if(root!=null) queue.add(root);
  
          int level = 0;
          //while控制从上往下，for控制同一层从左往右
          while(!queue.isEmpty()){
              List<Integer> tmp = new ArrayList<>();  //存当前层的节点
              for(int i = queue.size();i>0;i--){
                  TreeNode cur = queue.poll();
                  tmp.add(cur.val);
                  //如果当前层是奇数，那么下一层的顺序是偶数的
                  if((level % 2)==1){
                      if(cur.left!=null) queue.add(cur.left);
                      if(cur.right!=null) queue.add(cur.right);
                  }else{
                      if(cur.right!=null) queue.add(cur.right);
                      if(cur.left!=null) queue.add(cur.left);
                  } 
              }
              level++;
              res.add(tmp);
          }
          return res;
      }
  ```

- 按照层数逆转列表

  ```java
      //tmp倒序
      public List<List<Integer>> levelOrder(TreeNode root) {
          List<List<Integer>> res = new ArrayList<>();
          //定义队列
          LinkedList<TreeNode> queue = new LinkedList<>();
          if(root!=null) queue.add(root);
  
          //while控制从上往下，for控制同一层从左往右
          while(!queue.isEmpty()){
              List<Integer> tmp = new ArrayList<>();  //存当前层的节点
              for(int i = queue.size();i>0;i--){
                  TreeNode cur = queue.poll();
                  tmp.add(cur.val);
                  if(cur.left!=null) queue.add(cur.left);
                  if(cur.right!=null) queue.add(cur.right);
              }
              //逆转列表
              if(res.size()%2==1) Collections.reverse(tmp);
              res.add(tmp);
          }
          return res;
      }
  ```

- 按照层数改变入队顺序

  ```java
       public List<List<Integer>> levelOrder(TreeNode root) {
          Queue<TreeNode> queue = new LinkedList<>();
          List<List<Integer>> res = new ArrayList<>();
          if(root != null) queue.add(root);
          while(!queue.isEmpty()) {
              LinkedList<Integer> tmp = new LinkedList<>();
              for(int i = queue.size(); i > 0; i--) {
                  TreeNode node = queue.poll();
                  if(res.size() % 2 == 0) tmp.add(node.val); // 偶数层 -> 队列尾部，正常
                  else tmp.addFirst(node.val); // 奇数层 -> 队列头部
                  if(node.left != null) queue.add(node.left);
                  if(node.right != null) queue.add(node.right);
              }
              res.add(tmp);
          }
          return res;
      }
  ```

#### *[剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

 **此树的深度** 等于 **左子树的深度** 与 **右子树的深度** 中的 **最大值** +1+1

后序遍历就不用递归套递归了

- 套路（罗列 + 信息）【后序？】

  ```java
      //平衡二叉树：针对每个子树，左右高度差不超过1
      //罗列：左树是平，右树是平，|左高-右高|<=1
      //信息：（递归，信息一致）（process收信息）
      // ​	左树：平？高？
      // ​	右树：平？高？
  
      public static class ReturnType{
          public boolean is;
          public int height;
  
          public ReturnType(boolean is, int height){
              this.is = is;
              this.height = height;
          }
      }
  
      public static ReturnType process(TreeNode node) {
  		if (node == null) {//base
  			return new ReturnType(true, 0);
  		}
  
          //黑盒
          ReturnType left = process(node.left);
          ReturnType right = process(node.right);
  
          int h = Math.max(left.height,right.height) + 1;
          boolean isB = left.is && right.is && Math.abs(left.height-right.height) <=1;
          return new ReturnType(isB, h);
      }
  
      public boolean isBalanced(TreeNode root) {
          return process(root).is;
      }
  ```

- 【先序遍历 + 判断深度 （从顶至底）】（递归套递归了）

  和判断子树一样都是递归套递归

  ```java
  //简写
  //为什么是先序：
  //abs(self.depth(root.left) - self.depth(root.right)) <= 1 ：判断 当前子树 是否是平衡树；
  //self.isBalanced(root.left) ：先序遍历递归，判断 当前子树的左子树 是否是平衡树；
  //self.isBalanced(root.right) ：先序遍历递归，判断 当前子树的右子树 是否是平衡树；
  
      public boolean isBalanced(TreeNode root) {
          if (root == null) return true;
          return Math.abs(depth(root.left) - depth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
      }
  
      private int depth(TreeNode root) {
          if(root==null) return 0;
          return Math.max(depth(root.left),depth(root.right)) + 1;
      }
  ```

  - 复杂度分析

    ![1](appendix\二叉树12.png)

- 【后序遍历 + 剪枝 （从底至顶）】（后序遍历的好处就是可以带着子节点的信息返回）

  ```java
      //后序遍历+减枝
      public boolean isBalanced(TreeNode root) {
          return recur(root)!= -1;
      }
  
      private int recur(TreeNode root) {
          if(root==null) return 0;
          int left = recur(root.left);
          if(left==-1) return -1;
          int right = recur(root.right);
          if(right==-1) return -1;
          return Math.abs(left-right) < 2? Math.max(left,right) + 1 : -1;
      }
  ```

  - 复杂度分析

    时间复杂度 O(N)： N为树的节点数；最差情况下，需要递归遍历树的所有节点。
    空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用O(N) 的栈空间。

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

基于二叉搜索树的中序遍历递增，则逆中序递减

- 浪费空间

  ```java
      //直接利用逆中序遍历，用数组存储，返回结果
      List<Integer> res;
      public int kthLargest(TreeNode root, int k) {
          res  = new ArrayList<>();
          inOrderReverse(root);
          return res.get(k-1);
      }
      
      public void inOrderReverse(TreeNode root){
          if(root==null) return;
  
          inOrderReverse(root.right);
          res.add(root.val);
          inOrderReverse(root.left);
  
      
  ```

- 提前返回, 想将参数设为全局变量就这么写

  ```java
      //提前返回
      //k变全局
      int res,k;
      public int kthLargest(TreeNode root, int k) {
          this.k = k;
          inOrderReverse(root);
          return res;
      }
  
      public void inOrderReverse(TreeNode root){
          if(root==null) return;
  
          inOrderReverse(root.right);
          k--;
          if(k==0) {
              res = root.val;
              return;
          }
          inOrderReverse(root.left);
      }
  ```

-   错误K参数解法

    k放参数和全局有什么区别

    >   参数传进去的K,是生效的，但是你的k = k-1以后是在当前层的K-1，并没有返回值，所以不影响
    >
    >   如图所示:
    >
    >   ![image-20220517143213853](appendix/0刷题/image-20220517143213853.png)
    >
    >   

    ```java
        int max = Integer.MIN_VALUE;
        public int kthLargest(TreeNode root, int k) {
            max = 0;
            recur(root,k);
            return max;
        }
    
        public void recur(TreeNode root,int k){
            if(root==null) return;
            
            recur(root.right,k);
            System.out.println("k:"+ k +"\troot.val:"+root.val);
            k = k-1;
            if(k==0) {
                max = Math.max(root.val,max);
                return;
            }
            recur(root.left,k);
        }
    ```

    



#### [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

- 哈希表，哈希set，从下往上生成链

  ```java
      //哈希表，哈希set
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          if(root==null) return null;
  
          //建哈希表
          HashMap<TreeNode,TreeNode> parentMap =  new HashMap<>();
          parentMap.put(root,null);
          buildParentMap(root,parentMap);
  
          //找p的链，向上，存入hashset
          HashSet<TreeNode> pSet = new HashSet<>();
          TreeNode cur = p;
          while(parentMap.get(cur)!=null){
              pSet.add(cur);
              cur = parentMap.get(cur);
              //System.out.println(cur.val);
          }
  
          //System.out.println();
          cur = q;
          while( cur!=null &&!pSet.contains(cur)){
              cur = parentMap.get(cur);
              //System.out.println(cur.val);
          }
          if(cur==null) return root;
          return cur;
      }
  
      public static void buildParentMap(TreeNode root,HashMap<TreeNode,TreeNode> parentMap){
  
          if(root.left!=null) {
              parentMap.put(root.left,root);
              buildParentMap(root.left,parentMap);
          }
  
          if(root.right!=null) {
              parentMap.put(root.right,root);
              buildParentMap(root.right,parentMap);
          }
      }
  ```

  

- 分析情况(先序遍历)

  ```java
      //先序从上向下进行遍历，最近公共祖先，注意判断所有情况
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          //处理特殊
          if(root==null) return null;
  
          //先序
          if(root==p || root==q) return root;
  
          TreeNode left = lowestCommonAncestor(root.left,p,q);
          TreeNode right = lowestCommonAncestor(root.right,p,q);
  
          if(left==null) return right;
          if(right==null) return left;
          return root;
      }
  ```
  
- 三刷

  ```java
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          if(root==null) return root;
  
          if(root==p || root==q) return root;
          
          TreeNode left = lowestCommonAncestor(root.left,p,q);
          TreeNode right = lowestCommonAncestor(root.right,p,q);
  
          // if(left!=null && right!=null) return root;
          // if(left!=null) return left;
          // if(right!=null) return right;
          // return null;
  
          //可以优化为如下：
          if(left==null) return right;
          if(right==null) return left;
          return root;
      }
  ```

  

#### [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

若 root.val < p.va ，则 p在 root右子树 中；
若 root.val > p.val ，则 pp 在 root左子树 中；
若 root.val = p.val，则 p和 root指向 同一节点 

- 递归

  ```java
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          if(root==null || root==p || root==q) return root;  //base 先序
  
          if(p.val<root.val && q.val<root.val) return lowestCommonAncestor(root.left,p,q);
          if(p.val>root.val && q.val>root.val) return lowestCommonAncestor(root.right,p,q);
  
          return root;
      }
  ```

  - 时间复杂度 O(N) ： 其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 logN （满二叉树），最大为 N （退化为链表）。
    空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到树的层数 NN 。

    

- 迭代

  ```java
  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          //迭代
          while(root!=null){
              if(p.val < root.val && q.val< root.val){
                  root = root.left;
              }
              else if(p.val > root.val && q.val > root.val){
                  root = root.right;
              }
              else{
                  break;
              }
          }
          return root;
  
      }
  ```

  - 时间复杂度 O(N)O(N) ： 其中 NN 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 \log NlogN （满二叉树），最大为 NN （退化为链表）。
    空间复杂度 O(1)O(1) ： 使用常数大小的额外空间。

#### [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)（先序和中序）

太难了（分治）

- 基于以下原理

  ```java
  // 前序遍历的首元素 为 树的根节点 node 的值
  // 在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 
  // 根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ]
  
  // 分治算法解析：
  // 递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；
  // 终止条件： 当 left > right ，代表已经越过叶节点，此时返回 null ；
  // 递推工作：
  //     1. 建立根节点 node ： 节点值为 preorder[root] ；
  //     2. 划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；
  //         为了提升效率，本文使用哈希表 dic 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)；
  //     3. 构建左右子树： 开启左右子树递归；
  // =》推出
  // 中序遍历中左子树的边界[left,i-1]，先序遍历中root位置：root+1 
  // 中序遍历中右子树的边界[i+1,right],先序遍历中root位置：i-left+1+root
  
      int[] preorder; //先序序列
      HashMap<Integer,Integer> inoderMap = new HashMap<>();  //中序序列
      public TreeNode buildTree(int[] preorder, int[] inorder) {
          this.preorder = preorder;
  
          //为中序构建map
          for(int i = 0;i < inorder.length;i++){
              inoderMap.put(inorder[i],i);
          }
          return recur(0,0,inorder.length-1);
      }
  
      public TreeNode recur(int root,int left, int right){
          if(left > right) return null; //遇到空节点,递归终止
  
          TreeNode node = new TreeNode(preorder[root]);  //创建根节点
          int i = inoderMap.get(preorder[root]); //划分根节点，左子树，右子树
          node.left = recur(root+1,left,i-1); //递归构建左子树
          node.right = recur(i-left+1+root,i+1,right); //递归构建右子树
          return node;    //分治返回给根节点
      }
  ```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java

    int[] postorder; //先序序列
    HashMap<Integer,Integer> inoderMap = new HashMap<>();  //中序序列
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.postorder = postorder;

        //为中序构建map
        for(int i = 0;i < inorder.length;i++){
            inoderMap.put(inorder[i],i);
        }
        return recur(postorder.length-1,0,inorder.length-1);
    }

    public TreeNode recur(int root, int left, int right){
        if(left > right ||  root < 0) return null;
        // System.out.print(root + " ");
        TreeNode node = new TreeNode(postorder[root]);
        int i = inoderMap.get(postorder[root]);

        node.left = recur(root-right+i-1,left,i-1);
        node.right = recur(root-1,i+1,right);
    
        return node;
    }
```

#### *[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

>   划分节点

- 假设是二叉搜索树，利用中序是升序求出升序
  - 相当于利用中序和后序建树，但是不建，只是进行判断
  - 如果是，则代码没有问题，但是当不是二叉搜索树时，会出现重复遍历节点，可以依据这个进行判断

```java
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) { val = x; }
    }

    int[] postorder;
    int[] inorder;
    ArrayList<Integer> inorder1;
    HashMap<Integer,Integer> inorderMap = new HashMap<>();

    public boolean verifyPostorder(int[] postorder) {
        this.postorder = postorder;

        //得到中序遍历的列表
        int[] inorder = new int[postorder.length];
        for(int i=0;i<postorder.length;i++){
            inorder[i] = postorder[i];
        }
        Arrays.sort(inorder);
        this.inorder = inorder;
        // for(int i=0;i<inorder.length;i++){
        //     System.out.print(inorder[i]+" ");
        // }
        

        //将中序列表放入hashMap
        for(int i =0;i < inorder.length;i++){
            inorderMap.put(inorder[i],i);
        }

        //利用中序和后序建二叉树 改
        return recur(postorder.length-1,0,inorder.length-1);
    }

    HashSet<Integer> tmp = new HashSet<>();
    public boolean recur(int root, int left, int right){
        if(left > right ||  root < 0) return true; //处理叶节点

        //如果不是二叉树则会重复陷入死循环
        if(tmp.contains(postorder[root])) return false;
        // System.out.print(root+" ");
        TreeNode node = new TreeNode(postorder[root]);
        tmp.add(node.val);
        int i = inorderMap.get(postorder[root]);
        
        if(recur(root-right+i-1,left,i-1) && recur(root-1,i+1,right))
            return true;
        return false;
    }

    public void inorderRecur(TreeNode root){
        if(root==null) return;

        inorderRecur(root.left);
        inorder1.add(root.val);
        inorderRecur(root.right);
    }
```

- 标准：找出左右子树的分割点,则左树都小于根，右树都大于根，然后判断

  ```java
      // 方法二
      public boolean verifyPostorder(int[] postorder) {
          return recur(postorder, 0, postorder.length - 1);
      }
      //利用先序遍历，先判断当前子树序列是否合适，再判断左子序列，再判断右子序列
      //后序遍历，postorder[e]为根
      boolean recur(int[] postorder, int i, int j) {
          //base case 叶子节点及空节点返回true,有等于号
          if(i >= j) return true;
          int p = i;
  
          //1.划分左右子树
          //从左到右找到第一个比根大的节点，作为左右子树的分界线
          while(postorder[p] < postorder[j]) p++;
          
          //2. 判断当前节点是否合适
          //r之后都为右子树，看能否走到底
          int m = p;
          while(postorder[p] > postorder[j]) p++;
  
          //3. 返回
          return p == j && recur(postorder, i, m - 1) && recur(postorder, m, j - 1);
      }
  ```

- 单调栈的方法

  后续遍历，逆过来。在遍历树的时候，维持一个单调递增的栈，这样出栈的顺序是右根左，降序序列，只要最后栈空的时候，出栈的顺序是降序则是
  
  如果这题改成先序遍历。维持一个单调递减的栈，这样出栈的顺序是左根右，升序序列，只要最后栈空的时候，出栈的顺序是升序则是
  
  ```java
      public boolean verifyPostorder(int[] postorder) {
          //辅助栈，维护一个单调递增的栈，也就是只让根和右孩子入栈，当前节点作为别人的右孩子的时候入栈
          
          //倒过来，根右左
          //维持单调递增，所以只有根右入栈，当遇到左就出栈了
          //所以出栈顺序是降序
          Stack<Integer> s = new Stack<>();
  
          //
          int pre = Integer.MAX_VALUE;
          for(int i = postorder.length-1;i>=0;i--){
              //判断当前序列是否是递减的，如果不是则为false
              ////无论当前遇到的是根还是右，都应该比左大，所以条件判断放到这也可以
              if(postorder[i] > root) return false;
  
              //维护单调递减的栈
              while(!s.isEmpty() && s.peek() > postorder[i]){
                  pre = s.pop();
              }
  
              s.add(postorder[i]);
          }
  
          return true;
      }
  ```
  
  
  
- 假设是二叉搜索树，利用中序是升序求出升序【**好好研磨一下，感谢室友大腿帮我调了两个小时bug**】

  - 相当于利用中序和后序建树，但是不建，只是进行判断
  - 利用先序遍历 + 二叉搜索树左小右大的性质进行判断
  - 递归终止条件是左右子树都是空，而左右子树单独存在是子问题的情况之一，既然分不清就不要ran一起
  - 记得判空

  ```java
  
     	int[] postorder;
      int[] inorder;
      HashMap<Integer,Integer> inorderMap = new HashMap<>();
      public boolean verifyPostorder(int[] postorder) {
          if(postorder.length==0) return true;
          this.postorder = postorder;
  
          //得到中序遍历的列表
          inorder = new int[postorder.length];
          this.inorder = inorder;
          for(int i=0;i < postorder.length;i++){
              inorder[i] = postorder[i];
          }
  
          Arrays.sort(inorder);
  
          //把信息放入hashmap
          for(int i =0; i < inorder.length; i++){
              inorderMap.put(inorder[i],i);
          }
  
          return recur(postorder.length-1,0,inorder.length-1);
      }
  
      public boolean recur(int root,int left,int right){
          //左右节点都不存在的时候，可以直接返回true
          //建树的时候没有等是因为要给叶子节点创建空间
           if(left >= right || root < 0) return true;
          int inindex  = inorderMap.get(postorder[root]);
          // for(int i=left;i<=right;i++){
          //     System.out.print(inorder[i] + " ");
          // }
          // System.out.println("end arr");
          //  System.out.println("root: "+ root  + "left" + left + "right" + right);
  
          //left>=right 表示只有根节点，或者左右子树不存在
          //root-1 < 0 表示右子树不存在，但这个条件不全（有问题），因为在后序遍历【左右根】中存在，有左无右，root-1>0但没有右子树
          //right - inindex < 1 表示右子树不存在（上个条件的替换）
          //root-right+inindex-1 < 0 表示左子树不存在
          //if(left >= right || root < 1 || root-right+inindex-1 < 0 || right - inindex < 1) return true;
          //但是此处逻辑不对，没有右子树就返回true，不管有没有左 [4, 6, 7, 5]
          //没有左子树就返回true，不管有无右  [3,10,6,9,2]
          //应该分开判断
          int rootval = postorder[root];
          // System.out.println("root: "+ root +   " "   + postorder[root]);
          // System.out.println("inindex: "+ inindex);
          // int leftval = postorder[root-right+inindex-1];
          // System.out.println("leftindex: "+ (int)(root-right+inindex-1));
          // int rightval = postorder[root-1];
          // System.out.println("rigthindex: "+ (int)(root-1));
          // System.out.print(rootval + " "+ leftval + " "+ rightval);
          // System.out.println();
          
          //设置一个初始值，如果存在左子树，进行判断
          boolean f1 = true;
          if(root-right+inindex-1 >= 0){
              int leftval = postorder[root-right+inindex-1];
              if(leftval > rootval) f1 = false;
          }
          //设置一个初始值，如果存在右子树，进行判断
          boolean f2 = true;
          if(right - inindex >= 1){
              int rightval = postorder[root-1];
              if(rightval < rootval) f2 = false;
          }
  
          //剪枝
          // if(leftval > rootval || rightval < rootval) return false;
          if(!f1||!f2) return false;
  
          return recur(root-right+inindex-1,left,inindex-1)&&recur(root-1,inindex+1,right);
      }
  
  ```

  

#### *[剑指 Offer 2. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

>   要注意递归终止条件

平衡二叉树也有递归套递归

- 递归套递归，其实就是遍历A的每个节点x, 判断以x为根的子树是否包含B

  ```java
      //先序遍历树A的每个节点
      public boolean isSubStructure(TreeNode A, TreeNode B) {
          if(A==null || B==null) return false;
  
          return recur(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);   
      }
  
      //判断以A为节点的子树是否包含B
      public boolean recur(TreeNode A,TreeNode B){
          //B树遍历完了，说明是
          if(B==null) return true;
          //两个节点不相等
          //A==null说明isSubStructure函数遍历到最后了
          if(A==null || A.val!=B.val) return false;
      
          return recur(A.left,B.left) && recur(A.right,B.right);
  
      }
  ```
  
  

#### ** [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

>   三刷：真的难啊这个题，
>
>   关键点在于要怎么记录这个pre,head
>
>   每次链接的是 两个节点之间的两个指向，而不是三个节点！！

- 利用中序遍历，维护全局的pre和head

  **第二次做勉强理解**
  
  ```java
      Node pre,head;
      public Node treeToDoublyList(Node root) {
          if(root==null) return null;
          dfs(root);
          //链接头尾
          head.left = pre;
          pre.right = head;
          return head;
      }
  
      //利用中序遍历
      public void dfs(Node cur){
          if(cur==null) return;
  
          dfs(cur.left);
          //用一个判断确定是否是头
          if(pre!=null){
              pre.right = cur;
          }else{
              head = cur;
          }
          cur.left = pre;
          pre = cur;
  
          dfs(cur.right);
      }
  ```

#### * [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

>   需要注意添加答案的位置，如果null会添加两次，那就再叶子节点添加
>
>   并且注意回溯的状态重置问题

- 先序遍历+记录path，遍历还是一样的遍历（递归终止条件没变），回溯指维护path中的节点

  **注意：变量放在参数里，每个节点都是可以记录的，所以不用回溯，一般回溯的是是影响全局的变量**
  
  ```java
      //先序遍历 + 记录
      LinkedList<List<Integer>> res = new LinkedList<>();
      LinkedList<Integer> path = new LinkedList<>(); 
      public List<List<Integer>> pathSum(TreeNode root, int target) {
          recur(root, target);
          return res;
      }
  
      void recur(TreeNode root,int target){
          //放在这会加两次
          // if(target==0) res.add(new LinkedList(path));
          if(root==null) return;
  
          path.add(root.val);
          target -= root.val;
  
          //和为target, 且当前节点为叶子节点
          if(target==0 && root.left==null && root.right==null){
              //因为path是全局，如果这样加入，后面改变则都改变了
              //res.add(path);
              //所以需要创建一个新的空间加入
              res.add(new LinkedList(path));
          }
  
          recur(root.left,target);
          recur(root.right,target);
  
          path.removeLast();  //path回溯返回上一层
  
      }
  ```

-   三刷

    

    ```java
    List<List<Integer>> res = new LinkedList<>();
        LinkedList<Integer> path = new LinkedList<>();
        int sum = 0;
        int target;
    
        public List<List<Integer>> pathSum(TreeNode root, int target) {
            this.target = target;
            help(root);
            return res;
        }
    
        public void help(TreeNode root){
            // //放在这里左子树会加一次
            // //右子树会加一次
            // if(root==null){
            //     if(sum==target){
            //         res.add(new LinkedList<Integer>(path));
            //     }
               
            //     return;
            // }
    
            if(root==null) return;
            sum = sum + root.val;
            path.add(root.val);
            // System.out.print("\troot:"+root.val + "\tsum:"+sum+"\ttmp:"+path);
    
            // if(sum==target && root.left==null && root.right==null){
            //     res.add(new LinkedList<Integer>(path));
            // }
    
            //回溯的所有return前 都需要注意状态是否在此前发生了改变，如果发生了改变，在return前一定要进行重置
            if(sum==target && root.left==null && root.right==null){
                res.add(new LinkedList<Integer>(path));
                sum = sum - root.val;
                path.removeLast();
                return;
            }
    
            help(root.left);
            help(root.right);
            sum = sum - root.val;
            path.removeLast();
        }
    ```

    



#### [剑指 Offer 37. 序列化二叉树  LCOF](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

>   三刷：要注意序列化的分隔符不能选择"-"，遇到负数会有问题
>
>   不能选择“.”，也会有问题

分治

```java
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null){
            return "#!";
        }
        StringBuilder res = new StringBuilder();
        //以“！”做分割，以防止分不清是1和3还是13
        res.append(root.val + "!");
        res.append(serialize(root.left));
        res.append(serialize(root.right));
        // System.out.println(res);
        return res.toString();
    }

    // Decodes your encoded data to tree.
    Queue<String> queue;
    public TreeNode deserialize(String data) {
        String[] numbers = data.split("!");
        queue = new LinkedList<String>();

        //添加到队列
        for(int i=0; i<numbers.length;i++){
            queue.offer(numbers[i]);
        }

        return recur();
    }
    
    //先序遍历 + 分治
    public TreeNode recur(){
        //当头结点为空的时候，poll()选择返回null，pop()选择抛出异常
        //空不了
        String value = queue.poll();
		if (value.equals("#")) {
			return null;
		}
		TreeNode head = new TreeNode(Integer.valueOf(value));
        // System.out.println("b" + value);
		head.left = recur();
		head.right = recur();
		return head;
    }
```

### - 递归

#### [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

> 还差一点，条件句构建基本成功，但是根据返回值，应该构造一个和，于是(n = n + sum(n-1)) > 0

- 正常递归

  ```java
      //正常递归
      public int sumNums(int n) {
          if(n==1) return 1;
  
          return n + sumNums(n-1);
      }
  ```

  

- 利用短路构成语句代替if条件

  if(A && B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A && B 为 false

  if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true

  ```java
      //利用短路代替if条件判断
      public int sumNums(int n) {
          boolean x = n > 1 && (n += sumNums(n-1)) > 0;
  
          return n;
      }
  
  // Java 中，为构成语句，需加一个辅助布尔量 xxx ，否则会报错；
  // Java 中，开启递归函数需改写为 sumNums(n - 1) > 0 ，此整体作为一个布尔量输出，否则会报错；
  // 初始化变量 resresres 记录结果。（ Java 可使用上面的简洁写法，不用借助变量 resresres ）。
  
      int res = 0;
      public int sumNums(int n) {
          boolean x = n > 1 && sumNums(n-1) > 0;
  
          res += n;
  
          return res;
      }
  ```

#### **[剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

> 三刷都记不住这个题：在二进制级别进行运算。base = base * base; power = power>>1

//快速幂算法
        //1. 注意：int类型是：-2^31-(2^31-1),所以当n= -2147483648,执行n = -n的时候，就会造成越界，需要转到long类型
        //2. 注意：普通的递归会爆栈，所以需要采用快速幂的方式
        //         快速幂：利用把n转为2进制，右移，最后一位和1与，如果是1则res = res*base，如果是0对res不操作，每次base都要左移，power都要右移

- 错误做法

  ```java
      //是因为栈溢出递归调用太多次而不是因为整型的取值范围，也不是因为算法错了
      //0.00001  2147483647
      public double myPow(double x, int n) {
          //base case
          long b = n;
          if(x == 0) return 1;
          if(n < 0 ) {
              x = 1/x;
              b = -b;
          }
  
          return help(x,b);        
      }
  
      public double help(double x,long b){
          if(b==0) return 1;
  
          return x*help(x,b-1);
      }
  ```

  

- 递归+快速幂

  ```java
      public double myPow(double x, int n) {
          long b = n;
          if (n < 0) {
              b = -b;
              x = 1 / x;
          }
          return culc(x, b);
      }
  
      public double culc(double base, long power) {
          if (power == 0) {
              return 1;
          }
  
          double t = culc(base, power >> 1);
  
          if ((power & 1) == 1) {
              return t * t * base;
          }
  
          return t * t;
      }
  ```

  

- 快速幂、二分、位运算、迭代

  其实就是二进制的运算，注意右移和左移，和&1的含义
  
  ![image-20220424221736837](appendix\0刷题\image-20220424221736837.png)
  
  ```java
      public double myPow(double x, int n) {
  
          //快速幂算法
          //1. 注意：int类型是：-2^31-(2^31-1),所以当n= -2147483648,执行n = -n的时候，就会造成越界，需要转到long类型
          //2. 注意：普通的递归会爆栈，所以需要采用快速幂的方式
          //         快速幂：利用把n转为2进制，右移，最后一位和1与，如果是1则res = res*base，如果是0对res不操作，每次base都要左移，power都要右移
          if(x==0) return x;
          long b = n;
          if(n<0){
              b = -b;
              x = 1/x;
          }
  
          return help(x,b);
  
      }
  
      public double help(double base, long power){
          double res = 1;
          while(power>0){
              if((power & 1)==1) res *= base; 
            base = base * base;
              power = power>>1;
          }
  
        return res;
      }
  ```
```
  


- 另一种除法的理解

向下整除 n//2 等价于 右移一位n>>1 ；
取余数 n%2 等价于 判断二进制最右一位值 n&1 ；

​```java
    public double myPow(double x, int n) {
        if(x == 0) return 0;
        long b = n;
        double res = 1.0;
        if(b < 0) {
            x = 1 / x;
            b = -b;
        }
        while(b > 0){
            if((b&1)==1) res = res*x;  //如果为奇数,多乘一个x
            x *= x; //x*x
            b >>= 1;  // b//=2;
        }
        return res;
    }
```

注意：

```java
Java 代码中 int32 变量 n∈[-2147483648, 2147483647]，因此当 n=−2147483648时执行 n=−n 会因越界而赋值出错。解决方法是先将 n 存入 long 变量b ，后面用 b 操作即可。
```





二进制获取每一位：

获取二进制各位 b1,b2,b3,...,bm 的值： 循环执行以下操作即可。

```
n&n （与操作）： 判断 n 二进制最右一位是否为 111 ；
n>>1 （移位操作）： n右移一位（可理解为删除最后一位）。
```


深度优先搜索类型的题可以分为主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否可以开始搜索，如果可以即在辅函数进行搜索。辅函数则负责深度优先搜索的递归调用。

base: 最后在边界的时候才返回

治：最后return 

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

- 深搜 + 递归
  - 技巧：控制搜索方向的数组，di和dj相对应着
  - 注意边界，以及已经搜过了的节点要进行标记

```java
    //该题不是回溯，是深搜，遍历最大的相邻为1的和
    //主函数：遍历所有搜索位置
    public int maxAreaOfIsland(int[][] grid) {
        int ans = 0;
        for(int i = 0;i < grid.length; i++){
            for(int j=0;j<grid[0].length;j++){
                ans = Math.max(ans,dfs(grid,i,j));
            }
        }
        return ans;
    }

    //辅函数：用于做深搜
    //当前的头节点位置
    public int dfs(int[][] grid,int i,int j){
        if(i < 0 || j < 0 || i==grid.length || j==grid[0].length){  //base:边界
            return 0;
        }
        //只有当前位置为1才进行搜索
        if(grid[i][j]==0){
            return 0;
        }

        //代表当前节点已经被搜索过了，之后不再进行搜索了
        grid[i][j] = 0;
        //由di和dj分别对应控制上下左右（往四个地方去做搜索）
        int[] di = {0,0,-1,1};
        int[] dj = {1,-1,0,0};

        int ans = 1;
        for(int index = 0;index < 4;index++){
            int next_i = i + di[index];
            int next_j = j + dj[index];
            //进行深搜
            ans += dfs(grid,next_i,next_j);
        }
        return ans;
    }
```

- 三刷

```java
    int[] dx = {1,-1,0,0};
    int[] dy = {0,0,1,-1};
    boolean[][] visited;
    int sum = 0;

    public int maxAreaOfIsland(int[][] grid) {
        visited = new boolean[grid.length][grid[0].length];
        int max = 0;
        for(int i = 0;i < grid.length;i++){
            for(int j=0;j < grid[0].length;j++){
                sum = 0;
                if(grid[i][j]==1) max = Math.max(recur(grid,i,j),max);
            }
        }
        return max;
    }

    //从i,j出发的点的面积
    public int recur(int[][] grid,int i,int j){
        if(i < 0 || i >= grid.length || j < 0 ||j >= grid[0].length){
            return 0;
        }

        if(visited[i][j] || grid[i][j]==0) return 0;

        visited[i][j]=true;
        sum = sum + 1;

        for(int k = 0;k < 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            recur(grid,x,y);
        }

        return sum;
    }
```





#### *[剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

**上下左右会形成环的时候一定要用used,否则在当前路径会遍历同一个节点两次**

边界条件一定要想清楚

- 深度优先遍历+剪枝

  ```java
      public boolean exist(char[][] board, String word) {
  
          for(int i = 0;i < board.length;i++){
              for(int j=0;j < board[0].length;j++){
                  boolean[][] used = new boolean[board.length][board[0].length];
                  boolean res = dfs(board,i,j,word,0,used);
                  if(res){
                      return true;
                  }
              }
          }
          return false;
      }
  
      //二维数组，以当前（i,j）节点为头开始递归，word所求词，idx为遍历到word的第几个词,判断当前节点有无被访问过
      public boolean dfs(char[][]board, int i, int j, String word,int idx,boolean[][]used){
          //如果当前字符也不相等，则直接返回（剪枝）+ 边界
          //边界条件没有想清楚
          if(i < 0 || j < 0 || i == board.length || j==board[0].length || board[i][j]!=word.charAt(idx)){
              return false;
          }
          
          //排除遍历过的节点
          if(used[i][j]) return false;
  
          if(idx == word.length()-1 ) return true;
  
          //将当前节点标记为已访问
          used[i][j] = true;
  
          //定义上下左右四个方向 
          int[] di ={0,0,-1,1};
          int[] dj = {1,-1,0,0};
          
          //开始递归
          boolean res = false;
          for(int k = 0; k<4 ;k++){
              res |= dfs(board,i+di[k],j+dj[k],word,idx+1,used);
          } 
  
          //回溯
          // 因为只代表此次搜索过程中，该元素已访问过，当初始i j变化时，又开始了另一次搜索过程
          used[i][j] = false;
          return res;
  
      }
  ```

  

- 省时间省空间的做法

  ```java
      //省空间的做法，更改当前已访问过的元素，在结束此次搜索后还原
      public boolean exist(char[][] board, String word) {
          char[] words = word.toCharArray();
          for(int i = 0;i < board.length;i++){
              for(int j=0;j < board[0].length;j++){
                  boolean res = dfs(board,i,j,words,0);
                  if(res){
                      return true;
                  }
              }
          }
          return false;
      }
  
      //二维数组，以当前（i,j）节点为头开始递归，word所求词，idx为遍历到word的第几个词,
      public boolean dfs(char[][]board, int i, int j, char[] word,int idx){
          //如果当前字符也不相等，则直接返回（剪枝）+ 边界
          //边界条件没有想清楚
          if(i >= board.length || i < 0 || j>=board[0].length || j < 0 || board[i][j]!=word[idx]){
              return false;
          }
          
          //排除遍历过的节点
          // if(board[i][j]=='\0') return false;
  
          if(idx == word.length-1 ) return true;
  
          //将当前节点标记为已访问
          // char tmp = board[i][j];
          board[i][j]='\0';
  
          //定义上下左右四个方向 
          int[] di ={0,0,-1,1};
          int[] dj = {1,-1,0,0};
          
          //开使递归
          //只是针对此次搜索的res
          // boolean res = false;
          for(int k = 0; k<4 ;k++){
              if(dfs(board,i+di[k],j+dj[k],word,idx+1)) return true;  //再进行一次剪枝，直接返回
          } 
  
          //回溯
          // 因为只代表此次搜索过程中，该元素已访问过，当初始i j变化时，又开始了另一次搜索过程
          // board[i][j] = tmp;
          board[i][j] = word[idx];
          return false;
  
      }
  ```

- 三刷

  没有什么是画图解决不了的，如果有就是没画好

  ```java
      boolean[][] used;
      public boolean exist(char[][] board, String word) {
          char[] cs = word.toCharArray();
          // used = new boolean[board.length][board[0].length];
          for(int i=0;i<board.length;i++){
              for(int j=0;j<board[0].length;j++){
                  // used = new boolean[board.length][board[0].length];
                  //必须回溯，每次重新建的时候，当下一个节点超过1个可以走，则会导致状态错误
                  //[["A","B","C","E"],["S","F","E","S"],["A","D","E","E"]] "ABCESEEEFS"
                  boolean res = dfs(board,i,j,cs,0);
                  if(res) return true;
              }
          }
  
          return false;
      }
  
  
      public boolean dfs(char[][] board,int i,int j,char[] cs,int idx){
          int[] dx = {-1,1,0,0};
          int[] dy = {0,0,-1,1};
  
          //base case
          if(i<0 || i>= board.length || j<0 || j>=board[0].length || cs[idx]!=board[i][j] || used[i][j]){
              return false;
          }
  
          //出口
          if(idx==cs.length-1){
              return true;
          }
  
          used[i][j] = true;
  
          for(int k=0;k<4;k++){
              int x = i + dx[k];
              int y = j + dy[k];
              if(dfs(board,x,y,cs,idx+1)) return true;
          }
  
          used[i][j] = false;
  
          return false;
      }
  ```

- 太牛逼了 就改了一句话 直接超过百分之97%

  返回值能不或就别或

  ```java
      int[] dx = {1,-1,0,0};
      int[] dy = {0,0,1,-1};
      // boolean[][] visited;
      // LinkedList<Character> path = new LinkedList<>();
      public boolean exist(char[][] board, String word) {
          int m = board.length;
          int n = board[0].length;
          char[] cs = word.toCharArray();
  
          for(int i=0;i < m;i++){
              for(int j = 0;j < n;j++){
                  if(board[i][j]==cs[0] && recur(board,i,j,cs,0)) {
                          return true;
                  }
              }
          }
          return false;
      }
  
      public boolean recur(char[][] board,int i,int j, char[] cs,int idx){
          if(i < 0 || i >= board.length || j < 0 || j >= board[0].length){
              return false;
          }
  
          if(cs[idx]!=board[i][j] || board[i][j]=='\0') return false;
          if(idx==cs.length-1) return true;
  
          char tmp = board[i][j];
          board[i][j] = '\0';
  
          for(int k = 0;k < 4;k++){
              int x = i + dx[k];
              int y = j + dy[k];
              //这块不要放或，直接返回true，其他情况返回false
              if(recur(board,x,y,cs,idx+1)) return true;
          }
  
          board[i][j] = tmp;
          // return res;
          return false;
      }
  ```

  

#### * [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

**上下左右会在一个路径形成环的时候必须要used**

不需要path，因为这个求得是范围

- 暴力dfs + 剪枝 ，这个不用回溯，因为每个节点访问一次就可得出结论，并不是要路径什么的

  ```java
      public int movingCount(int m, int n, int k) {
          if(k==0) return 1;
  
          boolean[][] used = new boolean[m][n];
  
          return dfs(m,n,k,0,0,used);
          // return bitSum(k);
      }
  
      //i表示当前在i行，j列,标志位
      public int dfs(int m,int n,int k,int i,int j,boolean[][]used){
          if(i<0 || j<0 || i==m || j==n || bitSum(i)+bitSum(j) > k || used[i][j]){
              return 0;
          }
  
          used[i][j] = true;
  
          int[] di = {0,0,-1,1};
          int[] dj = {1,-1,0,0};
          int res = 0;
  
          res++;
          for(int idx = 0; idx < 4;idx++){
              res += dfs(m,n,k,i+di[idx],j+dj[idx],used); 
          }
  
          //不用回溯，每个节点遍历一遍即可
          // used[i][j] = false;
          return res;
      }
  
  
      public int bitSum(int num){
          int k = num;
          int res = 0;
          while(k!=0){
              res += k%10;
              k = k/10;
          }
          // int res = num%10 + num/10;
          return res;
      }
  ```

  ```java
  int sum = 0;
      int[] dx = {1,-1,0,0};
      int[] dy = {0,0,1,-1};
      public int movingCount(int m, int n, int k) {
          boolean[][] data = new boolean[m][n];
          recur(data,0,0,k);
          return sum;
      }
  
      public void recur(boolean[][] data,int i,int j,int k){
          if(i < 0 || i >= data.length || j < 0 || j >= data[0].length){
              return;
          }
  
          int s = digitSum(i) + digitSum(j);
          if(data[i][j] || s > k) return;
  
          data[i][j] = true;
          sum++;
  
          for(int m = 0; m < 4;m++ ){
              int x = i + dx[m];
              int y = j + dy[m];
  
              recur(data,x,y,k);
          }
      }
  
      public int digitSum(int m){
          int sum = 0;
          while(m!=0){
              sum = sum + m%10;
              m = m/10;
          }
          return sum;
      }
  ```
  
  



### - 回溯

感觉一部分用于优化深搜，免除浪费很多中间变量

#### *[46. 全排列](https://leetcode-cn.com/problems/permutations/)

> used数组
>
> 想清楚循环条件和减枝条件

- 优化前(太复杂了)

  ```java
      public List<List<Integer>> permute(int[] nums) {
          int len = nums.length;
          // 使用一个动态数组保存所有可能的全排列
          List<List<Integer>> res = new ArrayList<>();
          if (len == 0) {
              return res;
          }
  
          boolean[] used = new boolean[len];
          Deque<Integer> path = new ArrayDeque<>(len);
  
          dfs(nums, len, 0, path, used, res);
          return res;
      }
  
      private void dfs(int[] nums, int len, int depth,
                       Deque<Integer> path, boolean[] used,
                       List<List<Integer>> res) {
          if (depth == len) {
              //变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表,会使res为空
              res.add(new ArrayList<>(path));
              return;
          }
  
          for (int i = 0; i < len; i++) {
              if (!used[i]) {
                  path.addLast(nums[i]);
                  used[i] = true;
  
                  System.out.println("  递归之前 => " + path);
                  dfs(nums, len, depth + 1, path, used, res);
  
                  used[i] = false;
                  path.removeLast();
                  System.out.println("递归之后 => " + path);
              }
          }
      }
  ```

- 好理解的上个版本

  ```java
      public List<List<Integer>> permute(int[] nums) {
          List<List<Integer>> res = new ArrayList<>();
          List<Integer> path = new ArrayList<>();
          dfs(nums,path,res);
          return res;
      }
  
      public void dfs(int[] nums,List<Integer> path,List<List<Integer>> res){
          //叶子结点返回
          if(path.size()==nums.length){
              res.add(new ArrayList(path));
              return;
          }
  
          //控制分支，宽度
          for(int i=0;i <nums.length; i++){
              //操作
              if(path.contains(nums[i])){
                  continue;
              }
              path.add(nums[i]);
  
              //递归
              dfs(nums,path,res);
  
              //状态重置
              path.remove(path.size()-1);
          }
      }
  ```

- 创建新的中间变量则无需回溯

  每一次尝试都「复制」，则不需要回溯

  如果在每一个 非叶子结点 分支的尝试，都创建 新的变量 表示状态，那么
      在回到上一层结点的时候不需要「回溯」；
      在递归终止的时候也不需要做拷贝。
      这样的做法虽然可以得到解，但也会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。

  ```java
  public List<List<Integer>> permute(int[] nums) {
          // 首先是特判
          int len = nums.length;
          // 使用一个动态数组保存所有可能的全排列
          List<List<Integer>> res = new ArrayList<>();
  
          if (len == 0) {
              return res;
          }
  
          boolean[] used = new boolean[len];
          List<Integer> path = new ArrayList<>();
  
          dfs(nums, len, 0, path, used, res);
          return res;
      }
  
      private void dfs(int[] nums, int len, int depth,
                       List<Integer> path, boolean[] used,
                       List<List<Integer>> res) {
          if (depth == len) {
              // 3、不用拷贝，因为每一层传递下来的 path 变量都是新建的
              res.add(path);
              return;
          }
  
          for (int i = 0; i < len; i++) {
              if (!used[i]) {
                  // 1、每一次尝试都创建新的变量表示当前的"状态"
                  List<Integer> newPath = new ArrayList<>(path);
                  newPath.add(nums[i]);
  				
                  // 1、每一次尝试都创建新的变量表示当前的"状态"
                  boolean[] newUsed = new boolean[len];
                  System.arraycopy(used, 0, newUsed, 0, len);
                  newUsed[i] = true;
  
                  dfs(nums, len, depth + 1, newPath, newUsed, res);
                  // 2、无需回溯
              }
          }
      }
  ```

这就好比我们在实验室里做「对比实验」，每一个步骤的尝试都要保证使用的材料是一样的。我们有两种办法：

【全局】每做完一种尝试，都把实验材料恢复成做上一个实验之前的样子，只有这样做出的对比才有意义；

【局部】每一次尝试都使用同样的新的材料做实验

- 优化后(交换)

  ```java
      //相当于填nums.length长的数，不重不漏
      //注意刚开始为空
  
      //调用函数
      List<List<Integer>> res;
      public List<List<Integer>> permute(int[] nums) {
          res = new ArrayList<List<Integer>>();
          List<Integer> tmp = new ArrayList<>();
          for(int num:nums){
              tmp.add(num);
          }
          dfs(nums.length,0,tmp);
          return res;
      }
  
      //总共要填的数的数目，当前填到哪个数的下标，这一次的结果
      public void dfs(int length,int index, List<Integer> tmp){
          if(index == length){
              res.add(new ArrayList<Integer>(tmp));
              return;
          }
          //在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现
          //在当前位置，前面的数都排列好了，后面的数没有排列
          //在当前位置下，选定下一个数有多少种可能，就和二叉树一样，需要遍历左右孩子一样
          for(int i = index;i < length;i++){
              Collections.swap(tmp, index,i);
              dfs(length,index+1,tmp); //继续递归填下一个数
              Collections.swap(tmp, index,i); //状态重置
          }
      }
  ```

- 套路

  ```java
   LinkedList<Integer> path = new LinkedList<>();
      List<List<Integer>> res = new LinkedList<>();
      boolean[] visited;
  
      public List<List<Integer>> permute(int[] nums) {
          visited = new boolean[nums.length];
          
          dfs(nums,0);
          return res;    
      }
  
      public void dfs(int[]nums,int s){
          if(path.size()==nums.length){
              res.add(new LinkedList(path));
              return;
          }
  
          for(int i=0;i<nums.length;i++){
              if(visited[i]) continue;
  
              visited[i] = true; //标准此条路径中不能再有i
              path.addLast(nums[i]);
  
              dfs(nums,i+1);
  
              path.removeLast();
              visited[i] = false;
          }
      }
  ```

  

#### *[剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)（注意是包含可重复的字符）

> 去重要保持相对位置不变
>
> if(used[i] || (i>0 &&cs[i-1]==cs[i] && !used[i-1])) continue;

平时used数组的作用是代表当前节点我是否选择过了，防止对同一位置上的节点重复选择

并不表示不同位置相同节点上的重复，当含有重复字符时，需要对结果去重

- 费空间的做法

```java
public String[] permutation(String s) {
        if (s==null) return new String[0];
        char[] cs = s.toCharArray();
        StringBuilder path = new StringBuilder();
        // List<String> res = new ArrayList<>();
        HashSet<String> res = new HashSet<>(); //最后结果去重
        boolean[] flag = new boolean[cs.length];  //代表当前节点我是否选择过了，防止对同一位置上的节点重复选择
        //重复，boolean类型的变量，默认是false
        //并不表示不同位置相同节点上的重复
        
        dfs(cs,path,res,flag);

        String[] ans = new String[res.size()];
        int idx = 0;
        for (String str : res) ans[idx++] = str;
        return ans;
    }

    public void dfs(char[]cs, StringBuilder path,HashSet<String> res,boolean[] flag){
        if(path.length()==cs.length){
            res.add(new String(path.toString()));
            return;
        }

        for(int i=0;i < cs.length;i++){
            //不能这么判断，如果里面有重复的字符的就会报错，且会使path.length()==cs.length长度永不相等
            //题目要求可以重复
            //path.toString().contains((String.valueOf(cs[i])))
            if(flag[i])
                continue;
            path.append(cs[i]);
            flag[i] = true;
            dfs(cs,path,res,flag);
            path.deleteCharAt(path.length()-1);
            flag[i] = false;
        }
    }

```

- 交换不费空间

```java
    //采用交换的方式
    public String[] permutation(String s) {
        if (s==null) return new String[0];
        char[] cs = s.toCharArray();
        HashSet<String> res = new HashSet<>(); //最后结果去重
        
        dfs(cs,0,res);

        String[] ans = new String[res.size()];
        int idx = 0;
        for (String str : res) ans[idx++] = str;
        return ans;
    }

    public void dfs(char[]cs, int index, HashSet<String> res){
        //注意此处length要减一
        if(index == cs.length-1){
            res.add(String.valueOf(cs));
            return;
        }

        for(int i = index;i < cs.length;i++){
            swap(cs,i,index);
            dfs(cs,index+1,res);
            swap(cs,i,index);
        }
    }

    public void swap(char[]cs,int i,int j){
        char tmp = cs[i];
        cs[i] = cs[j];
        cs[j] = tmp;
    }
```

- 如果是不包含重复字符可以这么写

```java
    // 感觉此题只能对结果去重了！不是
    //采用交换的方式+去重，不可行，如遇到重复，index无法到达
    public String[] permutation(String s) {
        if (s==null) return new String[0];
        char[] cs = s.toCharArray();
        List<String> res = new ArrayList<>(); 
        //保证没有重复的字符
        //如果只有小写的字母可以写成，boolean[] used =new boolean[26];
        HashSet<Character> used = new HashSet<>(); 
        
        dfs(cs,0,res,used);

        String[] ans = new String[res.size()];
        int idx = 0;
        for (String str : res) ans[idx++] = str;
        return ans;
    }

    public void dfs(char[]cs, int index, List<String> res,HashSet<Character> used){
        if(index == cs.length){
            res.add(String.valueOf(cs));
            return;
        }

        for(int i = index;i < cs.length;i++){
            if(used.contains(cs[i])){
                continue;
            }
            swap(cs,i,index);
            used.add(cs[i]);
            dfs(cs,index+1,res,used);
            swap(cs,i,index);
            used.remove(cs[i]);
        }
    }

    public void swap(char[]cs,int i,int j){
        char tmp = cs[i];
        cs[i] = cs[j];
        cs[j] = tmp;
    }
```

- 最优解：去重

   //交换是为了保证对当前位置index进行选择，不否空间
   

  //加hashset，是为了保证有重复字符是不进行多余的分支

```java

    //修改下剪枝条件
    //交换是为了保证对当前位置index，不重复
    //加hashset，是为了保证有重复字符是不进行多余的分支
    public String[] permutation(String s) {
        if (s==null) return new String[0];
        char[] cs = s.toCharArray();
        List<String> res = new ArrayList<>(); 
        //保证没有重复的字符
        //如果只有小写的字母可以写成，boolean[] used =new boolean[26];
        
        dfs(cs,0,res);

        String[] ans = new String[res.size()];
        int idx = 0;
        for (String str : res) ans[idx++] = str;
        return ans;
    }

    public void dfs(char[]cs, int index, List<String> res){
        if(index == cs.length-1){
            res.add(String.valueOf(cs));
            return;
        }

        //在此层时，需要判断重复，重复则不给分支（不交换）
        HashSet<Character> used = new HashSet<>();
        for(int i = index;i < cs.length;i++){
            if(used.contains(cs[i])){
                continue;
            }
            used.add(cs[i]);
            swap(cs,i,index);
            dfs(cs,index+1,res);
            swap(cs,i,index);
            // used.remove(cs[i]);
        }
    }

    public void swap(char[]cs,int i,int j){
        char tmp = cs[i];
        cs[i] = cs[j];
        cs[j] = tmp;
    }
```

- 套路

  path:记录当前路径的序列

  used：记录当前路径的节点不会重复选择，比如是1，则不会再在当前路径选1

```java
    LinkedList<String> res = new LinkedList<>();
    StringBuilder path = new StringBuilder();
    boolean[] used;
    public String[] permutation(String s) {
        used = new boolean[s.length()];
        char[] cs = s.toCharArray();
        Arrays.sort(cs);
        dfs(cs,0);

        String[] ans = new String[res.size()];
        for(int i = 0;i<res.size();i++){
            ans[i] = res.get(i);
        }

        return ans;
        
    }

    public void dfs(char[] cs,int s){
        if(path.length()==cs.length){
            res.add(new String(path.toString()));
            return;
        }

        for(int i=0;i < cs.length;i++){
            //做选择，可能会有重复字符
            if(used[i] || (i>0 && cs[i-1]==cs[i] && used[i-1])) continue;

            used[i]=true;
            path.append(cs[i]);

            dfs(cs,i+1);

            used[i]=false;
            path.deleteCharAt(path.length()-1);
        }
    }
```

#### *[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

>   //这里每次只对应两种选择，不用for循环
>           //用for循环是因为之前全排列或者组合后的分枝数不是固定不变的

```java
    int res;
    int sum;
    public int findTargetSumWays(int[] nums, int target) {
        if(nums.length==0) return 0;
        res = 0;
        sum = 0;
        dfs(nums,target,0,sum);
        return res;
    }

    public void dfs(int[] nums, int target,int i,int sum){
        //base case
        if(nums.length==i){
            if(target==sum){
                res++;
            }
            return;
        }
        //这里每次只对应两种选择，不用for循环
        //用for循环是因为之前全排列或者组合后的分枝数不是固定不变的
        sum += nums[i];
        dfs(nums,target,i+1,sum);
        sum -= nums[i];
        sum -= nums[i];
        dfs(nums,target,i+1,sum);
        sum += nums[i];
    }
```



### - 动态规划

#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

- 递归法：
  原理： 把 f(n)问题的计算拆分成 f(n-1)和 f(n-2)两个子问题的计算，并递归，以f(0) 和 f(1)为终止条件。
  缺点： 大量重复的递归计算，例如 f(n) 和 f(n - 1)两者向下递归需要 各自计算 f(n - 2)的值。

  ```java
      public int fib(int n) {
          if(n<=1) return n;
          return fib(n-1)+fib(n-2);
      }
  ```

  

- 记忆化递归法：
  原理： 在递归法的基础上，新建一个长度为 n 的数组，用于在递归时存储 f(0)至 f(n)的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。
  缺点： 记忆化存储需要使用 O(N) 的额外空间。

- 动态规划：
  原理： 以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1) 为转移方程。
  从计算效率、空间复杂度上看，动态规划是本题的最佳解法。

  ```java
      //动态优化
      public int fib(int n){
          if(n < 2) return n;
  
          int a = 0;
          int b = 1;
          int sum = 0;
          for(int i=2; i<=n; i++){
              sum = (a + b)%1000000007;
              a = b ;
              b = sum;
          }
          return sum;
      }
  ```

#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

- 动态规划（未优化）

  ```java
      public int numWays(int n) {
          if(n==0) return 1;
          int[] dp = new int[n+1];
          dp[0] = 1;
          dp[1] = 1;
          for(int i=2;i<=n;i++){
              dp[i] = (dp[i-1] + dp[i-2])%1000000007;
          }
          System.out.println(Arrays.toString(dp));
          return dp[n];
      }
  ```
  
  
  
- 动态规划（优化）

  ```java
      //动态优化
      public int numWays(int n){
          if(n == 0 || n == 1) {
              return 1;
          }
  
          int a = 1;
          int b = 1;
          int sum = 0;
          for(int i=2; i <= n; i++){
              sum = (a + b)%1000000007;
              a = b;
              b = sum;
          }
  
          return sum;
      }
  ```

- 深搜

  ```java
  
      int count;
      public int numWays(int n) {
          count = 0;
          dfs(n);
          return count % 1000000007;
      }
      
      public void dfs(int n){
          if(n == 0 || n==1) {
              count += 1;
              return;
          }
          if(n == 2) {
              count += 2;
              return;
          } 
  
          dfs(n-1);
          dfs(n-2);
      }
  ```

- 递归

  ```java
      //和数列一样   
      public int numWays(int n){
          if(n == 0 || n==1) {
              return 1;
          }
          if(n == 2) {
              return 2;
          } 
  
          return (numWays(n-1) + numWays(n-2))%1000000007;
      }
  ```

#### *[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

>   //已知n-1时的情况，递推到n的情况
>   //返回值为删除后的第一个数字
>
>   ```java
>       //返回值：f(n-1)，删除1个数后，返回在下一个起始元素
>       //结果：f(1)
>       public int lastRemaining(int n, int m) {
>           if(n==1) return 0;
>   
>           //已知n-1,求n-2
>           //n-1表示删除一个数以后的起始元素
>           int x = lastRemaining(n-1,m);
>   
>           return (x + m)%n;
>       }
>   ```
>
>   

- 暴力模拟

  ```java
      //方法一，模拟
      //LinkedList会超时,ArrayList勉强可以通过
      public int lastRemaining(int n, int m) {
          ArrayList<Integer> list =  new ArrayList<>();
          for(int i=0; i<n ;i++){
              list.add(i);
          }
  
          int idx = 0;
          while(n > 1){
              idx = (idx + m - 1)%n;
              list.remove(idx);
              n--;
          }
          return list.get(0);
      }
  ```

  

- 递归

  ```java
  //已知n-1时的情况，递推到n的情况
      //返回值为删除后的第一个数字的下标
      public int lastRemaining(int n, int m) {
          //当n==1时，规模只有1，那么数字必然是最初始的0
          if(n==1) return 0;
  
          int x  = lastRemaining(n-1,m);
          
          return (x + m) % n;
      }
  ```

  

  ```java
      //约瑟夫环
      //递归
      public int lastRemaining(int n, int m) {
          if(n==1) return 0; //base
  
          //考虑x已知的情况的下,n-1个环所留下的数
          int x = lastRemaining(n-1,m);
  
          return (x + m)%n;
  
      }
  ```

  

- 动态规划

  ![](appendix\y1.png)

状态转移

![](appendix\y2.png)

```java
    //迭代
    //动态优化
    public int lastRemaining(int n, int m) {
        int x = 0;
        for (int i = 2; i <= n; i++) {
            x = (x + m) % i;
        }
        return x;
    }
```

#### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

- 暴力解法

  ```java
  //计算以0为开头的最大和
  //计算以....i为开头的最大和【从i到j】
  //最后求这些和里的最大和
  public int maxSubArray(int[] nums) {
          int max = Integer.MIN_VALUE;
          for(int i=0;i<nums.length;i++){
              int sum = 0;
              for(int j = i;j<nums.length;j++){
                  sum += nums[j];
                  if(sum > max){
                      max = sum;
                  } 
              }
          }
          return max;
      }
  ```

- 动态规划1:

  如果我们每次能在最右侧得到该行的最大值，然后再求这么多最大值的最大值，岂不就能在O(n)内计算出结果？		
  sum(0,0) 																 dp[0]
  sum(0,1) 	sum(1,1) 											 dp[1]
  sum(0,2) 	sum(1,2) 	sum(2,2) 						dp[2]
  sum(0,3) 	sum(1,3) 	sum(2,3) 	sum(3,3) 	dp[3]
  ..... 	... 	... 	.... 												   dp[j]

  表格每一行的子数组都是以某一值结尾，所以我们设dp[j]为以j结尾的子数组的最大值，如上面表格所示。dp[j]的最大值就是我们要的结果。

  （以某个数作为结尾，意思就是这个数一定会加上去，那么要看的就是这个数前面的部分要不要加上去。大于零就加，小于零就舍弃。）

  ![](appendix\42.png)

  ```java
      //动态优化
      public int maxSubArray(int[] nums) {
          if(nums.length==0) return Integer.MIN_VALUE;
          if(nums.length==1) return nums[0];
  
          int[] dp = new int[nums.length];
          dp[0] = nums[0];
          int max = dp[0];  //此处要设成dp[0],否则会没有检查到dp[0]
          for(int i=1; i< nums.length;i++){
              dp[i] = Math.max(dp[i-1],0) + nums[i];
              max = Math.max(dp[i],max);
          }
          return max;
      }
  ```

- 优化动态规划（原地存储）

  将dp的值存入原数组

  ```java
      //优化使用空间，原地存储
      public int maxSubArray(int[] nums) {
          if(nums.length==0) return Integer.MIN_VALUE;
          if(nums.length==1) return nums[0];
          
          int res = nums[0];
          //将当前dp的值存入原数组
          for(int i=1;i<nums.length;i++){
              nums[i] = Math.max(nums[i-1],0) + nums[i];
              res = Math.max(res,nums[i]);
          }
          return res;
      }
  ```

- 优化动态规划空间（滑动数组）

  ```java
      //使用滑动数组
      public int maxSubArray(int[] nums) {
          if(nums.length==0) return Integer.MIN_VALUE;
          if(nums.length==1) return nums[0];
  
          int dp = nums[0];
          int max = nums[0];
          for(int i=1;i<nums.length;i++){
              //以某个数作为结尾，意思就是这个数一定会加上去，那么要看的就是这个数前面的部分要不要加上去。
              dp = Math.max(dp + nums[i],nums[i]);
              max = Math.max(max,dp);
          }
  
          return max;
      }
  ```

#### [剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

- 动态规划

  ```java
      //动态规划
      //状态定义：dp[i],前i日能获得的最大利润，隐含是在第i天卖掉获得的利润和之前的利润的大小关系
      //状态转移方程：dp[i] = max(dp[i-1],prices[i]-min(prices[0:i-1]))
      //初始状态：dp[0] = 0
      //结果：dp[len-1]
      //多开辟了一个空间
      public int maxProfit(int[] prices) {
          if(prices==null || prices.length < 2) return 0;
          
          int len = prices.length;
          int[] dp = new int[len+1];
          dp[0] = 0;
          int cost = Integer.MAX_VALUE;
          for(int i = 1;i <= len;i++ ){
              dp[i] = Math.max(dp[i-1],prices[i-1]-cost);
              cost = Math.min(cost,prices[i-1]);
          } 
  
          return dp[len];
      }
  ```

  

- 动态规划空间优化

  ```java
  
      //优化空间
      // 由于 dp[i]dp[i]dp[i] 只与 dp[i−1] , prices[i] , cost相关，因此可使用一个变量（记为利润 profit ）代替dp列表
      public int maxProfit(int[] prices) {
          if(prices==null || prices.length < 2) return 0;
          
          int profit = 0;
          int cost = Integer.MAX_VALUE;
          for(int price:prices){
              profit = Math.max(profit,price-cost);
              cost = Math.min(cost,price);
          }
          return profit;
      }
  ```

#### [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

丑数只包含因子 2,3,5，因此有 “丑数 = 某较小丑数 × 某因子” ！！！（注意是只包含）

- 错误解法：不理解丑数的性质

  ```java
      public int nthUglyNumber(int n) {
          if(n==0) return 0;
  
          int count  = 1;
          int i = 2;
          for(; count <= n-1 ; i++ ){
              //质因数不能这么判断 14不是丑数 他的质因数除了2还有7
              if( i%2==0 || i%3==0 || i%5==0){
                  count++;
                  // System.out.println("i:" + i +"\tcount:"+count);
              }
          }
          return i-1;
      }
  ```

- 动态优化:

  n2，n3, n5设计的比较巧妙

  ```java
      //利用丑数的性质
      //丑数只包含因子 2,3,5，因此有 “丑数 = 某较小丑数 × 某因子” 
      //状态：dp[i]，代表第i+1个丑数，因为1为丑数
      //状态转移方程：
          // dp[i] = min(dp[a]*2,dp[b]*3,dp[c]*5)
          // 其中，a,b,c满足以下条件
          // dp[a]×2>dp[i−1]≥dp[a−1]×2
          // dp[b]×3>dp[i−1]≥dp[b−1]×3
          // dp[c]×5>dp[i−1]≥dp[c−1]×5
          // a,b,c可以理解为，分别对应的2,3,5的某较小丑数的最新的位置
      //初始值：dp[0]  = 1;
      //结果：dp[n-1]
      public int nthUglyNumber(int n) {
          if(n==0) return 0;
  
          int[] dp = new int[n];
          dp[0] = 1;
          int n2 = 0,n3 = 0, n5=0;
          for(int i = 1;i < n;i++){
              dp[i] = Math.min(Math.min(dp[n2]*2,dp[n3]*3),dp[n5]*5);
              if(dp[i]==dp[n2]*2) n2++;
              if(dp[i]==dp[n3]*3) n3++;
              if(dp[i]==dp[n5]*5) n5++;
          }
          return dp[n-1];
      }
  ```

-   三刷

    ```java
        //dp[i]表示，第i个丑数
        //dp[i] = Math.min(Math.min(2*dp[i2],3*dp[i3]),5*dp[i5]);
        //序列中的数组求，而不是在自然数序列中求
        //结果dp[n-1]
    
        public int nthUglyNumber(int n) {
            int[] dp = new int[n];
            dp[0] = 1;
            int i2 = 0,i3 = 0,i5 = 0;
            for(int i = 1;i < n;i++){
                dp[i] = Math.min(Math.min(2*dp[i2],3*dp[i3]),5*dp[i5]);
                System.out.print(dp[i]+" ");
                if(dp[i]==2*dp[i2]) i2++;
                if(dp[i]==3*dp[i3]) i3++;
                if(dp[i]==5*dp[i5]) i5++;
            }
            return dp[n-1];
        }
    ```

    



#### **[剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

- 状态要想清楚，最后dp[n]一般就是答案，可以从这推

  明确状态：绳长i

  明确选择：1~i

  ```java
      //动态规划，数学推导和贪心还是暂时放弃吧
      //状态：dp[i]表示，长度为i的绳子剪成m段的最大长度
      //状态转移方程：
          //不剪：dp[i]
          //剪：
              //剪第一段，剪掉j的长度，j*dp[i-j]  (其中j要大于2,否则没有意义)
              //剪完第一段后不剪了，j*(i-j)
      //初始值：dp[2] = 1，j =2;
      //结果：dp[n]
      public int cuttingRope(int n) {
          //初始值
          int[] dp  = new int[n+1];
          dp[2] = 1;
  
          //表示绳子的长度
          for(int i = 3;i <= n; i++){
              //剪第一段的长度
              for(int j = 2; j < i ;j++){
                  dp[i] = Math.max(Math.max(j*dp[i-j],j*(i-j)),dp[i]);
              }
          }
  
          return dp[n];
      }
  ```

- 小优化

  ```java
      //动态规划，数学推导和贪心还是暂时放弃吧
      //状态：dp[i]表示，长度为i的绳子剪成m段的最大长度
      //状态转移方程：
          //不剪：dp[i]
          //剪：
              //剪第一段，剪掉j的长度，j*dp[i-j]  (其中j要大于2,否则没有意义)
              //剪完第一段后不剪了，j*(i-j)
      // 初始值：dp[2] = 1，j =2;
      // 结果：dp[n]
      public int cuttingRope(int n) {
          //初始值
          int[] dp  = new int[n+1];
          dp[2] = 1;
  
          for(int i = 3;i <= n;i++){
              
              for(int j = 1;j<=i/2;j++){
                  dp[i] = Math.max(Math.max(j*(i-j),j*dp[i-j]),dp[i]);
              }
          }
          return dp[n];
      }
  ```

  

#### [剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

- 这题要考虑大数

  使用java的BigInteger类

  >   import java.math.BigInteger;
  >
  >   //将整形转为数字
  >
  >   BigInteger.valueOf(1)
  >
  >   //求两者中的最大值
  >
  >   BigInteger.valueOf(j * (i - j)).max(x)
  >
  >   //求两者的乘积
  >
  >   BigInteger.valueOf(j * (i - j)).multiply(x)
  >
  >   //求余
  >
  >   dp[n].mod(BigInteger.valueOf(1000000007))
  >
  >   //bigInteger转为int
  >
  >   dp[n].mod(BigInteger.valueOf(1000000007)).intValue()
  
  ```java
  
  import java.math.BigInteger;
  class Solution {
      //动态规划，数学推导和贪心还是暂时放弃吧
      //状态：dp[i]表示，长度为i的绳子剪成m段的最大长度
      //状态转移方程：
          //不剪：dp[i]
          //剪：
              //剪第一段，剪掉j的长度，j*dp[i-j]  (其中j要大于2,否则没有意义)
              //剪完第一段后不剪了，j*(i-j)
      //初始值：dp[2] = 1，j =2;
      //结果：dp[n]
  
      //大数越界： 剪绳子问题（不考虑取余）最终的结果是以3^a指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。
      public int cuttingRope(int n) {
          //初始值
          BigInteger[] dp = new BigInteger[n+1];
          //都得填充，否则不给计算
          Arrays.fill(dp, BigInteger.valueOf(1));
          // dp[2] = BigInteger.valueOf(1);
          //是dp[i]会越界，而不是仅仅答案会越界，所以不能只对答案进行处理
  
          //表示绳子的长度
          for(int i = 3;i <= n; i++){
              //剪第一段的长度
              for(int j = 2; j < i ;j++){
                  dp[i] = dp[i].max(BigInteger.valueOf(j * (i - j))).max(dp[i - j].multiply(BigInteger.valueOf(j)));
              }
          }
  
          return dp[n].mod(BigInteger.valueOf(1000000007)).intValue();
          }
  }
  ```

#### **[剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

>   dp空间的和的大小写错了
>
>   dp的初始化写错了，应该是1-6
>
>   且要注意使得j-k有效，则要大于等于i-1个骰子的最小值
>
>   最后的结果是n个筛子，所以不求和，答案是dp[n]/6^n
>
>   
>
>   状态和选择：
>
>   状态是和
>
>   选择是每个筛子的点数

- 思考状态和选择

  ```java
      //动态规划
      //p(k) = k出现的次数/总次数，总次数 = 6^n,所以现在要求k（和）出现的次数
      //考虑最终情况：dp[n][j],掷完n个骰子后，各个点数和出现的次数
          //假设已知 n−1个骰子的解 f(n−1) ，此时添加一枚骰子，求 n 个骰子的点数和为 x的概率 f(n,x) 
      //状态：dp[i][j],掷完i个骰子后，各个点数和j出现的次数
      //状态转移方程：
          // dp[n][j]:
          // for(int i = 1;i <= 6;i++){
          //     dp[n][j] += dp[n-1][j-i]
          // }
      //初始状态：
          // dp[1][j]:
          // for(int j = 1;i <= 6;i++){
          //     dp[1][j] = 1;
          // }
      //结果：dp[n]/6^n
      public double[] dicesProbability(int n) {
          //申请dp空间
          int[][] dp = new int[n+1][6*n+1];
          //初始化
          for(int i = 1;i <= 6; i++ ){
              dp[1][i] = 1;
          }
  
          //从掷两个骰子开始
          for(int i=2;i <= n;i++){
              //可能的和,最小为i,最大为i*6
              for(int j=i;j<=i*6;j++){
                  //掷完i个骰子后，各个点数和j出现的次数，把规模放小
                  //且要注意使得j-k有效，则要大于等于i-1个骰子的最小值
                  for(int k = 1;k<=6 && j >= i+k-1;k++){
                      dp[i][j] += dp[i-1][j-k];
                  }
              }
          }
  
          //这个长度是：最大值减最小值+1得到的
          double[] ans = new double[6*n-n+1];
          for(int i = n;i<=6*n;i++){
              ans[i-n] = (double)dp[n][i]/(Math.pow(6,n));
          }
          return ans;
      }
  ```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

- 动态规划（不优化空间）

  ```java
      // 状态：dp[i]表示偷到i家时能获取的最大数现金
      // 状态转移方程：dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i])
      // 初始值：dp[0] = nums[0],dp[1] = Math.max(nums[0],num[1])
      // 结果：dp[n-1]
      //不优化空间的普通做法
      public int rob(int[] nums) {
          if(nums.length < 2) return nums[0];
  
          int[] dp = new int[nums.length];
          dp[0] = nums[0];
          dp[1] = Math.max(nums[0],nums[1]);
          for(int i = 2;i < nums.length;i++){
              dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);
          }
          return dp[nums.length-1];
      }
  ```

  

- 优化空间

  ```java
      //优化空间的普通做法
      public int rob(int[] nums) {
          if(nums.length < 2) return nums[0];
  
          int a = nums[0];
          int b = Math.max(nums[0],nums[1]);
          int c = Math.max(a,b);
          for(int i = 2;i < nums.length;i++){
              c = Math.max(b,a+nums[i]);
              a = b;
              b = c;
              // System.out.println("b:"+ b+" \tc:"+ c);
          }
          // return b;
          return c;
      }
  
  //
  public int rob(int[] nums) {
          if(nums.length==0) return 0;
          if(nums.length==1) return nums[0];
          if(nums.length <3) return Math.max(nums[0],nums[1]);
          
          //状态：偷到i家时最大金额
          //初始化
          int a = nums[0];
          int b = Math.max(nums[0],nums[1]);
          int max = 0;
          for(int i=2;i<nums.length;i++){
              max = Math.max(a+nums[i],b);
              a = b;
              b = max;
          }
          return max;
  
      }
  ```

#### [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

>   注意结果是sum(dp)，因为状态是：以当前i为结尾的子序列的 数目

- 动态规划

  
  
  ```java
      // 状态：dp[i] 表示当前到i的子序列的数目
      // 状态转移方程：
      //     if(nums[i]-nums[i-1]==nums[i-1]-num[i-2])
      //         dp[i] = dp[i-1] + 1;
      // 初始值：
      //     dp[0] = 0, dp[1] = 0
      // 结果：sum (dp[i])
      public int numberOfArithmeticSlices(int[] nums) {
          if(nums.length < 3) return 0;
          int[] dp = new int[nums.length];
          dp[0] = 0;
          dp[1] = 0;
  
          for(int i = 2;i < nums.length;i++){
              if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])
              dp[i] = dp[i-1] + 1;
          }
  
          return Arrays.stream(dp).sum();
      }
  ```



#### * [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

- 递归(后序)：错误解法，尽管答案没错

  ```java
      public int maxValue(int[][] grid) {
  
          return dfs(grid,0,0);
      }
  
      public int dfs(int[][] grid,int i,int j){
          if(i == grid.length || j == grid[0].length){
              return 0;
          }
          
          //此处少了边界条件的判断
          //因为此处返回值是0，即使在其他边界出来了，最后结果也只会加0，对结果不产生影响,因为求得最大值
          //如果求最小值，则应return Integer.MAX_VALUE,加到结果里就会产生影响
  
          int r = dfs(grid,i,j+1);
          int b = dfs(grid,i+1,j);
  
          return Math.max(r,b) + grid[i][j];
      }
  ```

- 正确的递归

  ```java
      //正常的递归应该是
      //递归会超时（不是回溯）(后序遍历)
      public int maxValue(int[][] grid) {
          return dfs(grid,0,0);
      }
  
      public int dfs(int[][] grid,int i,int j){
          if(i == grid.length || j == grid[0].length){
              return 0;
          }
  
          //base case, 最右下角又是边界，又是要拿出来单独判
          if(i == grid.length-1 && j == grid[0].length-1){
              return grid[i][j];
          }
  
          int r = dfs(grid,i,j+1);
          int b = dfs(grid,i+1,j);
  
          return Math.max(r,b) + grid[i][j];
      }
  ```

- 在后序递归的基础上+记忆会比dp还快

  ```java
      //剪枝+状态记录
      private int m;
      private int n;
      private int[][]memo;
  
      public int maxValue(int[][] grid) {
          this.m = grid.length;
          this.n = grid[0].length;
          this.memo = new int[m][n];
          for(int i= 0;i < m;i++){
              Arrays.fill(memo[i],-1);
          }
  
          return dfs_me(grid,0,0);
      }
  
      public int dfs_me(int[][] grid,int i, int j){
          if(i==m || j==n ) return 0;
  
          //剪枝+状态记录
          if(memo[i][j] > -1) return memo[i][j];
  
          if(i==m-1 && j==n-1) return grid[i][j];
          
          int r = dfs_me(grid,i,j+1);
          int b = dfs_me(grid,i+1,j);
  
          memo[i][j] = Math.max(r,b) + grid[i][j];
          return memo[i][j];
      }
  ```

- 深搜

  ```java
      //暴力递归（dfs）
      private int[][] grid;
      private int m;
      private int n;
      private int max = Integer.MIN_VALUE;
  
      public int maxValue (int[][] grid) {
          if (grid == null) return 0;
          if (grid.length == 0) return 0;
          this.grid = grid;
          this.m = grid.length;
          this.n = grid[0].length;
          int sum = 0;
          dfs(0,0,sum);
          return max;
      }
  
      public void dfs (int i,int j,int sum) {
          //base case:已到达
          if (i == m - 1 && j == n - 1) {
              sum += grid[i][j];
              max = Math.max(max,sum);
              return;
          }
          //越界
          if (i == m || j == n) {
              return;
          }
          sum += grid[i][j];
          dfs (i + 1,j,sum);
          dfs (i,j + 1,sum);
      }
  ```

- 暴力递归

  ```java
      //暴力递归
      public int maxValue (int[][] grid) {
          return path(grid,0,0);
      }
  
      //参数和返回值代表：当前i,j位置上的礼物最大值，向更大的位置看（更进一步）
      public int path(int[][]grid, int i,int j){
          if(i==grid.length-1 && j==grid[0].length-1) return grid[i][j];
          else if(i==grid.length-1) return grid[i][j] + path(grid,i,j+1);
          else if(j==grid[0].length-1) return grid[i][j] + path(grid,i+1,j);
  
          return grid[i][j] + Math.max(path(grid,i,j+1),path(grid,i+1,j));
      }
  ```

  

- 动态规划

  ![](appendix\礼物.png)

  为了弱化边界条件，可以多增一行和一列

  空间可以使用原地

  ```java
      //动态规划
      //状态：dp[i][j]表示0~i-1,0~j-1,的最大礼物数
      //状态转移方程：dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1]
      //注意此处是多开了一行一列空间，弱化边界条件，使转移方程更加简洁
      //初始状态：dp[1][1]= grid[0][0]
      //结果返回dp[n][m]
      public int maxValue(int[][] grid) {
          int n = grid.length;
          int m = grid[0].length;
  
          int[][] dp = new int[n+1][m+1];
  
          for(int i=1;i <= n;i++){
              for(int j=1;j<=m;j++){
                  dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1];
              }
          }
          return dp[n][m];
      }
  ```

- 不开辟空间

  ```java
  //不开辟空间
      public int maxValue(int[][] grid) {
          //开辟空间，弱化边界条件
          //dp[i][j]表示，0-i，0-j的礼物最大值
          int[][] dp = new int[grid.length][grid[0].length];
          dp[0][0] = grid[0][0];
          for(int i=0;i<grid.length;i++){
              for(int j = 0;j<grid[0].length;j++){
                  if(i==0 && j>0){
                      dp[i][j] = dp[i][j-1] + grid[i][j];
                  }
                  else if(j==0 && i>0){
                      dp[i][j] = dp[i-1][j] + grid[i][j];
                  }
                  else if(i!=0 && j!=0){
                      dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+grid[i][j];
                  }
                  // for(int[] x:dp){
                  //     System.out.println(Arrays.toString(x));
                  // }
                  // System.out.println();
              }
          }
          return dp[grid.length-1][grid[0].length-1];
      }
  ```
  
  
  
- 递归（dfs）

  **因为此题只能往下和往右走，所以必然不会走回头路，形成环，所以不用used数组**

  **因为此题没有求路径，只是路径和，所以可以直接通过返回值就可以记录当前节点由下自上的和，同时也可以memo进行优化**

  **如果求路径，则需要path，并进行回溯**

  ```java
      int max = 0;
      int sum = 0;
      boolean[][] used;
      LinkedList<Integer> path = new LinkedList<>();
      public int maxValue(int[][] grid) {
          used = new boolean[grid.length][grid[0].length];
          dfs(grid,0,0);
          return max;
      }
  
      public void dfs(int[][] grid,int i,int j){
            //base case
          if(i>=grid.length || j>=grid[0].length ){
              return;
          }
          sum += grid[i][j];
          path.add(grid[i][j]);
          System.out.println("grid[i][j]"+grid[i][j]+"i:"+i+"j:"+j);
          //到达终点
          if(i==grid.length-1 &&j==grid[0].length-1){
              //sum += grid[i][j];
              for(int num:path){
                  System.out.print(num+" ");
              }
              System.out.println();
              System.out.println("last"+path.getLast());
              path.removeLast();     
              max = Math.max(max,sum);
              sum -= grid[i][j];
              return;
          }
          //选择
          //sum += grid[i][j];
          dfs(grid,i+1,j);
          dfs(grid,i,j+1); 
         // used[i][j] = false;
          path.removeLast();
          sum -= grid[i][j];
      }
  ```

=========================================================================================================

详细讲解：

![image-20220425003200711](appendix\0刷题\image-20220425003200711.png)

- 暴力dfs，不带path

  ```java
      //1. 直接利用返回值
      //会超时
      public int maxValue(int[][] grid) {
          return dfs(grid,0,0);
      }
  
      public int dfs(int[][] grid,int i,int j){
          //base case
          if(i>=grid.length || j>= grid[0].length){
              return 0;
          }
  
          //前序的时候判断：是否到达终点，是的话就不进去递归了
          if(i==grid.length-1 && j==grid[0].length-1){
              return grid[i][j];
          }
  
          return Math.max(dfs(grid,i+1,j),dfs(grid,i,j+1)) + grid[i][j];
      }
  ```

- 带memo进行优化

  ```java
  //2. 看递归树的情况下，我们知道节点会有重复，情况其实完全一样，所以可以用memo记录
      int[][] memo;
      public int maxValue(int[][] grid) {
          //定义memo，进行初始化
          memo = new int[grid.length][grid[0].length];
          for(int i= 0;i < grid.length ;i++){
              Arrays.fill(memo[i],-1);
          }
          return dfs(grid,0,0);
      }
  
      public int dfs(int[][] grid,int i,int j){
          //base case
          if(i>=grid.length || j>= grid[0].length){
              return 0;
          }
  
          //前序的时候判断：是否到达终点，是的话就不进去递归了
          if(i==grid.length-1 && j==grid[0].length-1){
              return grid[i][j];
          }
  
          //利用memo减枝
          if(memo[i][j]!=-1) return memo[i][j];
  
          memo[i][j] = Math.max(dfs(grid,i+1,j),dfs(grid,i,j+1)) + grid[i][j];
  
          return memo[i][j];
      }
  ```

- 暴力递归，利用dfs

  - 坑，错误做法示例

  ```java
      //3. 利用path，回溯的方法
      LinkedList<Integer> path = new LinkedList<>();
      int sum = 0;
      int max = 0;
      public int maxValue(int[][] grid) {
          dfs(grid,0,0);
          return max;
      }
  
      public void dfs(int[][] grid,int i,int j){
          //base case
          if(i>=grid.length || j>= grid[0].length){
              return;
          }
  
          //前序的时候判断：是否到达终点，是的话就不进去递归了
          if(i==grid.length-1 && j==grid[0].length-1){
              sum += grid[i][j];
              max = Math.max(sum,max);
              return;
          }
  
          sum += grid[i][j];
          path.add(grid[i][j]);
  
          dfs(grid,i+1,j);
          dfs(grid,i,j+1);
  
          path.removeLast();
          sum -= grid[i][j];
      }
  ```

  为什么不对呢？分析一波发现，打印path

  ```java
  //前序的时候判断：是否到达终点，是的话就不进去递归了
          if(i==grid.length-1 && j==grid[0].length-1){
              max = Math.max(sum,max);
              for(int x:path){
                  System.out.print("x: "+x);
              }
              System.out.println();
              return;
          }
  ```

  ![image-20220425002500356](appendix\0刷题\image-20220425002500356.png)

  1 1 4 5 2 1，怎么来的呢，本来是 1,1,4,2,1，但是当到达叶子节点的时候，没有removeLast操作，导致了节点往上返回时，减少了一次removeLast，所以变成了1 1 4(本来应该是1 1)，然后就递归到5了，结果就变成了1 1 4 5 2 1。正确的代码如下：

  ```java
      //3. 利用path，回溯的方法
      LinkedList<Integer> path = new LinkedList<>();
      int sum = 0;
      int max = 0;
      public int maxValue(int[][] grid) {
          dfs(grid,0,0);
          return max;
      }
  
      public void dfs(int[][] grid,int i,int j){
          //base case
          if(i>=grid.length || j>= grid[0].length){
              return;
          }
  
          sum += grid[i][j];
          path.add(grid[i][j]);
  
          //前序的时候判断：是否到达终点，是的话就不进去递归了
          if(i==grid.length-1 && j==grid[0].length-1){
              max = Math.max(sum,max);
              for(int x:path){
                  System.out.print("x: "+x);
              }
              System.out.println();
              ///切记,当然不返回也可以
              path.removeLast();
              sum -= grid[i][j];
              return;
          }
  
          
  
          dfs(grid,i+1,j);
          dfs(grid,i,j+1);
  
          path.removeLast();
          sum -= grid[i][j];
      }
  ```



#### 求把第一次最大路径值置空后的第二次最大路径

- 暴力

```java
int max;
    int sum;
    LinkedList<Integer> value;
    LinkedList<int[]> path;
    LinkedList<int[]> maxPath;

    public int maxValue(int[][] grid) {
        //第一次dfs，找最大路径
        max = Integer.MIN_VALUE;
        value  =  new LinkedList<>();
        path  =  new LinkedList<>();
        maxPath  =  new LinkedList<>();
        sum = 0;
        dfs(0,0,grid);

        // for(int i=0;i < maxPath.size();i++){
        //     System.out.println(Arrays.toString(maxPath.get(i)));
        // }
        
        //把第一条路径值为空
        for(int i=0;i<maxPath.size();i++){
            int[] cur = maxPath.get(i);
            grid[cur[0]][cur[1]] = 0;
        }

        //第二次dfs
        max = Integer.MIN_VALUE;
        value  =  new LinkedList<>();
        path  =  new LinkedList<>();
        maxPath  =  new LinkedList<>();
        sum = 0;
        dfs(0,0,grid);
        // System.out.println();

        // for(int i=0;i < grid.length;i++){
        //     System.out.println(Arrays.toString(grid[i]));
        // }
        
        // for(int i=0;i < maxPath.size();i++){
        //     System.out.println(Arrays.toString(maxPath.get(i)));
        // }

        return max;
    }

    public void dfs(int i,int j,int[][] grid){
        //base case
        if(i>=grid.length || j>=grid[0].length){
            return;
        }

        sum += grid[i][j];
        value.add(grid[i][j]);
        path.add(new int[]{i,j});

        //终点
        if(i==grid.length-1 && j==grid[0].length-1){
            if(max < sum){
                max = sum;

                LinkedList<int[]> tmp = new LinkedList<>();
                for(int k=0;k<path.size();k++){
                    tmp.add(path.get(k));
                }
                maxPath = tmp;
            }
        }

        dfs(i+1,j,grid);
        dfs(i,j+1,grid);

        sum -= grid[i][j];
        value.removeLast();
        path.removeLast();
    }
```

- dp

```java
//dp
    public int maxValue(int[][] grid) {
        int[][] dp = new int[grid.length+1][grid[0].length+1];
        // for(int i = 1;i < dp.length;i++){
        //     for(int j = 1;j < dp[0].length;j++){
        //         dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1]; 
        //     }
        // }
        dpHelp(grid,dp);

        //找对应的值值为空
        int i = dp.length-1;
        int j = dp[0].length-1;
        //开始的放在外面
        grid[0][0] = 0;
        grid[grid.length-1][grid[0].length-1] = 0;
        while(i>=2 && j>=2){
            if(dp[i-1][j] > dp[i][j-1]){
                grid[i-2][j-1] = 0;
                i = i-1;
            }else{
                grid[i-1][j-2] = 0;
                j = j-1;
            }
        }

        for(int k=0;k < grid.length;k++){
            System.out.println(Arrays.toString(grid[k]));
        }

        //开始第二次dp
        int[][] dp1 = new int[grid.length+1][grid[0].length+1];
        dpHelp(grid,dp1);
        
        return dp1[grid.length][grid[0].length];

    }

    public void dpHelp(int[][] grid,int[][] dp){

        for(int i = 1;i < dp.length;i++){
            for(int j = 1;j < dp[0].length;j++){
                dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1]; 
            }
        }
    }
```

- dfs+memo

```java
    //dfs+memo
    HashMap<String,List<int[]>> memo = new HashMap();
    public int maxValue(int[][] grid) {
        List<int[]> res = dfs(0,0,grid);
        for(int i=0;i<res.size();i++){
            System.out.print(Arrays.toString(res.get(i)));
        }
        return 0;
    }

    public int sum(List<int[]> tmp,int[][] grid){
        int res = 0;
        for(int i = 0;i<tmp.size();i++){
            int[] cur = tmp.get(i);
            res +=  grid[cur[0]][cur[1]];
        }
        return res;
    }
    

    public List<int[]> dfs(int i,int j,int[][]grid){
        //base case
        if(i>=grid.length || j>=grid[0].length){
            return new LinkedList<>();
        }
        //m
        String key = i + "*" + j;
        if(memo.containsKey(key)){
            return memo.get(key);
        }

        List<int[]> left = dfs(i+1,j,grid);
        List<int[]> right = dfs(i,j+1,grid);

        int l = sum(left,grid);
        int r = sum(right,grid);

        List<int[]> path;

        if(l>r){
            path = new LinkedList<>(left);
        }else{
            path = new LinkedList<>(right);
        }

        path.add(new int[]{i,j});
        memo.put(key,path);

        return memo.get(key);
    }
```

- 错误

path是自定向下

memo是自底向上

不一致

```java
    //返回价值
    public int dfs(int i,int j,int[][] grid){
        //base case
        if(i>=grid.length || j>=grid[0].length){
            return 0;
        }

        // if(memo[i][j]!=0) return memo[i][j];

        path.add(grid[i][j]);

        memo[i][j] = Math.max(dfs(i+1,j,grid),dfs(i,j+1,grid)) + grid[i][j];

        //此处是memo的起点，因为memo是返回值，自底向上的
        //但是是path的终点，path在先序的时候添加
        //所以两者不一致
        if(i==grid.length-1 && j==grid[0].length-1){

            LinkedList<Integer> tmp = new LinkedList<>(path);
            System.out.println(Arrays.toString(tmp.toArray()));
            path.removeLast();
            System.out.println(memo[i][j]+" "+ memo[0][0]);
            return grid[i][j];
        }
         System.out.println("wai"+memo[i][j]+" "+ memo[0][0]);
        
        // System.out.println(Arrays.toString(path.toArray()));
        path.removeLast();
        return memo[i][j];
        
    }
```



#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)（重要）

可以和最大礼物和的题一起对比着看

- 动态规划1:错误解法

  ```java
      // 动态规划：（错误方式）
      // 增加一行一列(不能用这种方式，因为求的是最小值，新增加的行和列最小值都为0，在求取运算的时候会影响当前值（因为当前值总大于0）)
      // 状态：dp[i][j]表示当前i-1,j-1位置的最小和
      // 转移方程：
      //     dp[i][j] =  Math.min(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1];
      // 初始条件：
      //     dp[0][0] = grid[0][0]
      // 结果：
      //     dp[n][n] 
      public int minPathSum(int[][] grid) {
          int m = grid.length;
          int n = grid[0].length;
  
          int[][] dp = new int[m+1][n+1];
          dp[1][1] = grid[0][0];
          for(int i=1; i<=m;i++){
              for(int j=1;j<=n;j++){
                  dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i-1][j-1];
              }
          }
  
          return dp[m][n];
      }
  ```

- 动态规划：正确解法

  ```java
      // 动态规划：
      // 状态：dp[i][j]表示当前i,j位置的最小和
      // 转移方程：
      //      if(i==0 && j==0) dp[i][j] = grid[i][j];
      //      if(i==0) dp[i][j] = dp[i][j-1] + grid[i][j]
      //      if(j==0) dp[i][j] = dp[i-1][j] + grid[i][j]
      //      else: Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
      // 初始条件：
      //     dp[0][0] = grid[0][0]
      // 结果：
      //     dp[m-1][n-1] 
      public int minPathSum(int[][] grid) {
          int m = grid.length;
          int n = grid[0].length;
  
          int[][] dp = new int[m][n];
          for(int i=0; i<m;i++){
              for(int j=0;j<n;j++){
                  if(i==0 && j==0) dp[i][j] = grid[i][j];
                  else if(i==0) dp[i][j] = dp[i][j-1] + grid[i][j];
                  else if(j==0) dp[i][j] = dp[i-1][j] + grid[i][j];
                  else dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
              }
          }
  
          return dp[m-1][n-1];
      }
  ```

- 动态规划，可用原地空间

  ```java
      // 可用原地空间
      // Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
      // 因为grid[i][j]与之前的grid值无关
      public int minPathSum(int[][] grid) {
          for(int i = 0; i < grid.length; i++) {
              for(int j = 0; j < grid[0].length; j++) {
                  if(i == 0 && j == 0) grid[i][j]=grid[i][j];
                  else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];
                  else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];
                  else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
              }
          }
          return grid[grid.length - 1][grid[0].length - 1];
      }
  ```

- 暴力递归（深搜）(先序)

  ```java
      //暴力递归（dfs）
      private int m;
      private int n;
      private int min;
  
      public int minPathSum(int[][] grid) {
          this.m = grid.length;
          this.n = grid[0].length;
          this.min = Integer.MAX_VALUE;
  
          int sum = 0;
          dfs(grid,0,0,sum);
          return min;
      }
  
      public void dfs(int[][]grid,int i,int j,int sum){
          if(i==m-1 &&j==n-1) {
              sum += grid[i][j];
              min = Math.min(sum,min);
              return;
          }
  
          if(i==m || j==n) return;
  
          sum += grid[i][j];
          dfs(grid,i+1,j,sum);
          dfs(grid,i,j+1,sum);
      }
  ```

- 暴力递归（后序）

  ```java
      // 暴力递归 后序遍历
      public int minPathSum(int[][] grid) {
          return recur(grid,0,0);
      }
  
      public int recur(int[][] grid,int i,int j){
          //因为求最小值，所以没用的要写最大值才不会影响
          if(i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;
          //之前少了个条件判断
          if(i==grid.length-1 && j==grid[0].length-1) return grid[i][j];
      
          int r = recur(grid,i,j+1);
          int b = recur(grid,i+1,j);
  
          return Math.min(r,b) + grid[i][j];
      }
  ```

- 递归后序 + 剪枝记忆

  ```java
      // 递归 + 记忆 后序遍历
      private int[][]memo;
      public int minPathSum(int[][] grid) {
          memo = new int[grid.length][grid[0].length];
          for(int i= 0;i < grid.length;i++){
              Arrays.fill(memo[i],-1);
          }
          return recur(grid,0,0);
      }
  
      public int recur(int[][] grid,int i,int j){
          //因为求最小值，所以没用的要写最大值才不会影响
          if(i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;
          //之前少了个base case条件
          //自底向上，此时的值就是当前位置的最小路径和，因为在最低了
          if(i==grid.length-1 && j==grid[0].length-1) return grid[i][j];
  
          //剪枝，记忆状态
          if(memo[i][j]>-1) return memo[i][j];
  
          int r = recur(grid,i,j+1);
          int b = recur(grid,i+1,j);
  
          memo[i][j] = Math.min(r,b) + grid[i][j];
          return memo[i][j];
      }
  ```

- 另一种递归

  ```java
      //递归
      private int m;
      private int n;
      private int min;
      public int minPathSum(int[][] grid) {
          this.m = grid.length;
          this.n = grid[0].length;
          return recur(grid,0,0);
      }
  
      public int recur(int[][] grid, int i, int j) {
          if(i==m-1 && j==n-1) return grid[i][j];
          else if(i==m-1) return grid[i][j] + recur(grid,i,j+1);
          else if(j==n-1) return grid[i][j] + recur(grid,i+1,j);
  
          return grid[i][j] + Math.min(recur(grid,i,j+1),recur(grid,i+1,j));
      }
  ```

**由47和64题可得，其后序递归可以加状态保存，以空间换时间，速度会比dp还快**

> 压缩空间的时候的技巧：
>
> 0-1背包对物品的迭代放在里层，外层的体积或价值正向遍历;（零钱兑换1）
>
> ```java
> for(int i=1;i<=amount;i++){
>    for(int coin:coins){
> ```
>
> 
>
> 完全背包对体积或价值放在里层正向遍历，外层的物品的迭代（零钱兑换2）
>
> ```java
> for (int i = 0; i < coins.length; i++)
>     for (int j = 1; j <= amount; j++)	
> ```

#### * [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

初始值的问题

![image-20220428155656017](appendix\0刷题\image-20220428155656017.png)

```java
//     状态：dp[i]表示，凑成i的金额的最小硬币数
// 转移方程：
// 	i>0:dp[i] = min(dp[i-2],dp[i-3],dp[i-5])..+1
// 	i<0:无效 
// 初始：dp[0] = 0
// 结果：dp[amount]
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        //需要填充一个大数，因为要取最小值，不然初始值为0的情况下，最小值都为0
        Arrays.fill(dp,amount+1);

        dp[0] = 0;
        for(int i=1;i<=amount;i++){
            for(int coin:coins){
                if(i >= coin ) {
                    dp[i] = Math.min(dp[i-coin]+1,dp[i]);
                }
            }
        }
        // System.out.println(Arrays.toString(dp));
        //因为<0的dp值为amount+1
        if(dp[amount] > amount){
            return -1;
        }else{
            return dp[amount];
        }
        
    }
```

- 01背包解法

```java
// 状态：dp[i][j]表示，在前i(0-i-1)个硬币里，凑成j的金额的最小硬币数
// 转移方程：取最小 
// 	选：dp[i][j] = dp[i][j-coins[i]] + 1
// 	不选：dp[i][j] = dp[i-1][j]
// 初始：dp[0][0] = 0,其他值为最大
// 结果：dp[amount]
    public int coinChange(int[] coins, int amount) {
        int[][] dp = new int[coins.length+1][amount+1];
        //需要填充一个大数，因为要取最小值，不然初始值为0的情况下，最小值都为0
        for(int i =0;i<=coins.length;i++){
            Arrays.fill(dp[i],amount+1);
        }
        
        //表示从前 0种硬币中选出若干个组成金额 0所对应的最小硬币数目为 0，即「空集合」不选任何硬币即可得到金额 0
        dp[0][0] = 0;
        for(int i=1;i<=coins.length;i++){
            for(int j=0;j<=amount;j++){
                if(j-coins[i-1] < 0) {
                    dp[i][j] = dp[i-1][j];
                }else{
                    dp[i][j] = Math.min(dp[i][j-coins[i-1]] + 1,dp[i-1][j]);
                }
            }
        }

        // for(int i = 0;i<dp.length;i++){
        //     System.out.println(Arrays.toString(dp[i]));
        // }
        
        //因为<0的dp值为amount+1
        if(dp[coins.length][amount] == amount + 1){
            return -1;
        }else{
            return dp[coins.length][amount];
        }
        
    }
```



#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

- 完全背包

```java
    //dp
    //状态：选的硬币，总金额
    //  dp[i][j]：选择前i-1个硬币里，和为j的组合数
    //初始值：
    //  dp[0][i] =0,dp[i][0] = 1（无为而治）
    //状态转移：（第i-1个硬币装还是不装）,两者相加
    //  选择：选 dp[i][j] = dp[i][j-coins[i-1]](可以重复)
    //  选择：不选 dp[i][j] = dp[i-1][j]
    public int change(int amount, int[] coins) {
        int[][] dp = new int[coins.length+1][amount+1];

        // 初始化
        for(int i = 1;i <= coins.length;i++){
            dp[i][0] = 1;
        }

        for(int i=1;i<=coins.length;i++){
            for(int j = 1;j<=amount;j++){
                if(j-coins[i-1] < 0){
                    dp[i][j] = dp[i-1][j];
                }else{
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];
                }
            }
        }

        return dp[coins.length][amount];

    }
```

- 压缩空间

```java
int change(int amount, int[] coins) {
    int n = coins.length;
    int[] dp = new int[amount + 1];
    dp[0] = 1; // base case
    for (int i = 0; i < n; i++)
        for (int j = 1; j <= amount; j++)
            if (j - coins[i] >= 0)
                dp[j] = dp[j] + dp[j-coins[i]];
    
    return dp[amount];
}
```



#### [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

完全背包问题

- 最优

```java
    //转成完全背包问题
    //dp[i]：现在和为i的最小的个数
    //状态转移：当前的数的平方选还是不选
    //  dp[i] = Math.min(f(n-1^2),f(n-2^2)...)+1
    //初始值：
    //  dp[0]=0,其他都是最大值
    //结果：
    //  dp[n]

    
    public int numSquares(int n) {
        int[] dp = new int[n+1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0] = 0;

        for(int i =1;i <= n;i++){
            for(int j=1; j*j<= i;j++){
                dp[i] = Math.min(dp[i],dp[i-j*j]+1);
            }
        }

        return dp[n];
    }
```

- 服了

```java
    //转成完全背包问题
    //状态：所选的数，价值
    //dp[i][j]：可以选择0-i-1的数的平方，现在和为j的最小的个数
    //状态转移：当前的数的平方选还是不选
    //  dp[i][j] = Math.min(dp[i-1][j],dp[i][j-i^2] + 1)
    //初始值：
    //  dp[0][0]=0,其他都是最大值
    //结果：
    //  dp[m][n]
    public int numSquares(int n) {
        List<Integer> list = new ArrayList<>();
        int t=1;
        while(t*t<=n){
            list.add(t*t);
            t++;
        }

        int m = list.size();
        int[][] dp = new int[m+1][n+1];

        for(int i = 0;i <= m;i++){
            Arrays.fill(dp[i],Integer.MAX_VALUE/2);
        }

        for(int i=1;i<=m;i++){
            dp[i][0] = 0;
        }

//        for(int i =0;i<=m;i++){
//            System.out.println(Arrays.toString(dp[i]));
//        }

        // dp[0][0] = 0;
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(j-list.get(i-1) < 0){
                    dp[i][j] = dp[i-1][j];
                }else{
                    dp[i][j] = Math.min(dp[i-1][j],(int)(dp[i][j-list.get(i-1)])+1);

//                    System.out.println("dp[i-1][j]: "+(i-1)+","+ j +"  :" + dp[i-1][j]);
//                    System.out.println("dp[i][j-list.get(i-1)]: "+i+", "+(j-list.get(i-1))+ "  :"+ (int)(dp[i][j-list.get(i-1)])+1);
//                    System.out.println("dp[i][j]: "+(i)+","+ j +"  :" + dp[i][j]);
//                    System.out.println();
                }
            }
        }

//        System.out.println();
//        for(int i =0;i<=m;i++){
//            System.out.println(Arrays.toString(dp[i]));
//        }

        return dp[m][n];
    }
```





#### ** [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

>   二刷：转移方程：比nums[i]小的那些j的dp的最大值+1

初始值的问题

```java
    //注意：该问题中的子序列不要求连续
    //dp[i]：表示以nums[i]结尾的递增子序列的最大长度,下标
    //转移方程：比nums[i]小的那些j的dp的最大值+1
    //初始值：dp[i] = 1,因为子序列必然包含它本身
    //结果：max(dp[i])
    public int lengthOfLIS(int[] nums) {
        int max = 0;
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        for(int i = 0;i<nums.length;i++){
            for(int j = 0;j < i;j++){
                if(nums[j]<nums[i]) {
                    dp[i] = Math.max(dp[j]+1,dp[i]);
                }
            }
            max = Math.max(max,dp[i]);
        }
        // System.out.println(Arrays.toString(dp));

        return max;
    }
```

```java
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];

        //初始化
        Arrays.fill(dp,1);
        //初始的max = 1 
        int max = 1;

        for(int i = 0;i < nums.length;i++){
            for(int j = 0;j < i;j++){
                if(nums[j] < nums[i]){
                    dp[i] = Math.max(dp[j]+1,dp[i]);
                }
                max = Math.max(dp[i],max);
            }
        }

        return max; 
    }
```



#### [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

>   注意初始值

```java
    //状态：dp[i]表示前i个里最大的序列和，nums[i]我必要
    //初始值： dp[0] = nums[0]
    //转移方程：dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);
    //结果：max(dp[])
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        int max = Integer.MIN_VALUE;
        dp[0] = nums[0];

        for(int i = 1;i<nums.length;i++){
            dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);
            max = Math.max(dp[i],max);
        }

        return dp[0]<max?max:dp[0];
    }
```



#### *[931. 下降路径最小和](https://leetcode-cn.com/problems/minimum-falling-path-sum/)

>   要明确返回值，也就是程序的出口，以及程序的入口...都是一行

- 暴力dfs

  ```java
      //暴力dfs
      public int minFallingPathSum(int[][] matrix) {
          //dfs
          int min = Integer.MAX_VALUE;
          for(int i =0;i<matrix.length;i++){
              min = Math.min(min,dfs(matrix,0,i));
          }
  
          return min;
      }
  
      public int dfs(int[][] matrix,int i,int j){
          if(i>=matrix.length || j<0 ||j>=matrix[0].length){
              return Integer.MAX_VALUE;
          }
  
          if(i==matrix.length-1){
              return matrix[i][j];
          }
  
          return Math.min(Math.min(dfs(matrix,i+1,j-1),dfs(matrix,i+1,j)),dfs(matrix,i+1,j+1)) + matrix[i][j];
      }
  ```

  

- 带memo的dfs

  ```java
  //带备忘录
      int[][] memo;
      public int minFallingPathSum(int[][] matrix) {
          //dfs
          int min = Integer.MAX_VALUE;
          memo = new int[matrix.length][matrix[0].length];
          for(int i = 0;i<memo.length;i++){
              Arrays.fill(memo[i],-101);
          }
  
          for(int i =0;i<matrix.length;i++){
              min = Math.min(min,dfs(matrix,0,i));
          }
  
          return min;
      }
  
      public int dfs(int[][] matrix,int i,int j){
          if(i>=matrix.length || j<0 ||j>=matrix[0].length){
              return Integer.MAX_VALUE;
          }
  
          if(memo[i][j]!=-101){
              return memo[i][j];
          }
          
          if(i==matrix.length-1){
              return matrix[i][j];
          }
  
          memo[i][j] = Math.min(Math.min(dfs(matrix,i+1,j-1),dfs(matrix,i+1,j)),dfs(matrix,i+1,j+1)) + matrix[i][j];
          return memo[i][j];
      }
  ```

  

- 动态规划

  ```java
    //dp
     //dp[i][j]：表示到（i,j）的最小和
     //转移方程：dp[i][j] = Math.min(dp[])，边界问题
     //初始值：第一行为自己本身
     //结果：min(dp[i][j]) 最后一行
      public int minFallingPathSum(int[][] matrix) {
          int min = Integer.MAX_VALUE;
          //
          int[][] dp = new int[matrix.length][matrix[0].length];
          for(int i=0;i<matrix[0].length;i++){
              dp[0][i] = matrix[0][i];
          }
  
          for(int i=1;i<matrix.length;i++){
              for(int j=0;j<matrix[0].length;j++){
                  dp[i][j] = Integer.MAX_VALUE;
              }
          }
  
          //
          for(int i = 1;i<matrix.length;i++){
              for(int j =0;j<matrix[0].length;j++){
                  if(i-1>=0 && j-1>=0){
                      dp[i][j] = Math.min(dp[i][j],dp[i-1][j-1]+matrix[i][j]);
                  }
                  if(i-1 >=0){
                      dp[i][j] = Math.min(dp[i][j],dp[i-1][j]+matrix[i][j]);
                  }
                  if(i-1 >=0 && j+1 < matrix[0].length){
                      dp[i][j] = Math.min(dp[i][j],dp[i-1][j+1]+matrix[i][j]);
                  }
                  
                  
              }
              // System.out.println(Arrays.toString(dp[i]));
              
          }
  
          //因为会有的只有一行，只能拉出来看
          for(int i = 0;i<matrix.length;i++){
              min = Math.min(min,dp[matrix.length-1][i]);
          }
  
          return min;
      
  ```
  
  ```java
  //三刷    
  public int minFallingPathSum(int[][] matrix) {
          int m = matrix.length;
          int n = matrix[0].length;
          int min = Integer.MAX_VALUE;
  
          int[][] dp = new int[m][n];
  
          for(int i = 0;i < m;i++){
              for(int j = 0;j < n ;j++){
                  if(i==0 && j==0) dp[i][j] = matrix[i][j];
                  else if(i==0) dp[i][j] = matrix[i][j];
                  else if(j==0) dp[i][j] = Math.min(dp[i-1][j],dp[i-1][j+1]) + matrix[i][j];
                  else if(j==n-1) dp[i][j] = Math.min(dp[i-1][j],dp[i-1][j-1]) + matrix[i][j];
                  else dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i-1][j-1]),dp[i-1][j+1]) + matrix[i][j];
                  
              }
              
          }
  
          for(int i = 0;i < n;i++){
              min = Math.min(min,dp[m-1][i]);
          }
          return min;
      }
  ```
  
  

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

    插入一个字符
    删除一个字符
    替换一个字符

- 暴力dfs

  ```java
      //暴力解法dfs，会超时
      public int minDistance(String word1, String word2) {
          int m = word1.length(), n = word2.length();
          // i，j 初始化指向最后一个索引
          return dfs(word1, m - 1, word2, n - 1);
      }
  
      // 定义：返回 s1[0..i] 和 s2[0..j] 的最小操作数
      int dfs(String word1,int i,String word2,int j){
          //base case
          //当两个序列走完了
          if(i==-1) return j+1;
          if(j==-1) return i+1;
  
          //返回
          if(word1.charAt(i)==word2.charAt(j)){
              return dfs(word1,i-1,word2,j-1);
          }
  
          //增，删，改
          return Math.min(Math.min(dfs(word1,i,word2,j-1),dfs(word1,i-1,word2,j)),
                  dfs(word1,i-1,word2,j-1)) + 1;
      }   
  ```

  

- 带memo的dfs

  ```java
  //备忘录优化
      int[][] memo;
      public int minDistance(String word1, String word2) {
          int m = word1.length(), n = word2.length();
          memo = new int[m][n];
          for(int i = 0;i<m;i++){
              Arrays.fill(memo[i],-1);
          }
          // i，j 初始化指向最后一个索引
          return dfs(word1, m - 1, word2, n - 1);
      }
  
      // 定义：返回 s1[0..i] 和 s2[0..j] 的最小操作数
      int dfs(String word1,int i,String word2,int j){
          //base case
          //当两个序列走完了
          if(i==-1) return j+1;
          if(j==-1) return i+1;
  
          //剪枝
          if(memo[i][j]!=-1){
              return memo[i][j];
          }
  
          //返回
          if(word1.charAt(i)==word2.charAt(j)){
              return dfs(word1,i-1,word2,j-1);
          }
  
          //增，删，改
          memo[i][j] = Math.min(Math.min(dfs(word1,i,word2,j-1),dfs(word1,i-1,word2,j)),
                  dfs(word1,i-1,word2,j-1)) + 1;
          return memo[i][j];
      }    
  ```

  

- 动态规划

  ```java
  //dp
  //状态：
  // dp[i][j] 代表 word1 到 i-1 位置转换成 word2 到 j-1 位置需要最少步数
  //转移方程：
  //当word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；
  //改，删，增
  //当word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
  //初始值 base cse
  //不是很理解
  //结果：dp[m][n]
      public int minDistance(String word1, String word2) {
          int m = word1.length(), n = word2.length();
          int[][] dp = new int[m+1][n+1];
          //base case
          // 第一行
          for (int j = 1; j <= n; j++) dp[0][j] = dp[0][j - 1] + 1;
          // 第一列
          for (int i = 1; i <= m; i++) dp[i][0] = dp[i - 1][0] + 1;
  
          for(int i = 1;i <= m;i++){
              for(int j = 1;j <= n;j++){
                  if(word1.charAt(i-1)==word2.charAt(j-1)){
                      dp[i][j] = dp[i-1][j-1];
                  }else{
                      dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
                  }
              }
          }
          return dp[m][n];
      }
  ```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```java
    //动态规划
    //dp[i][j]：表text1[0:i-1]，text2[0:j-1]之间的最长公共子序列
    //状态转移方程：
    //  text1[i-1]==text2[j-1]时 :dp[i][j] = dp[i-1][j-1]+1
    //  text1[i-1]!=text2[j-1]时 :dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
    //初始值：
    //  i = 0 : dp[0][j] = 0
    //  j = 0 : dp[j][0] = 0
    //结果：
    //  dp[m][n]
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m+1][n+1];

        //初始化
        for(int i = 1;i <=m ;i++){
            dp[i][0] = 0;
        }

        for(int j = 1;j<=n;j++){
            dp[0][j] = 0;
        }

        //状态转移
        for(int i = 1;i<=m;i++){
            for(int j =1;j<=n;j++){
                if(text1.charAt(i-1)==text2.charAt(j-1)) dp[i][j] = dp[i-1][j-1] + 1;
                else dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
            }
        }

        return dp[m][n];

    }
```



#### * [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

转为01背包的问题

初始条件

```java
    //状态：
    //	dp[i][j] = x，表示选择第i个物品，当前背包的容量是j-1，如果x=true表示可以装满
    //状态转移：
    //	选择：不装和装（是否刚好装满）
    //	dp[i][j] = dp[i-1][j] || d[i-1][j-nums[i-1]]
    //初始值：dp[0][i] = false,dp[i][0] = true
    //结果：dp[nums.length][sum/2]
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int num:nums){
            sum +=num;
        }
        
        if (sum % 2 != 0) {
            return false;
        }
        sum = sum/2;

        boolean[][] dp = new boolean[nums.length][sum+1];

        // // 初始化
        for (int i = 0; i < nums.length; i++)
            dp[i][0] = true;

        if (nums[0] <= sum) {
            dp[0][nums[0]] = true;
        }
        for(int i = 1;i < nums.length;i++){
            //选择当前容量
            for(int j = 0;j<=sum;j++){
                if(j-nums[i] < 0){
                    dp[i][j] = dp[i-1][j];
                }else{
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
                }
            }
        }

        return dp[nums.length-1][sum];
    }
```



#### [787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)

```java
    //从前向后dfs
    //
    int INF = 1000007;

    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        // k表示经过的节点，我们转成边数（步数），这样好计算一些
        int[][] memo = new int[n][k+2];
        for(int i = 0;i<n;i++){
            Arrays.fill(memo[i],-1);
        }
        int ans = dfs(flights, src, dst, k + 1, memo);
        return ans >= INF ? -1 : ans;
    }

    //从src到dst(固定)的走k步的最小价格
    //无环 不用visit数组
    private int dfs(int[][] flights, int src, int dst, int k,int[][] memo){
        //base case
        if(k < 0){
            return INF;
        }

        if(src==dst){
            return 0;
        }

        if(memo[src][k]!=-1){
            return memo[src][k];
        } 

        int min = INF;
        for(int[] flight:flights){
            if(flight[0]==src){
                min = Math.min(min,dfs(flights,flight[1],dst,k-1,memo)+flight[2]);
            }
        }

        memo[src][k] = min;
        return min;
    }
```



0-1背包对物品的迭代放在外层，里层的体积或价值逆向遍历;完全背包对物品的迭代放在里层，外层的体积或价值正向遍历

```java
    //转成完全背包问题
    //状态：所选的数，价值
    //dp[i][j]：可以选择0-i-1的数的平方，现在和为j的最小的个数
    //状态转移：当前的数的平方选还是不选
    //  dp[i][j] = Math.min(dp[i-1][j],dp[i][j-i^2] + 1)
    //初始值：
    //  dp[0][0]=0,其他都是最大值
    //结果：
    //  dp[m][n]
    public int numSquares(int n) {
        List<Integer> list = new ArrayList<>();
        int t=1;
        while(t*t<=n){
            list.add(t*t);
            t++;
        }

        int m = list.size();
        int[][] dp = new int[m+1][n+1];

        for(int i = 1;i <= m;i++){
            Arrays.fill(dp[i],Integer.MAX_VALUE);
        }

        for(int i=1;i<=m;i++){
            dp[i][0] = 0;
        }

        for(int i =0;i<m;i++){
            System.out.println(Arrays.toString(dp[i]));
        }

        // dp[0][0] = 0;
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(j-list.get(i-1) < 0){
                    dp[i][j] = dp[i-1][j];
                }else{
                    dp[i][j] = Math.min(dp[i-1][j],dp[i][j-list.get(i-1)]+1);
                    System.out.println("dp[i-1][j]: "+i-1+": "j +"  " + dp[i-1][j] );
                    System.out.println("dp[i][j-list.get(i-1)]: "+i+": "j-list.get(i-1)+ "  "+ dp[i][j-list.get(i-1)]+1);
                }
            }
        }
        for(int i =0;i<m;i++){
            System.out.println(Arrays.toString(dp[i]));
        }
        
        return dp[m][n];
    }
```

#### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

动态规划图

![image-20220502172625442](appendix/0刷题/image-20220502172625442.png)

```java
    //定义先手和后手
    class Pair{
        int fir,sec;

        Pair(int fir,int sec){
            this.fir = fir;
            this.sec = sec;
        }
    }

    // 动态规划
    // 状态：
    // Pair[][] dp
    // dp[i][j].fir表示在i-j区间，先手可以拿到的最多的石子数
    // dp[i][j].sec表示在i-j区间，后手可以拿到的最多的石子数
    // 状态转移：选左边，选右边
    // dp[i][j].fir = Math.max(piles[i] + dp[i+1][j].sec,piles[j] + dp[i][j-1].sec)
    // dp[i][j].sec = 
    //     if(dp[i][j].fir==piles[i] + dp[i+1][j].sec) dp[i][j].sec = dp[i+1][j].fir
    //     if(dp[i][j].fir==piles[j] + dp[i][j-1].sec) dp[i][j].sec = dp[i][j-1].fir
    // 初始化：
    // dp[x][x].fir = piles[x]
    // dp[x][x].sec = 0
    // 其他位置为0,0
    // 结果：
    // dp[0][len-1].fir-dp[0][len-1].sec

    public boolean stoneGame(int[] piles) {
        int n = piles.length;
        Pair[][] dp= new Pair[n][n];

        //初始化
        for (int i = 0; i < n; i++) 
            for (int j = i; j < n; j++)
                dp[i][j] = new Pair(0, 0);
    
        for (int i = 0; i < n; i++) {
            dp[i][i].fir = piles[i];
            dp[i][i].sec = 0;
        }
        
        //开始状态转移
        //由于状态本身，从下往上，从左向右
        //初始值n-1已经计算过了，从n-2开始
        for(int i = n-2;i>=0;i--){
            for(int j = i + 1;j<n;j++){
                int left = piles[i] + dp[i+1][j].sec;
                int right = piles[j] + dp[i][j-1].sec;
                if(left > right){
                    dp[i][j].fir = left;
                    dp[i][j].sec = dp[i+1][j].fir;
                }else{
                    dp[i][j].fir = right;
                    dp[i][j].sec = dp[i][j-1].fir;
                }
            }
        }

        Pair res = dp[0][n-1];
        return res.fir > res.sec;
    }
```

#### 651.[四键键盘](https://labuladong.gitee.io/algo/3/26/94/)

假设你有一个特殊的键盘，上面只有四个键，它们分别是：

1、`A` 键：在屏幕上打印一个 `A`。

2、`Ctrl-A` 键：选中整个屏幕。

3、`Ctrl-C` 键：复制选中的区域到缓冲区。

4、`Ctrl-V` 键：将缓冲区的内容输入到光标所在的屏幕上。

```java
public int maxA(int N) {
    int[] dp = new int[N + 1];
    dp[0] = 0;
    for (int i = 1; i <= N; i++) {
        // 按 A 键
        dp[i] = dp[i - 1] + 1;
        for (int j = 2; j < i; j++) {
            // 全选 & 复制 dp[j-2]，连续粘贴 i - j 次
            // 屏幕上共 dp[j - 2] * (i - j + 1) 个 A
            dp[i] = Math.max(dp[i], dp[j - 2] * (i - j + 1));
        }
    }
    // N 次按键之后最多有几个 A？
    return dp[N];
}
```









 ### -找规律

#### [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

思路：(有点难受)

根据以上分析，可将求解分为三步：

    确定n所在数字的位数 ，记为digit；
    确定n所在的数字，记为num；
    确定n是num中的哪一数位，并返回结果。

![44](appendix\44_1.png)

![44](appendix\44_2.png)

![44](appendix\44_3.png)

![44](appendix\44_4.png)

![44](appendix\44_5.png)

![44](appendix\44_6.png)

```java
    public int findNthDigit(int n) {
        //1.求位数
        int digit = 1; //位数
        long start = 1; //首位数
        long count = 9; //digit有多少位数
        while (n > count) { // 1.
            n -= count;
            //下一轮的
            digit += 1;
            start *= 10;
            count = digit * start * 9;
        }

        //2.求是哪个数字
        long num = start + (n - 1) / digit; // 2.

        //3.求数字中的第几位
        return Long.toString(num).charAt((n - 1) % digit) - '0'; // 3.
    }
```

#### [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

- 步骤：

  - 不能用除法的情况下，将乘积分为两个部分，当前数之前（左），当前数之后（右），当前数看为1

  - 先将所求空间列出，发现，左半部分是下三角区，右半部分是上三角区，分别计算进行累乘

  - 计算下三角区：b[i] = b[i-1]*a[i-1]

    计算上三角区（从下向上计算，可以将小数的结果复用）：tmp *= a[i+1]; b[i]*= tmp;

  ```java
      //分组进行计算
      //当前下标i的值当做为1
      //分为上下两个三角，分别进行计算，再累乘
      public int[] constructArr(int[] a) {
          if(a==null || a.length < 2) return new int[0];
  
          int[] b = new int[a.length];
          b[0] = 1;
          int index = 1;
          //累乘计算下三角，这循环写得太牛了
          for(int i = 1;i < a.length;i++ ){
              b[i] = b[i-1] * a[i-1];  
          }
          //累乘计算上三角
          //从下往上累乘可以复用结果
          int tmp = 1;
          for(int i=a.length-2;i>=0;i--){
              tmp *= a[i+1];
              b[i] *= tmp;
          }
          return b;
      }
  ```

  



### - 栈、队列

#### [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```java
 LinkedList<Integer> s1, s2;
    public CQueue() {
        s1 = new LinkedList<Integer>();
        s2 = new LinkedList<Integer>();

    }
    
    public void appendTail(int value) {
        s1.addLast(value);
    }
    
    public int deleteHead() {
        if(!s2.isEmpty()){
            return s2.removeLast();
        }else if(s1.isEmpty()&&s2.isEmpty()){
            return -1;
        }else if(!s1.isEmpty()&&s2.isEmpty(){
            while(!s1.isEmpty()){
                s2.addLast(s1.removeLast());
            }
            return s2.removeLast();
        }
    }
```

-   最垃圾的算法，s1->s2->s1

```java
    Stack<Integer> s1;
    Stack<Integer> s2;

    public CQueue() {
        s1 = new Stack<>();
        s2 = new Stack<>();
    }
    
    public void appendTail(int value) {
        s1.push(value);
    }
    
    public int deleteHead() {
        int res = -1;
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        if(!s2.isEmpty()){
            res = s2.pop();
        }
        while(!s2.isEmpty()){
            s1.push(s2.pop());
        }
        return res;
    }
```

-   优化上一步,s1->s2

```java
    Stack<Integer> s1;
    Stack<Integer> s2;

    public CQueue() {
        s1 = new Stack<>();
        s2 = new Stack<>();
    }
    
    public void appendTail(int value) {
        s1.push(value);
    }

    public int deleteHead() {
        int res = -1;
        while(!s2.isEmpty()){
            return s2.pop();
        }
        //s2为空，s1不为空
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        if(!s2.isEmpty()){
            res = s2.pop();
        }
        return res;
    }
```



#### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

```java
    Stack<Integer> s1;
    Stack<Integer> s2;
    public MinStack() {
        s1 = new Stack<>(); //正常栈
        s2 = new Stack<>(); //辅助栈，要求最小值在栈顶,不用所有元素都进辅助栈，找到最小就好

    }
    
    public void push(int x) {
        s1.add(x);
        if(s2.empty() || x <= s2.peek()){
            s2.add(x);
        }
    }
    
    public void pop() {
        //注意此处stack里放的是Integer，
        int x = s1.pop();
        if(!s2.empty() && x==s2.peek()){
            s2.pop();
        }
    }
    
    public int top() {
        return s1.peek();
    }
    
    public int min() {
        return s2.peek();
    }
```

```java

    Stack<Integer> s1;
    Stack<Integer> s2;

    /** initialize your data structure here. */
    public MinStack() {
        s1 = new Stack<>();
        s2 = new Stack<>();
    }
    
    public void push(int x) {
        s1.push(x);
        if(!s2.isEmpty() && s2.peek() < x) return;
        s2.push(x);
    }
    
    public void pop() {
        int x = s1.pop();
        if(!s2.isEmpty() && x==s2.peek()){
            s2.pop();
        }
    }
    
    public int top() {
        if(!s1.isEmpty()){
            return s1.peek();
        }else{
            return -1;
        }
    }
    
    public int min() {
        // System.out.print(s2);
        if(!s2.isEmpty()){
            return s2.peek();
        }else{
            return -1;
        }
    }
```



#### *[剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

- 遍历popped数组，快

  ```java
          Stack<Integer> s = new Stack<>();
          int index = 0; //控制pushed
          int i = 0; //控制popped
          while(i < popped.length){
              if(s.empty() || (!s.empty() && s.peek()!=popped[i])){
                  while(index < pushed.length && pushed[index]!=popped[i] ){
                      s.push(pushed[index]);
                      index++;
                  }
              }
              if(index < pushed.length && pushed[index]==popped[i]){
                  s.push(pushed[index]);
                  index++;
              }
              if(popped[i]==s.peek()){
                  s.pop();
                  i++;
              }else{
                  return false;
              }
          }
          return true;
      }
  ```

- 遍历pushed数组,慢

  ```java
      public boolean validateStackSequences(int[] pushed, int[] popped) {
          Stack<Integer> s = new Stack<>();
          int i = 0;//控制popped的下标
          for(int num:pushed){
              s.push(num);
              while(!s.empty() && s.peek() == popped[i]){
                  s.pop();
                  i++;
              }
          }
          return s.empty();
      }
  ```

-   要注意遍历push数组的时候，先让数据入栈，再看是否出栈，不要ran在一起

    ```java
        public boolean validateStackSequences(int[] pushed, int[] popped) {
            Stack<Integer> s = new Stack<>();
    
            int pop = 0;
            for(int num:pushed){
                s.push(num);
                while(!s.isEmpty() && s.peek()==popped[pop]){
                    s.pop();
                    pop++;
                }
                //不要写成这样，s为空的时候，pop就越界了
                while(!s.isEmpty() && s.peek()==popped[pop++]){
                    s.pop();
                }
            }
            return s.isEmpty();
        }
    ```

    



#### *[剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

- 双端队列，保持辅助队列中，队头为最大

  ```java
      LinkedList<Integer> q1;
      LinkedList<Integer> q2;
      public MaxQueue() {
          q1 = new LinkedList<>(); //队列，队尾为最大值getLast()，从队头出
          q2 = new LinkedList<>(); //正常队列
      }
      
      public int max_value() {
          if(q2.isEmpty()){
              return -1;
          }else{
              return q2.getLast();
          }
      }
      
      public void push_back(int value) {
          q2.add(value);
          if(!q1.isEmpty() && value > q1.getLast()){
              q1.add(value);
          }else if(q1.isEmpty()){
              q1.add(value);
          }
      }
      
      public int pop_front() {
          if(q2.isEmpty()){
              return -1;
          }
          int cur = q2.removeFirst();
          if(!q1.isEmpty() && cur==q1.getFirst()){
              q1.removeFirst();
          }
          return cur; 
      }
  ```

-   思路是对的，代码实现太粗心了，栈和队列的操作要记熟

    尤其是双端队列

    队列是offer poll

    栈是push pop

    ```java
        LinkedList<Integer> q1;
        LinkedList<Integer> q2;
    
        public MaxQueue() {
            q1 = new LinkedList<>(); //正常队列
            q2 = new LinkedList<>(); //只存比当前头小的，大的都删了
        }
        
        public int max_value() {
            if(!q2.isEmpty()){
                return q2.peek();
            }else{
                return -1;
            }
        }
        
        public void push_back(int value) {
            q1.offer(value);
            //注意脑袋里想的是对的，代码实现错了
            //和队列的尾比较
            while(!q2.isEmpty() && q2.peekLast() < value){
                q2.pollLast();
            }
            q2.offer(value);
        }
        
        public int pop_front() {
            if(q1.isEmpty()) return -1;
            int res = q1.poll();
            if(!q2.isEmpty() && q2.peek()==res){
                q2.poll();
            }
            return res;
        }
    ```

    

#### **[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

一点也想不起来单调队列的方法...

还是注意双端队列的使用...

- 暴力

  ```java
      public int[] maxSlidingWindow(int[] nums, int k) {
          if(nums==null||nums.length < 1 ) return new int[0];
          int[] res = new int[nums.length-k+1];
          int start = 0, end = k-1;
          while(start <= nums.length-k){
              //数组copy
              int tmp[] = Arrays.copyOfRange(nums, start, end+1);
              //数组求最大
              res[start] = Arrays.stream(tmp).max().getAsInt();
              start++;
              end++;
          }
          return res;
      }
  ```

- 单调队列

  其使用 单调栈 实现了随意入栈、出栈情况下的 O(1)时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素” 。

  窗口对应的数据结构为 双端队列 ，本题使用 单调队列 即可解决以上问题。遍历数组时，每轮保证单调队列 deque ：

  - deque内 仅包含窗口内的元素 
  - deque内的元素 非严格递减 

  ```java
      public int[] maxSlidingWindow(int[] nums, int k) {
          if(nums.length == 0 || k == 0) return new int[0];
          LinkedList<Integer> q = new LinkedList<>(); //定义一个双端队列，维护非严格递减序列（队头为最大）
          int[] res = new int[nums.length - k + 1];
  
          //当没有形成窗口前
          for(int i=0;i < k;i++){
              while(!q.isEmpty() && q.getLast() < nums[i]){
                  q.removeLast();
              }
              q.addLast(nums[i]);
          }
  
          //形成窗口后
          res[0] = q.getFirst();
          for(int i = k;i < nums.length;i++){
              if(q.getFirst()==nums[i-k]){ //第一个被移除的元素
                  q.removeFirst();
              }
              while(!q.isEmpty() && q.getLast() < nums[i]){
                  q.removeLast();
              }
              q.addLast(nums[i]);
              res[i-k+1] = q.getFirst();
          }
          return res;
      }
  ```

- 时间复杂度分析

  **暴力：** O((n−k+1)k)≈O(nk) 。

  设数组 nums的长度为 n，则共有 (n-k+1)个窗口；
  获取每个窗口最大值需线性遍历，时间复杂度为 O(k) 。

  **单调双端队列：**O(2n) 

  其中 n为数组 nums长度；线性遍历 nums 占用 O(n；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O(2n) 

  



### - 其他

#### [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

分析：

![](appendix\求1.png)

```java
    public int countDigitOne(int n) {
        int res = 0, digit = 1;//digit表示位数，1为个数，10为十位，100为百位
        int low = 0;
        int cur = n%10; //求n的个位
        int high = n/10; //求n的十位
        //计算当前位为1的可能性
        while(high!=0 || cur!=0 ){   //high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出
            if(cur > 1){
                res += (high + 1)*digit;  //每种情况进行分析
            }else if(cur == 1){
                res += high*digit + low+1;
            }else{
                res += high*digit;
            }

            //下一轮变量的值
            low = cur * digit + low;
            cur = high % 10; //目前高位的个位
            high /= 10; //求目前高位的十位
            digit *= 10;
        }
        return res;
    }
```

#### [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

- 无符号右移

  ```java
      public int hammingWeight(int n) {
          int res = 0;
          while(n!=0){
              res += n&1;
              n>>>=1;  //无符号右移
          }
          return res;
      }
  ```

  

- 消除最右边的1

  ```java
      public int hammingWeight(int n) {
          int res = 0;
          while(n!=0){    //每一次循环都能消除最右边的1
              res++;
              n = n&(n-1);  //消除最右边的1
          }
          return res;
      }
  ```

#### [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

- 不考虑大数

  ```java
   public int[] printNumbers(int n) {
          int i = 0;
          int len = (int)Math.pow(10,n)-1;
          int[] res = new int[len];
          
          while(i < len){
              res[i] = i + 1;
              i++;
          }
  
          return res;
          
      }
  ```

- 考虑大数,全排列，递归回溯问题

  ```java
      //大数，要当做字符串处理，全排列问题
      //利用了额外空间，不用回溯
      int res[];
      int count = 0; //控制res
      char[] num;
      int n;
      public int[] printNumbers(int n) {
          this.n = n;
          res = new int[(int)Math.pow(10,n)-1];
          num = new char[n];
          dfs(0);
          return res;
      }
  
      //x表示当前位置
      public void dfs(int x){  //x表示当前位置
          if(x == n){
              String s = String.valueOf(num);
              int curNum = Integer.parseInt(s); //会自动把字符串前面无效的0去掉
              if(curNum!=0) res[count++] = curNum;
              return;
          }
  
          for(char i='0';i <='9';i++){
              num[x] = i;
              dfs(x+1);
          }
      }
  ```

### - 位运算

#### [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

利用位运算：将问题分解为【无进位加法+进位】

无进位加法：异或

进位：与运算后左移1（只是进位）

（和 s ）=（非进位和 n ）+（进位 c）。即可将 s=a+b转化为：s=a+b⇒s=n+c

循环求 n和 c ，直至进位 c=0；此时 s=n，返回 n 即可

不用考虑负数，负数是一样的

- 递归

  ```java
      public int add(int a, int b) {
          if(b==0) return a;
  
          return add(a^b, (a&b) << 1);
      }
  ```

- 迭代

  ```java
      //迭代
      public int add(int a, int b) {
          while(b != 0) { // 当进位为 0 时跳出
              int c = (a & b) << 1;  // c = 进位
              a ^= b; // a = 非进位和
              b = c; // b = 进位
          }
          return a;
      }
  ```

#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

- 寻找最右侧的1进行分组

  注意避坑：只是用了位运算但没有位移操作，得出的结果不是0或1

  ```java
      public int[] singleNumbers(int[] nums) {
          int n = 0; 
          int m = 1; //寻找最右侧的1
          int a = 0,b=0; //表示那两个数
          //n = a^b
          for(int num:nums){
              n ^= num;
          }
                  
          //由于a!=b!=0（等于0是必须每一位都为0），则必然有一位是1，我们可以先找到最右侧的1，将a和b进行分组
          //(a=1&&b=0)  || (a=0&&b=1)
  
          //m为找到最右侧的1的位置（a或者b中）
          while((n&m)==0){
              m <<= 1;
          }
  
          for(int num:nums){
              if((num&m)!=0){   
              // 没有位移操作，不能直接比1
              // 此处判断的两种情况相当于 num&m==m 和 num&m==0 而不是0和1
              // if((num&m)==1){
                  a ^= num; 
              }else{
                  b^=num;
              }
          }
  
          return new int[]{a,b};
      }
  ```

#### [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

- 遍历：统计每个位上1的个数count[]，对count模3，剩下的数即为所求

  ![](appendix\模3.png)

  ```java
      public int singleNumber(int[] nums) {
          int[] count = new int[32];
          //统计好每一位为1的数量
          for(int num:nums){
              for(int i=0;i<32;i++){
                  count[i] += num&1;
                  //num右移
                  num >>>=1; //此时在最低位,为了判断下一个高位，需要右移
              }
          }
  
          int res = 0,m=3;
          for(int i= 0;i<32;i++){
              res <<= 1;   //是因为下面的语句最先变的，为了不影响res
              res |= count[31-i] % m;  //或等 4|1 = 5;
          }
          return res;
      }
  ```

#### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

- 定义上下左右四个边界， “从左向右、从上向下、从右向左、从下向上” 四个方向循环

  ![](appendix\模拟打印.jpg)

  ```java
      public int[] spiralOrder(int[][] matrix) {
          if(matrix.length==0) return new int[0];
  
          //定义上下左右四个边界
          int l = 0,r = matrix[0].length-1, t = 0, b = matrix.length-1;
          int[] res = new int[(r+1)*(b+1)];
          int idx = 0;
          
          while(true){
              for(int i = l;i <= r;i++) res[idx++] = matrix[t][i];
              if(++t > b) break;
              for(int i = t;i <= b;i++) res[idx++] = matrix[i][r];
              if(--r < l) break;
              for(int i = r;i >=l ;i--) res[idx++] = matrix[b][i];
              if(--b < t) break;
              for(int i = b;i >=t ;i--) res[idx++] = matrix[i][l];
              if(++l > r) break;
          }
  
          return res;
      }
  ```

  



### -字符串

#### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

- 中心扩展法

  ```java
      //中心扩展法
      //从左到右，依次以字符为中心轴进行判断，双指针
      //但是要注意偶数长度的子串的遍历，并不是以某个字符为轴对称，需要将中心点由一个扩展到2个
      //例如：ababa
      //abab这个字符串并不是某个字符的中心点，无法遍历到，则无法判断是否是回文
  
      public int countSubstrings(String s) {
          int l = 0,r = 0;
          int count = 0;
          for(int i=0;i < s.length();i++){
              count += help(s,i,i);   //中心轴为一个字符（子串为奇数的长度）
              count += help(s,i,i+1); //中心轴为两个字符（子串为偶数的长度）
          }
          return count;
      }
  
      public int help(String s, int l, int r){
          int count = 0;
          while(l>=0 && r< s.length() && s.charAt(l)==s.charAt(r)){
              count++;
              l--;
              r++;
          }
          return count;
      }
  ```

#### [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

- 对字符进行分组

  我们可以将字符串 s按照 000 和 111 的连续段分组，存在 counts 数组中，例如 s=00111011，可以得到这样的 counts 数组：counts={2,3,1,2}。

  这里 counts 数组中两个相邻的数一定代表的是两种不同的字符。假设 counts 数组中两个相邻的数字为 u或者 v，它们对应着 u个 0和 v个 1，或者 u个 1 和 v个 0。它们能组成的满足条件的子串数目为 min⁡{u,v}，即一对相邻的数字对答案的贡献。

  ```java
   public int countBinarySubstrings(String s) {
          List<Integer> counts = new ArrayList<>();
          int index = 0;
          char pre = s.charAt(index);
          
          //先对连续的字符串进行分组
          //记录pre的方式
          int count = 0;
          // while(index < s.length()){
          //     char cur = s.charAt(index);
          //     if(pre==cur){
          //         count++;
          //     }else{
          //         counts.add(count);
          //         count = 1;
          //     }
          //     pre = cur;
          //     index++;
          // }
          // counts.add(count);
  
          //先对连续的字符串进行分组
          //双层循环的方式
          while(index < s.length()){
              char cur = s.charAt(index);
              count = 0;
              while(index < s.length() && s.charAt(index)==cur){
                  count++;
                  index++;
              }
              counts.add(count);
          }
  
          //再对分组数组取最小
          index = 0;
          int res = 0;
          while(index < counts.size()-1){
              res += Math.min(counts.get(index),counts.get(index + 1));
              index++;
          }
          return res;
  
      }
  ```

- 针对上一种方式的优化，利用滑动数组的思想

  ```java
      //优化：只关注上一个和当前的count的数目的最小值
      public int countBinarySubstrings(String s) {    
          int index = 0;
          int preCount = 0;
          int res = 0;
          while(index < s.length()){
              int count = 0; 
              char cur = s.charAt(index);
              while(index < s.length() && s.charAt(index)==cur){
                  count++;
                  index++;
              }
              res += Math.min(count,preCount);
              preCount=count;
          }
          return res;
           
      }
  ```

#### [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

- 利用双栈，操作栈，数字栈

- 两个坑：要注意加入和pop操作栈的时候，需要用循环的方式，因为这是保证从左往右的方式，而不是同级的放在最后从右向左计算，就会发生错误；第二个坑，要注意判断连续数字的时候，出循环后i会多1，要减掉。

  ```java
      public int calculate(String s) {
          //定义优先级
          HashMap<Character,Integer> priority = new HashMap<>();
          //定义数字栈和操作栈
          Stack<Integer> nums = new Stack<>();
          Stack<Character> ops = new Stack<>();
  
          //添加优先级
          priority.put('+',1);
          priority.put('-',1);
          priority.put('*',2);
          priority.put('/',2);
  
          //进行运算
          //处理字符串开头有负号的情况
          //题目要求非负，可以不加
          // s = '0' + s;
          //保证了同级运算中**从左到右**的顺序，不然会出错
          int i = 0;
          while(i < s.length()){
              // char cur = s.charAt(i);
  
              //处理空格
              if(s.charAt(i)==' ')  {
                  i++;
                  continue;
              }
              //读取一个连续的数字,并转为数字
              String tmp = "";
              // System.out.println("i"+ i+ "\tcur:"+ s.charAt(i));
              while(i<s.length() && s.charAt(i) >='0' && s.charAt(i) <='9'){
                  tmp += s.charAt(i);
                  // System.out.println("cur:"+ s.charAt(i) + "tmp:"+tmp +"\t");
                  i++;
                  //可能会多加一个1
              }
              // System.out.println("i"+ i + "tmp" + tmp);
              // System.out.println(nums + "  " + ops);
  
              if(!tmp.isEmpty()){
                  int num = Integer.parseInt(tmp);
                  nums.add(num);
                  // System.out.println("num:"+ num + "nums:"+nums +"\t");
              }else{ //操作符
                  // System.out.println("i: "+ i + "tmp: "+ tmp + " ops: " + ops + " cur:"+s.charAt(i) + "nums"+nums);
              //此处有大坑！！！注意，当操作符为统一级的时候，为了保证从左到右依次计算，应该用循环，将等于的操作都做完，再入栈
              //而不是简单的if判断，这样会导致同级运算一直被留在栈里，最后出栈的时候，同级运算变成从右向左了
                  // if(s.charAt(i)==' ')  {
                  //     i++;
                  //     continue;
                  // }
                  // // System.out.println("i: "+ i + "tmp: "+ tmp + " ops: " + ops + " cur:"+s.charAt(i) + "nums"+nums);
  
                  // if(!ops.isEmpty()){
                  //     if(priority.get(ops.peek()) < priority.get(s.charAt(i))){  //操作栈的优先级低
                  //         ops.add(s.charAt(i));
                  //     }else{  //操作栈的优先级高
                  //         operate(nums,ops);
                  //         ops.add(s.charAt(i));
                  //     }
                  // }else{ //操作栈为空直接加
                  //     ops.push(s.charAt(i));
  
                  while(!ops.isEmpty() && priority.get(ops.peek()) >= priority.get(s.charAt(i))){
                      operate(nums,ops);
                  }
                  ops.add(s.charAt(i));
              }
              if(tmp.isEmpty()){
                  i++;
              }
          }
  
          // System.out.println(nums + "  " + ops);
          while(!ops.isEmpty()){
              operate(nums,ops);
              // System.out.println(nums + "  " + ops);
          }
          return nums.pop();
      }
  
  
      //从双栈取数进行操作
      public void operate(Stack<Integer> nums,Stack<Character> ops){
          int num1 = nums.pop();
          int num2 = nums.pop();
          char op = ops.pop();
  
          if(op=='+'){
              nums.push(num2 + num1);
          }else if(op=='-'){
              nums.push(num2 - num1);
          }else if(op=='*'){
              nums.push(num2 * num1);
          }else{
              nums.push(num2 / num1);
          }
      }
  ```

#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

- KMP

  ```java
  // O(N)
      public int strStr(String haystack, String needle) {
          if(needle.isEmpty()) return 0;
  
          if (haystack == null ||  needle.length() < 1 || haystack.length() < needle.length()) {
              return -1;
          }
          
  
          char[] h = haystack.toCharArray(); //母串
          char[] n = needle.toCharArray(); //子串
  
          int x = 0; //母串下标
          int y = 0; //子串下标
          
          //O(N)
          int[] next = getNext(n);
          while(x < h.length && y < n.length){
              if(h[x] == n[y]){
                  x++;
                  y++;
              }else if(next[y]==-1){  //y = 0;
                  x++; 
              }else{
                  y = next[y];
              }
          }
  
          return y==n.length? x-y : -1;
  
      }
  
      //只和子串有关
      public int[] getNext(char[] n){
          if(n.length==1) return new int[]{-1};
  
          int[] next = new int[n.length];
          next[0] = -1;
          next[1] = 0;
          int index = 2;
          int cn = 0;  //当前需要比较的位置，同时也是值
          while(index < n.length){
              if(n[index-1] == n[cn]){   //注意此处是index-1,因为前一个就不包含他本身
                  next[index++] = ++cn;  //此处是++cn
              }else if(cn > 0){  //为什么没有等  cn=0的时候是-1
                  cn = next[cn];
              }else{
                  next[index++] = 0;  //没有前后缀是0
              }
          }
          
          return next;
      }
  
  ```

#### [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

- 从左向右递归

  ```java
      public int translateNum(int num) {
          if(num==0) return 1;
          String str = String.valueOf(num);
          char[] strs = str.toCharArray();
          return dfs(strs,0);
      }
  
      //i之前的位置，如何转化已经做过决定了
  	//i...有多少种转化结果
      public int dfs(char[] nums, int i){
          if(i==nums.length)  //最后一位的下一位
              return 1;
      
          if(nums[i]=='0'){
              return dfs(nums,i+1);
          }else if(nums[i]=='1'){
              int res = dfs(nums,i+1);
              if(i+1 < nums.length){
                  res += dfs(nums,i+2);
              }
              return res;
          }else if(nums[i]=='2'){
              int res = dfs(nums,i+1);
              if(i+1<nums.length && nums[i+1] <= '5' ){
                  res += dfs(nums,i+2);
              }
              return res;
          }else{//‘3’-‘9’的情况
              return dfs(nums,i+1);
          }
      }
  ```

- 动态规划

  ```java
      //动态规划
      //滑动数组
      public int translateNum(int num) {
          if(num==0) return 1;
          String str = String.valueOf(num);
          int a = 1; //记录i-1
          int b = 1; //记录i-2
          for(int i=2;i < str.length();i++){
              String tmp = str.substring(i-2,i);
              int c = tmp.compareTo("10")>=0 && tmp.compareTo("25")<=0? a+b:a;  //compareTo返回的是前-后的值
              b=a;
              a=c;
          }
          return a;
      }
  ```

#### [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

- 暴力

  ```java
      public int lengthOfLongestSubstring(String s) {
          if(s.isEmpty()) return 0;
          if(s.length()==1) return 1;
  
          char[] str = s.toCharArray();
          int max = Integer.MIN_VALUE;
          //控制窗口左
          for(int i=0; i < str.length;i++){
              int res = 0;
              int flag = 0;
              //控制右
              for(int j = i+1;j < str.length;j++){
                  //判断当前数是否能加入窗口
                  for(int k = j-1;k>=i;k--){
                      if(str[k]==str[j] ){
                          flag = 1;
                          break;
                      }
                  }
                  if(flag==1) {
                      break;
                  }else {
                      res++;
                  }
              }
              max = Math.max(max,res+1);
  
          }
          return max;
      }
  ```

  

- 可变滑动窗口

  ```java
      //可变滑动窗口，左开右闭！！！
      //(start,i]
      public int lengthOfLongestSubstring(String s) {
          int start = -1; //滑动窗口起始
          int max = 0;
  
          //定义hashmap，用于存放该字符最后一个索引值
          HashMap<Character,Integer> map = new HashMap<>();
  
          for(int i=0;i<s.length();i++){
              char cur = s.charAt(i);
              if(map.containsKey(cur)){
                  //取最大是因为会出现abba的情况，不取大，则start又等于0了
                  start = Math.max(map.get(cur),start);
              }
              map.put(cur,i);
              max = Math.max(max,i-start);
          }
          return max;
      }
  ```

#### [剑指 Offer 67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

- 大数越界处理

  思路：

  - 首部空格： 删除之即可；

  - 符号位： 三种情况，即 ''+++'' , ''−-−'' , ''无符号" ；新建一个变量保存符号位，返回前判断正负即可。

  - 非数字字符： 遇到首个非数字的字符时，应立即返回。
    数字字符：
  
  - 数字字符：
  
    - 字符转数字： “此数字的 ASCII 码” 与 “ 000 的 ASCII 码” 相减即可；
            
  
    - 数字拼接： 若从左向右遍历数字，设当前位字符为 c ，当前位数字为 x ，数字结果为 res ，则数字拼接公式为：
  
      x =  c - '0';
  
      res = res *10 + x;
  
  - 大数越界处理：int合理范围是
  
    -2147483648~2147483647
  
    在判断是否越界时，不能直接用这种方式（if(res *10 + (cs[idx]-'0') > Integer.MAX_VALUE)），当输入为2147483648，系统会判定为res *10 + (cs[idx]-'0') = -2147483648, 成负的

  ```java
      public int strToInt(String str) {
          char[] cs = str.trim().toCharArray();
          if(cs.length==0) return 0;
  
          int idx = 0, sign = 1; //下标和符号位
          if(cs[0]=='-'){
              sign = -1;
              idx =1;
          }else if(cs[0]=='+'){
              idx++;
          }
          int res = 0;
          int max_int_boundary = Integer.MAX_VALUE/10;
          while(idx < cs.length){
              if(cs[idx] < '0' || cs[idx] > '9'){
                  break;
              }
              //到这的res还没有加 
              //注意这个边界条件
              //此处其实也考虑了负数
              if(res > max_int_boundary || (res==max_int_boundary && cs[idx] > '7')){
              //不能直接用这种方式，系统会判定为res *10 + (cs[idx]-'0') = -2147483648,成负的
              // if(res *10 + (cs[idx]-'0') > Integer.MAX_VALUE){
                  if(sign==1){
                      return Integer.MAX_VALUE;
                  }else{
                      return Integer.MIN_VALUE;
                  }
              }
  
              res = res *10 + (cs[idx]-'0');
              idx++;
          }
          return sign*res;
      }
  ```

#### [剑指 Offer 20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

- 多条件判断

  ```java
   public boolean isNumber(String s) {
          //base case
          if(s==null || s.length()==0) return false;
          //标志位
          boolean isDot = false,isE = false, isNum = false;
          //去空格，转为数组
          char[] arr = s.trim().toCharArray();
          //从左往右遍历开始判断
          for(int i = 0;i < arr.length;i++){
              char tmp = arr[i];
              //遇到了数字
              if(tmp >= '0' && tmp <= '9'){
                  isNum = true;
              //遇到了点，注意点和e不能同时出现，e只能和整数一起
              }else if(tmp == '.'){
                  if(isDot || isE) {
                      return false;
                  }
                  isDot = true;
              //出现E，则前面必须有整数，不能重复出现e
              }else if(tmp=='e'||tmp=='E'){
                  if(!isNum || isE) {
                      return false;
                  }
                  isE = true;
                  //e的后面需要一个整数，所以重置
                  isNum = false;
              }else if(tmp == '+' || tmp == '-'){
                  //出现正负号，如果不是在首位，则必须在e之后，否则不符合
                  if(i != 0 && arr[i-1] != 'e' && arr[i-1] != 'E'){
                      return false;
                  }
              //出现其他的奇怪的字符
              }else{
                  return false;
              }
          }
          //其他情况返回isNum,而不是true,比如12e的情况
          return isNum;
      }
  ```

#### [剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

- [动态规划](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/)

  - 解题思路

  假设主串为 A，模式串为 B 从最后一步出发，需要关注最后进来的字符。假设 A的长度为 n ，B 的长度为 m ，关注正则表达式 B的最后一个字符是谁，它有三种可能，正常字符、∗ 和 .（点），那针对这三种情况讨论即可，如下：

      如果 B的最后一个字符是正常字符，那就是看 A[n−1]是否等于 B[m−1]B，相等则看A_{0..n-2} 与B_{0..m-2}，不等则是不能匹配，这就是子问题。
      
      如果 B的最后一个字符是.，它能匹配任意字符，直接看 A_{0..n-2}与 B_{0..m-2}
      
      如果 B 的最后一个字符是*它代表 B[m−2]=c,可以重复0次或多次，它们是一个整体 c∗
          情况一：A[n−1]是 0个 c，B最后两个字符废了，能否匹配取决于 A_{0..n-1}和 B_{0..m-3}是否匹配
          情况二：A[n−1] 是多个 c中的最后一个（这种情况必须 A[n−1]=c 或者 c=′.′），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A_{0..n-2} 和B_{0..m-1}是否匹配。

  - 转移方程

  f[i] [j]代表 A 的前 i个和 B的前 j个能否匹配

      对于前面两个情况，可以合并成一种情况 f[i][j]=f[i−1][j−1]
      
      对于第三种情况，对于 c∗ 分为看和不看两种情况
          不看：直接砍掉正则串的后面两个， f[i][j]=f[i][j−2]
          看：正则串不动，主串前移一个，f[i][j]=f[i−1][j]

  - 初始条件

  特判：需要考虑空串空正则

      空串和空正则是匹配的，f[0][0]=true
      空串和非空正则，不能直接定义 true和 false，必须要计算出来。（比如A= '' ,B=a∗b∗c∗）
      非空串和空正则必不匹配，f[1][0]=...=f[n][0]=false
      非空串和非空正则，那肯定是需要计算的了。

  大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 ∗ 和不是 ∗ 两种情况了。
  结果

  我们开数组要开 n+1 ，这样对于空串的处理十分方便。结果就是f\[n\]\[m\]
  
  - 代码
  
  ```java
      //动态规划
      //只关注最后进来的字符
      //注意区别方程和本身索引的差别
      public boolean isMatch(String s, String p) {
          int n = s.length(); 
          int m = p.length();
          //矩阵默认值为false
          boolean[][] f = new boolean[n+1][m+1];   //f[i][j]表示，s[0...i-1]和p[0...j-1]是否匹配
  
          //加等于时为了处理空串
          for(int i = 0;i <= n; i++){
              for(int j = 0;j <= m; j++){
                  //空正则
                  if(j==0){
                      f[i][j] = i==0 ;  //true
                  }else{
                      //非空正则分为两个情况，*和非*
                      if(p.charAt(j-1)!='*'){ //当正则的最后一个字符不是*时
                          if(i > 0 && (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1)=='.')){
                              f[i][j] = f[i-1][j-1]; //结果取决于s[0..i-2]和p[0...j-2]
                          }
                      }else{  //是*
                          //不看，当没有
                          if(j >= 2){
                              f[i][j] |= f[i][j-2];   //用或等是因为f[i][j]有两种情况，只要有一种情况为true，结果就会为true
                          }
                          //看
                          if(i>=1 && j>=2 && (s.charAt(i-1)==p.charAt(j-2) || p.charAt(j-2)=='.'))
                              f[i][j] |= f[i-1][j]; 
                      }
                       
                  }
              }
          }
          //如果写成return f[n-1][m-1]，则为空串时不好处理，越界
          return f[n][m];
      }
  ```



### - BFS

#### [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)(多源最短路模板)

- bfs

  多源最短路问题：添加超级源点，将多源最短路转为单源最短路

  （1）多次单源BFS
  通过对每个water进行BFS搜索，得到一组nearest lands，然后从中寻找max。

  （2）一次多源BFS
  在多次单源BFS中，每个water都是相互独立的，那么能否通过添加一个超级节点将所有单源节点连接起来，这样就是的问题转换成了一次单源BFS。

  注意：当添加了超级节点后，超级节点的扩散方式并不是上下左右，而是相连的都扩散出去，且距离=0。这在算法如何实现？
  只要手动完成即可，即让超级节点连接的所有节点，先都进入队列中，就完成了扩散。


  套路：（反着来就行了，反正我搞不懂了）

* **求每个位置到最近的0的距离，超级源点是1，把所有0入队列，则第一步就都会到达最近的0**

  求每个位置到最近的1的距离，超级源点是0，把所有1入队列，则第一步就都会到达最近的1

  ```java
      public int[][] updateMatrix(int[][] mat) {
          LinkedList<int[]> q = new LinkedList<>();
  
          //遍历矩阵，将0的全部由超级源点链接起来，向四周扩散
          //并标志原本的1的位置为-1，和之后的距离值区别开来
          //因为这部分是要用源空间进行保存
          for(int i = 0 ; i < mat.length;i++){
              for(int j = 0; j < mat[0].length;j++){
                  if(mat[i][j]==0){
                      q.add(new int[]{i,j});
                  }else{
                      mat[i][j] = -1;
                  }
              }
          }
  
          //进行单源最短路径的搜索
          //bfs，并记录距离，层级
          int[] x = {-1,1,0,0};
          int[] y = {0,0,-1,1};
          int step = 1;
          while(!q.isEmpty()){
              int size = q.size();  //每一轮都会变
              for(int i = 0;i < size; i++){
                  int[] cur = q.remove();
                  for(int j = 0;j < 4;j++){
                      int newx = cur[0] + x[j];
                      int newy = cur[1] + y[j];
                      //摆脱边界
                      //以及记录过的就不再进行记录 >0
                      //step为0 的情况不用处理
                      if(newx < 0|| newy < 0 || newx >= mat.length || newy >= mat[0].length  || mat[newx][newy] >= 0 ){
                          continue;
                      } 
                      mat[newx][newy] = step;
                      q.add(new int[]{newx,newy});
                  }
              }
              //下次遍历到的-1相比前一次的距离step+1
              step++;
          }
          return mat;
      }
  ```

- 动态规划

  ```java
      //动态规划
      // 状态：dp[i][j]，表示i,j位置上距离0的最小值
      // 状态转移方程：
      //     从左上到右下（往下和往右）+ 从右下到坐上（往上和往左），四个方向都搜索到了
      //     if(mat[i][j]==0) dp[i][j] = 0;
  
      //     从左上到右下（往下和往右）
  	//	   相当于是把min记录下来了
      //     if (i-1 >= 0) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1);
      //     if (j-1 >= 0) dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);
          
      //     从右下到坐上（往上和往左）
      //     if (i+1 < mat.length) dp[i][j] = Math.min(dp[i][j], dp[i+1][j] + 1);
      //     if (j+1 < mat[0].length) dp[i][j] = Math.min(dp[i][j], dp[i][j+1] + 1);
  
      // 初始状态：dp[i][j] = 0;
      // 结果：dp
  
      static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
  
      public int[][] updateMatrix(int[][] matrix) {
          int m = matrix.length, n = matrix[0].length;
          // 初始化动态规划的数组，所有的距离值都设置为一个很大的数
          int[][] dist = new int[m][n];
          for (int i = 0; i < m; ++i) {
              Arrays.fill(dist[i], Integer.MAX_VALUE / 2);
          }
          // 如果 (i, j) 的元素为 0，那么距离为 0
          for (int i = 0; i < m; ++i) {
              for (int j = 0; j < n; ++j) {
                  if (matrix[i][j] == 0) {
                      dist[i][j] = 0;
                  }
              }
          }
          // 只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序
          for (int i = 0; i < m; ++i) {
              for (int j = 0; j < n; ++j) {
                  if (i - 1 >= 0) {
                      dist[i][j] = Math.min(dist[i][j], dist[i - 1][j] + 1);
                  }
                  if (j - 1 >= 0) {
                      dist[i][j] = Math.min(dist[i][j], dist[i][j - 1] + 1);
                  }
              }
          }
          // 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序
          for (int i = m - 1; i >= 0; --i) {
              for (int j = n - 1; j >= 0; --j) {
                  if (i + 1 < m) {
                      dist[i][j] = Math.min(dist[i][j], dist[i + 1][j] + 1);
                  }
                  if (j + 1 < n) {
                      dist[i][j] = Math.min(dist[i][j], dist[i][j + 1] + 1);
                  }
              }
          }
          return dist;
      }
  ```

- 二刷

  ```java
  //bfs
      LinkedList<int[]> q = new LinkedList<>();
      public int[][] updateMatrix(int[][] mat) {
  
          for(int i=0;i<mat.length;i++){
              for(int j = 0;j<mat[0].length;j++){
                  //超级源点是1，把所有0都添加进去
                  if(mat[i][j]==0){
                      q.offer(new int[]{i,j});
                  }else{
                      mat[i][j] = -1;
                  }
              }
          }
          bfs(mat);
          return mat;
      }
  
      public void bfs(int[][]mat){
          int[] dx = {-1,1,-0,0};
          int[] dy = {0,0,-1,1};
  
          int depth = 1;
          while(!q.isEmpty()){
              int len = q.size();
              for(int i = 0;i<len;i++){
  
                  int[] cur = q.poll();
                  
                  for(int k=0;k < 4;k++){
                      int x = cur[0] + dx[k];
                      int y = cur[1] + dy[k];
                      if(x<0 || x>=mat.length || y<0 ||y>=mat[0].length) continue;
                      if(mat[x][y]==-1){
                          mat[x][y] = depth;
                          q.offer(new int[]{x,y});
                      }else{
                          continue;
                      }
                  }
              }
              depth++;
          }
      }
  ```

- 动态规划

  ```java
      public int[][] updateMatrix(int[][] mat) {
          int m = mat.length;
          int n = mat[0].length;
          int[][] dp = new int[m][n];
  
          for(int i = 0;i < m;i++){
              for(int j=0;j < n;j++){
                  dp[i][j] = mat[i][j]==0?0:Integer.MAX_VALUE/2;
              }
          }
          
          //左上到右下
          for(int i = 0;i < m;i++){
              for(int j=0;j < n;j++){
                  if(i-1 >= 0){
                      dp[i][j] = Math.min(dp[i-1][j]+1,dp[i][j]);
                  }
                  if(j-1>=0){
                      dp[i][j] = Math.min(dp[i][j-1]+1,dp[i][j]);
                  }
              }
          }
  
          //右上到左下
          for(int i = m-1;i>=0;i--){
              for(int j = n-1;j>=0;j--){
                  if(i+1 < m){
                      dp[i][j] = Math.min(dp[i+1][j]+1,dp[i][j]);
                  }
                  if(j+1 < n){
                      dp[i][j] = Math.min(dp[i][j+1]+1,dp[i][j]);
                  }
              }
          }
          return dp;
      }
  ```

  





# 模板归类

# 数组

### 快慢指针

### 1. 原地修改元素

#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

```java
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null) return null;

        ListNode slow = head, fast = head;
        while(fast!=null){
            //不相等则赋值
            if(slow.val!=fast.val){
                slow.next = fast;
                slow = slow.next;
            }
            fast = fast.next;
        }

        //注意把不符合条件的断开
        slow.next = null;
        return head;
        
    }
```

```java
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null) return head;
        ListNode slow = head,fast = head.next;
        while(fast!=null){
            if(slow.val==fast.val){
                fast = fast.next;
            }else{
                slow.next = fast;
                slow = slow.next;
                fast = fast.next;
            }
        }
        //最后fast必为空
        slow.next = fast;
        return head;
    }
```



#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

-   不交换

```java
    public void moveZeroes(int[] nums) {
        int left = 0, right = 0;
        while(right < nums.length){
            if(nums[right]!=0){
                nums[left] = nums[right];
                left++;
            }
            right++;
        }

        while(left < nums.length){
            nums[left] = 0;
            left++;
        }
    }
```

```java

        //不交换快了很多
    public void moveZeroes(int[] nums) {
        //不用cnt直接用valid也可以
        int len = nums.length;
        int valid = -1;
        int idx = 0;
        int cnt = 0;
        while(idx < len){
            if(nums[idx]==0){
                idx++;
                cnt++;
            }else{
                nums[++valid] = nums[idx++];
                // swap(nums,idx++,++valid);
            }
        }

        for(int i = len-1;i>=len-cnt;i--){
            nums[i] = 0;
        }

    }
```



-   交换

```java
    //一次快排，交换可能比较浪费时间
    public void moveZeroes(int[] nums) {
        int len = nums.length;
        int valid = -1;
        int idx = 0;
     
        while(idx < len){
            if(nums[idx]==0){
                idx++;
            }else{
                swap(nums,idx++,++valid);
            }
        }

    }

    public void swap(int[] nums,int i,int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
```





### 2.滑动窗口

#### *[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)（hashmap放子串字符词频）

```java
public String minWindow(String s, String t) {
        //思路：
        //先不断地扩大窗口，直到窗口中的字符串符合要求（包含了T中的所有字符）
        //指针缩小窗口,直到窗口中的字符串不符合要求，每次缩小窗口，我们都要更新一轮结果

        //定义变量
        HashMap<Character,Integer> need = new HashMap<>();  //总结t中我们需要的字符以及数量
        HashMap<Character,Integer> windows = new HashMap<>(); //查看窗口中对应的字符以及数量
        int valid = 0; //要求一个字符的所有数量是否在窗口内
        int left = 0, right = 0; //滑动窗口，左闭右开
        int start = 0,minlen = Integer.MAX_VALUE; //记录结果

        //初始化
        for(int idx = 0; idx < t.length(); idx++){
            need.put(t.charAt(idx),need.getOrDefault(t.charAt(idx),0) + 1);
        }

        //滑动窗口
        while(right < s.length()){
            //当前移入窗口的字符
            char c = s.charAt(right);
            //右移窗口
            right++;
            //窗口内的更新操作
            if(need.containsKey(c)){
                windows.put(c,windows.getOrDefault(c,0) + 1);

                if(windows.get(c).equals(need.get(c))){
                    valid++;
                }
            }


            //判断窗口是否要收缩
            //注意此处用的循环
            while(valid == need.size()){
                //先更新结果,在此处更新结果！！！
                if(right - left < minlen){ //因为是左闭右开，所以窗口的长度为rigth-left
                    start = left;
                    minlen = right-left;
                }

                //当前要移除窗口的元素
                char d = s.charAt(left);
                //缩小窗口
                left++;
                //窗口内的更新操作
                if(need.containsKey(d)){
                    // if(need.containsKey(d) && windows.containsKey(d)){  //其实前面保证了d一定在窗口里
                    //有效字符减少
                    if(need.get(d).equals(windows.get(d))){
                        valid--;
                    }
                    windows.put(d,windows.get(d) - 1);
                }
            }
        }

        return minlen == Integer.MAX_VALUE ? "" : s.substring(start, start + minlen);
    }
```

踩过坑以后，才知道上述方法是写的最好的

```java
public String minWindow(String s, String t) {
        if(t.length()>s.length()) return "";
        //思路：
        //先不断地扩大窗口，直到窗口中的字符串符合要求（包含了T中的所有字符）
        //指针缩小窗口,直到窗口中的字符串不符合要求，每次缩小窗口，我们都要更新一轮结果

        //定义变量
        //不能直接对need进行操作，如果字符串中包含多个A，但我们只需要1个，need的增加和减少会出错
        //所以必须要windows记录数字的次数
        HashMap<Character,Integer> need = new HashMap<>();  //总结t中我们需要的字符以及数量
        HashMap<Character,Integer> windows = new HashMap<>(); //查看窗口中对应的字符以及数量
        int valid = 0; //要求一个字符的所有数量是否在窗口内
        int left = 0, right = 0; //滑动窗口，左闭右开
        // String min = s; //记录结果，这种处理的特殊情况太多了
        int start = 0,minlen = Integer.MAX_VALUE; //记录结果

        //初始化
        for(int idx = 0; idx < t.length(); idx++){
            need.put(t.charAt(idx),need.getOrDefault(t.charAt(idx),0) + 1);
        }

        //滑动窗口
        while(right < s.length()){
            //当前移入窗口的字符
            System.out.println("begin:" + right);
            char c = s.charAt(right);
            //右移窗口
            right++;
            //窗口内的更新操作
            if(need.containsKey(c)){
                windows.put(c,windows.getOrDefault(c,0) + 1);

                if(windows.get(c).equals(need.get(c))){
                    valid++;
                }
            }


            //判断窗口是否要收缩
            //注意此处用的循环
            while(valid == need.size()){
                //先更新结果,在此处更新结果！！！
                // System.out.println("low:"+left+"\thigh:"+right + "\tvalid:"+valid + "\tneed:"+need +"\twindows:"+windows+ "\tstring:" +s.substring(left,right));
                if(right - left < minlen){ //因为是左闭右开，所以窗口的长度为rigth-left
                    start = left;
                    minlen = right-left;
                }

                //当前要移除窗口的元素
                char d = s.charAt(left);
                //缩小窗口
                left++;
                //窗口内的更新操作
                if(need.containsKey(d)){
                    //有效字符减少
                    if(need.get(d).equals(windows.get(d))){
                        valid--;
                    }
                    windows.put(d,windows.get(d) - 1);
                }
            }
        }
    
        return minlen == Integer.MAX_VALUE ? "" : s.substring(start, start + minlen);
    }
```





#### *[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)（hashmap放子串字符词频）

**由于判断是子串，代表s1中的字符必须相邻，利用窗口长度去控制就可以**

```java
public boolean checkInclusion(String s1, String s2) {
        //思路：
        //先不断地扩大窗口，直到窗口中的字符串符合要求（包含了T中的所有字符）
        //指针缩小窗口,直到窗口中的字符串不符合要求，每次缩小窗口，我们都要更新一轮结果
        //由于判断是子串，代表s1中的字符必须相邻，利用窗口长度去控制就可以

        //定义变量
        HashMap<Character,Integer> need = new HashMap<>();  //总结t中我们需要的字符以及数量
        HashMap<Character,Integer> windows = new HashMap<>(); //查看窗口中对应的字符以及数量
        int valid = 0; //要求一个字符的所有数量是否在窗口内
        int left = 0, right = 0; //滑动窗口，左闭右开

        //初始化
        for(int idx = 0; idx < s1.length(); idx++){
            need.put(s1.charAt(idx),need.getOrDefault(s1.charAt(idx),0) + 1);
        }

        //滑动窗口
        while(right < s2.length()){
            //当前移入窗口的字符
            char c = s2.charAt(right);
            //右移窗口
            right++;
            //窗口内的更新操作
            if(need.containsKey(c)){
                windows.put(c,windows.getOrDefault(c,0) + 1);

                if(windows.get(c).equals(need.get(c))){
                    valid++;
                }
            }


            //判断窗口是否要收缩
            //
            while(right - left >= s1.length()){
                //先更新结果,在此处更新结果！！！
                if(valid == need.size()){ //因为是左闭右开，所以窗口的长度为rigth-left
                    return true;
                }

                //当前要移除窗口的元素
                char d = s2.charAt(left);
                //缩小窗口
                left++;
                //窗口内的更新操作
                if(need.containsKey(d)){
                    // if(need.containsKey(d) && windows.containsKey(d)){  //其实前面保证了d一定在窗口里
                    //有效字符减少
                    if(need.get(d).equals(windows.get(d))){
                        valid--;
                    }
                    windows.put(d,windows.get(d) - 1);
                }
            }
        }
        return false;
    }
```

-   注意是需要滑动窗口的

```java
    public boolean checkInclusion(String s1, String s2) {
        //本以为这题不需要滑动窗口，但是还是需要
        //s1 = "adc",s2 = "dcda"
        HashMap<Character,Integer> need = new HashMap<>();
        HashMap<Character,Integer> windows = new HashMap<>();
        int valid = 0;

        for(int i =0;i < s1.length();i++){
            char c = s1.charAt(i);
            need.put(c,need.getOrDefault(c,0)+1);
        }

        int low = 0,high = 0;
        while(high < s2.length()){
            char c = s2.charAt(high);
            high++;
            if(need.containsKey(c)){
                windows.put(c,windows.getOrDefault(c,0)+1);

                if(windows.get(c).equals(need.get(c))){
                    valid++;
                }
            }

            // while((high-low)==s1.length()){
            //     if(valid==need.size()){
            while(valid==need.size()){
                // System.out.println("low:"+low+"\thigh:"+high + "\tvalid:"+valid + "\tneed:"+need +"\twindows:"+windows+ "\tstring:" +s2.substring(low,high));
                if((high-low)==s1.length()){
                    return true;
                }

                char d = s2.charAt(low);
                low++;
                if(need.containsKey(d)){
                    //因为不能剪别人的valid
                    if(need.get(d).equals(windows.get(d))){
                        valid--;
                    }
                    windows.put(d,windows.get(d)-1);
                }
            }
        }
        return false;
    }
```





#### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)（hashmap放子串字符词频）

```java
    public List<Integer> findAnagrams(String s2, String s1) {
        //思路：
        //先不断地扩大窗口，直到窗口中的字符串符合要求（包含了T中的所有字符）
        //指针缩小窗口,直到窗口中的字符串不符合要求，每次缩小窗口，我们都要更新一轮结果
        //由于判断是子串，代表s1中的字符必须相邻，利用窗口长度去控制就可以

        //定义变量
        HashMap<Character,Integer> need = new HashMap<>();  //总结t中我们需要的字符以及数量
        HashMap<Character,Integer> windows = new HashMap<>(); //查看窗口中对应的字符以及数量
        int valid = 0; //要求一个字符的所有数量是否在窗口内
        int left = 0, right = 0; //滑动窗口，左闭右开
        List<Integer> res = new ArrayList<>();

        //初始化
        for(int idx = 0; idx < s1.length(); idx++){
            need.put(s1.charAt(idx),need.getOrDefault(s1.charAt(idx),0) + 1);
        }

        //滑动窗口
        while(right < s2.length()){
            //当前移入窗口的字符
            char c = s2.charAt(right);
            //右移窗口
            right++;
            //窗口内的更新操作
            if(need.containsKey(c)){
                windows.put(c,windows.getOrDefault(c,0) + 1);

                if(windows.get(c).equals(need.get(c))){
                    valid++;
                }
            }


            //判断窗口是否要收缩
            //
            while(right - left >= s1.length()){
                //先更新结果,在此处更新结果！！！
                if(valid == need.size()){ //因为是左闭右开，所以窗口的长度为rigth-left
                    res.add(left);
                }

                //当前要移除窗口的元素
                char d = s2.charAt(left);
                //缩小窗口
                left++;
                //窗口内的更新操作
                if(need.containsKey(d)){
                    // if(need.containsKey(d) && windows.containsKey(d)){  //其实前面保证了d一定在窗口里
                    //有效字符减少
                    if(need.get(d).equals(windows.get(d))){
                        valid--;
                    }
                    windows.put(d,windows.get(d) - 1);
                }
            }
        }
        return res;
    }
```

#### *[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)（hashmap存索引值）和剑指offer48一样

和普通的滑动窗口不太一样，不能直接套模板，但思考的问题差不多

hashmap存放索引值

```java
    public int lengthOfLongestSubstring(String s) {
        //思路：
        //1，左闭右开，hashmap中放的是索引值而不是单纯的次数
        //2，扩大right
        //3，left缩小窗口的时候，要注意不是单纯的left++，要判断当前left的位置和这个字符上一次出现的索引+1的大小，考虑abba和pwwkew的情况
        //4，结果在缩小窗口之后
        //5，更新添加的hashmap的位置

        //定义变量
        HashMap<Character,Integer> windows = new HashMap<>(); //记录的是上个字符的索引值
        int left = 0, right = 0; //滑动窗口，左闭右开
        int maxlen = Integer.MIN_VALUE;

        //滑动窗口
        while(right < s.length()){
            //当前移入窗口的字符
            char c = s.charAt(right);

            //右移窗口
            right++;

            //判断窗口是否要收缩
            if(windows.containsKey(c)){
                //左移窗口
                // left = windows.get(c)+1;   //这块一定要取更大的那个，而不是单纯的left++，
                //这块不是单纯的left++，移得不止一格 例子：pwwkew
                //不是单纯的windows.get(c)+1，因为存在 abba的情况，当判断到a时，该值为1，但left已经在2了
                left = Math.max(left,windows.get(c)+1);   
            }
            //更新结果
            maxlen = Math.max(right-left, maxlen);
            windows.put(c, right-1);
            

        }
        return maxlen==Integer.MIN_VALUE?0:maxlen;
    }
```

-   我tm是真不理解，调了好久，才调出来

    滑动窗口的题一定要注意什么时候扩大，什么时候缩小，什么时候记录答案

```java
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character,Integer> windows = new HashMap<>();
        int low = 0,high = 0;
        int maxlen = 0;
        boolean flag = false;

        while(high < s.length()){
            //扩大窗口
            char c = s.charAt(high);
            
            high++;
            if(!windows.containsKey(c) || windows.get(c)==0){
                maxlen = Math.max(maxlen,high-low);
            }
            windows.put(c,windows.getOrDefault(c,0)+1);
            // System.out.println("low:"+low+"\thigh:"+high+"\tmaxlen:"+maxlen+"\ts:"+s.substring(low,high)+"\tc:"+c+"\twindows:"+windows);
            

            while(duplication(windows)){
                flag = true;
                char d = s.charAt(low);
                low++;
                if(windows.containsKey(d)){
                    windows.put(d,windows.get(d)-1);
                }

            }
        }
        return maxlen;
    }

    public boolean duplication(HashMap<Character,Integer> windows){
        for(char key:windows.keySet()){
            if(windows.get(key) > 1){
                return true;
            }
        }
        return false;
    }
```





### 左右指针

### 1. 二分查找

#### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

```java
    public int search(int[] nums, int target) {
        if(nums==null) return -1;

        int left = 0, right = nums.length-1;

        while(left<=right){
            int mid = left + ((right-left)>>1);
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }

        return -1;
    }
```

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

先找左边界，再找右边界

```java
  public int[] searchRange(int[] nums, int target) {
        //处理特殊值
        if(nums==null || nums.length < 1) return new int[]{-1,-1};

        int[] res = {-1,-1};
        //左右指针
        int left = 0,right = nums.length-1;
        //先找左位置
        while(left <= right){
            int mid = left + ((right-left)>>1);
            if(nums[mid]==target){
                right = mid - 1;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else{
                right = mid -1;
            }
        }

        if (left >= nums.length || nums[left] != target) {
            res[0] = -1;
        }else{
            res[0] = left;
        }

        //再找右边界
        left = 0;
        right = nums.length-1;
        while(left <= right){
            int mid = left + ((right-left)>>1);
            if(nums[mid]==target){
                left = mid + 1;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else{
                right = mid -1;
            }
        }

        if (right < 0 || nums[right] != target) {
            res[1] = -1;
        }else{
            res[1] = right;
        }

        return res;
    }
```

与此题一样，仅返回值不同

#### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

统计一个数字在排序数组中出现的次数。

### 2. 其他

#### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

```java
    public int[] twoSum(int[] numbers, int target) {
        int left = 0,right = numbers.length-1;
        int[] res = {-1,-1};
        while(left <= right){
            if(numbers[left] + numbers[right]==target){
                res[0] = left + 1;
                res[1] = right + 1;
                return res;
            }else if(numbers[left] + numbers[right] > target){
                right--;
            }else{
                left++;
            }
        }
        return res;
    }
}
```

#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```java
    public void reverseString(char[] s) {
        int left = 0,right = s.length-1;
        while(left < right){
            swap(s,left++,right--);
        }
    }

    public void swap(char[]s,int i,int j){
        char t = s[i];
        s[i] =  s[j];
        s[j] = t;
    }
```

### 3. 中心扩展法

#### *[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

```java
    //中心扩展法
    //从左到右，依次以字符为中心轴进行判断，双指针
    //但是要注意偶数长度的子串的遍历，并不是以某个字符为轴对称，需要将中心点由一个扩展到2个
    //例如：ababa
    //abab这个字符串并不是某个字符的中心点，无法遍历到，则无法判断是否是回文

    public int countSubstrings(String s) {
        int count = 0;
        for(int i=0;i < s.length();i++){
            count += help(s,i,i);   //中心轴为一个字符（子串为奇数的长度）
            count += help(s,i,i+1); //中心轴为两个字符（子串为偶数的长度）
        }
        return count;
    }

    public int help(String s, int l, int r){
        int count = 0;
        while(l>=0 && r< s.length() && s.charAt(l)==s.charAt(r)){
            count++;
            l--;
            r++;
        }
        return count;
    }
```

```java
    public int countSubstrings(String s) {
        int sum = 0;
        for(int i = 0;i < s.length();i++){
            sum += help(s,i,i);
            // if(i+1 < s.length()){，在代码里也会排除掉
            sum += help(s,i,i+1);
        }

        return sum;
    }

    public int help(String s,int i,int j){
        int cnt = 0;
        
        while(i >= 0 && j <= s.length()-1 && s.charAt(i)==s.charAt(j)){
            cnt++;
            //只有相等的时候才更新i和j的值
            i--;
            j++;
            
        }
        return cnt;
    }
```





#### *[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```java
    //中心扩展法
    //从左到右，以奇，偶为轴依次遍历子串

    public String longestPalindrome(String s) {
        String max = "";
        for(int i = 0; i < s.length(); i++){
            String oddres = palindrome(s,i,i);
            String evenres = palindrome(s,i,i+1);
            max = oddres.length() > max.length()?  oddres:max;
            max = evenres.length() > max.length()?  evenres:max;
        } 
        return max;
    }

    //双指针,由中间往两边扩
    public String palindrome(String s,int left,int right){
        while(left >= 0 && right < s.length() && s.charAt(left)==s.charAt(right)){
            left--;
            right++;
        }
        
        return s.substring(left + 1,right);
    }
```

学习一下别人简洁的写法~

```java
    public String longestPalindrome(String s) {

        String max = "";
        String tmp = "";

        for(int i = 0;i < s.length();i++){
            String s1 = help(s,i,i);
            String s2  = help(s,i,i+1);
            if(s1.length() > s2.length()){
                tmp = s1;
            }else{
                tmp = s2;
            }

            if(tmp.length()>max.length()){
                max = tmp;
            }

        }
        return max;
    }

    public String help(String s,int i,int j){

        //循环越多，本身就越长
        while(i>=0 && j <= s.length()-1 && s.charAt(i)==s.charAt(j)){
            i--;
            j++;
        }
        //跳出循环就是不符合要求的，需要减掉
        return s.substring(i+1,j);
    }
```



### 二维数组的遍历

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

题目：给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

思路：

```java
//顺时针旋转90度：
    //沿左上到右下的对角线镜像反转矩阵，使行和列发生交换
    //再对每一行进行反转
```

```java
    //顺时针旋转90度：
    //沿左上到右下的对角线镜像反转矩阵，使行和列发生交换
    //再对每一行进行反转

    //逆时针旋转90度：
    //沿右上到左下的对角线镜像反转矩阵，使行和列发生交换
    //再对每一行进行反转
    public void rotate(int[][] matrix) {
        //沿左上到右下的对角线镜像反转矩阵，使行和列发生交换
        for(int i = 0; i < matrix.length; i++){
            for(int j = i;j < matrix.length;j++){   //从对角线以后开始翻转，不然又翻转回去了
            // swap(matrix[i][j], matrix[j][i]);
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = tmp;
            }
        }

        //逐行翻转
        for(int i = 0; i < matrix.length ; i++){
            reverse(matrix[i]);
        }

    }

     //逐行翻转
    void reverse(int[] arr){
        int i = 0;
        int j = arr.length-1;
        while(i < j){
            // swap(arr[i++],arr[j--]);
            int tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
            i++;
            j--;
        }
    }
```

注意：java无法简单的交换两个值，需要利用数组来实现

```java
    public void rotate(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        //沿 y = x进行翻转
        for(int i = 0;i < m;i++){
            for(int j = i;j < n;j++){
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = tmp;
            }
        }

        //沿轴对称进行翻转
        for(int i = 0;i < m;i++){
            for(int j = 0;j < n/2;j++){
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[i][n-j-1];
                matrix[i][n-j-1] = tmp;
            }
        }
    }
```



#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

```java
    public List<Integer> spiralOrder(int[][] matrix) {

        //定义上下左右四个边界
        int l = 0,r = matrix[0].length-1, t = 0, b = matrix.length-1;
        List<Integer> res = new ArrayList<>();
        
        //如果不想break,可以利用Res的长度判断
        while(true){
            for(int i = l;i <= r;i++) res.add(matrix[t][i]);
            //这个在for循环外面
            if(++t > b) break;
            for(int i = t;i <= b;i++) res.add(matrix[i][r]);
            if(--r < l) break;
            for(int i = r;i >=l ;i--) res.add(matrix[b][i]);
            if(--b < t) break;
            for(int i = b;i >=t ;i--) res.add(matrix[i][l]);
            if(++l > r) break;
        }

        return res;
    }
```

#### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

```java
    public int[][] generateMatrix(int n) {
        int l=0,r=n-1,t=0,b=n-1;
        int[][] mat = new int[n][n];
        int num=1,tar = n*n;
        while(num <= tar){
            for(int i=l;i<=r;i++) mat[t][i]=num++;
            t++;
            for(int i=t;i<=b;i++) mat[i][r]=num++;
            r--;
            for(int i=r;i>=l;i--) mat[b][i]=num++;
            b--;
            for(int i=b;i>=t;i--) mat[i][l]=num++;
            l++;
        }
        return mat;
    }
```



## 单调栈(去重)

#### **[402. 移掉 K 位数字](https://leetcode-cn.com/problems/remove-k-digits/)

```java
    public String removeKdigits(String num, int k) {
        //利用单调栈，保持栈是升序，因为后面的数如果比栈顶小，则选择移除栈顶，符合该题逻辑
        //没说顺序不能变

        if(num.length() <= k) return "0";

        LinkedList<Character> stack = new LinkedList<Character>();
        StringBuilder res = new StringBuilder();

        for(int i = 0;i < num.length(); i++){
            while( k > 0 &&!stack.isEmpty() && stack.getLast() > num.charAt(i)){
                stack.removeLast();
                k--;
            }
            stack.addLast(num.charAt(i));
        }

        
        //使答案剩下n-k个,k现在变成多得没处理的k
        for(int i = 0;i < k; i++){
            stack.removeLast();
        }

        //处理前导0

        boolean isZero = true;
        while(!stack.isEmpty()){
            if(isZero && stack.getFirst()=='0'){
                stack.removeFirst();
                continue;
            }
            isZero =false;
            res.append(stack.removeFirst());
        }

        return res.length()==0? "0":res.toString();

    }
```

-   这个题的单调栈的使用比较灵活，特殊情况比较多

    比如要处理先导0，要处理112这种本来就单调递增的数据

```java
    public String removeKdigits(String num, int k) {

        //利用严格单调递增的栈，从左往右找到最大的K个树
        //然后把剩下的数据入栈，再利用双端栈反向弹出

        if(num.length()==k) return "0";

        LinkedList<Character> stack = new LinkedList<>();
        for(int i = 0;i < num.length();i++){
            char c = num.charAt(i);
            while(k > 0 && !stack.isEmpty() && stack.peek() > c){
                stack.pop();
                k--;
            }
            //就算k维持完了，剩下的字符会按次序入栈            
            stack.push(c);
        }


        //会有"112"这种情况，K就没有变
        while(!stack.isEmpty() && k > 0){
            stack.pop();
            k--;
        }

        // System.out.println(stack);

        StringBuilder res = new StringBuilder();
        boolean zero = true;
        while(!stack.isEmpty()){
            if(stack.getLast()=='0' && zero==true){
                stack.removeLast();
            }else{
                zero=false;
                res.append(stack.removeLast());
            }
        }

        String tmp = res.toString();
        //由于数字很大，不可以直接用Integer.parseInt("String")
        return tmp.equals("")? "0" : tmp;

    }
```



## 查找

#### *[380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

```java
    HashMap<Integer, Integer> map;
    List<Integer> nums;
    Random rand = new Random();


    //插入删除都在尾部进行操作
    public RandomizedSet() {
        nums = new ArrayList<Integer>();
        map = new HashMap<>(); //记录索引和元素
    }
    
    public boolean insert(int val) {
        if(map.containsKey(val)) return false;

        map.put(val,nums.size());
        nums.add(nums.size(),val);
        return true;
    }
    
    //交换到尾部进行删除
    public boolean remove(int val) {
        if(!map.containsKey(val)) return false;

        int tmp = nums.get(nums.size()-1);
        // nums.set(nums.size()-1,nums.get(map.get(val)));
        nums.set(map.get(val),tmp);

        map.put(tmp,map.get(val));

        map.remove(val);
        nums.remove(nums.size()-1);
        return true;

    }
    
    public int getRandom() {
        return nums.get(rand.nextInt(nums.size()));
    }
```

-   可以在仔细看看，数组上不用蓄水池算法

```java
    //因为删除查找也需要O(1)的时间复杂度所以需要使用hashmap(//元素 + 索引)
    HashMap<Integer,Integer> map;
    List<Integer> nums; //不要用链表 不知道长度 随机获得数据的时候麻烦 得用蓄水池算法
    Random rand =  new Random();

    public RandomizedSet() {
        map = new HashMap<>();
        nums = new ArrayList<>();
    }
    
    public boolean insert(int val) {
        if(map.containsKey(val)){
            return false;
        }

        map.put(val,nums.size());
        nums.add(val);
        return true;
    }
    
    public boolean remove(int val) {
        if(!map.containsKey(val)){
            return false;
        }
        //交换到尾部进行删除
        int tailValue = nums.get(nums.size()-1);
        int idx = map.get(val);
        // System.out.println("map:"+map+"\tidx:"+idx);
        nums.set(idx,tailValue);
        map.put(tailValue,idx);

        nums.remove(nums.size()-1);
        map.remove(val);
        return true;
    }
    
    public int getRandom() {
        return nums.get(rand.nextInt(nums.size()));
    }
```



## 前缀和

### 一维

#### [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

- 不用前缀和

  ```java
      //不用前缀和
      private int[] nums;
      
      public NumArray(int[] nums) {
          this.nums = nums;
      }
      
      public int sumRange(int left, int right) {
          int sum = 0;
          for(int i = left;i<=right;i++){
              sum += nums[i];
          }
          return sum;
      }
  ```

  

- 前缀和

  ```java
      //前缀和
      private int[] preSum;
      
      public NumArray(int[] nums) {
          //搞个假头，便于计算累加和
          preSum = new int[nums.length + 1];
          preSum[0] = 0;
          for(int i=1;i < preSum.length;i++){
              preSum[i] = nums[i-1] + preSum[i-1];
          }
      }
      
      public int sumRange(int left, int right) {
          return preSum[right+1]-preSum[left];
      }
  ```

### 二维

#### [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

题目：给定一个二维矩阵 matrix，以下类型的多个请求：计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。

思路：

类似于前缀和，我们可以把这种思想拓展到二维，即积分图（image integral）。我们可以先建立一个 intergral 矩阵，intergral[i][j] 表示以位置 (0, 0) 为左上角、位置 (i, j) 为右下角的长方形中所有数字的和。intergral[i][j] = matrix[i-1][j-1] +integral[i-1][j] + integral[i][j-1] - integral[i-1][j-1]，即当前坐标的数字 + 上面长方形的数字和 + 边长方形的数字和 - 上面长方形和左边长方形重合面积（即左上一格的长方形）中的数字和。

![](appendix\前缀和.png)

```java
    int[][] integral;

    public NumMatrix(int[][] matrix) {
        //动态规划求前缀和矩阵
        //状态：intergral[i][j]表示以(i-1,j-1)为右下角，(0,0)为左上角的矩阵元素的和
        //转移方程：intergral[i][j] = matrix[i-1][j-1] +integral[i-1][j] + integral[i][j-1] - integral[i-1][j-1]
        //初始：多的一行一列默认值都为0
        //结果：integral[row2+1][col2+1] - integral[row2+1][col1] -integral[row1][col2+1] + integral[row1][col1]
        integral = new int[matrix.length + 1][matrix[0].length+1];
        for(int i=1; i < integral.length;i++){
            for(int j=1;j < integral[0].length;j++){
                integral[i][j] = matrix[i-1][j-1] + integral[i-1][j] + integral[i][j-1] - integral[i-1][j-1];
            }
        }

    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        //要注意不能少算了一行和一列，重合的地方 笨蛋
        return integral[row2+1][col2+1] - integral[row2+1][col1] -integral[row1][col2+1] + integral[row1][col1];
    }
```

#### *[560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

注意优化后的方法

题目：给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

- 麻烦的前缀和

  ```java
      public int subarraySum(int[] nums, int k) {
          //计算前缀和
          int[] preSum = new int[nums.length+1];
          preSum[0] = 0;
          int res = 0;
          for(int i = 1;i < preSum.length;i++){
              preSum[i] = nums[i-1] + preSum[i-1];
          }
  
          //遍历每个子数组的和[j,i-1]
          for(int i=1; i < preSum.length; i++ ){
              for(int j=0;j < i; j++){
                  if(preSum[i]-preSum[j]==k){
                      res++;
                  }
              }
          }
          return res;
      }
  ```

  

- 方便的前缀和

  第二层 for 循环在干嘛呢？翻译一下就是，**在计算，有几个 `j` 能够使得 `preSum[i]` 和 `preSum[j]` 的差为 `k`**。毎找到一个这样的 `j`，就把结果加一。

  我们可以把 if 语句里的条件判断移项，这样写：

  ```java
  if (preSum[j] == preSum[i] - k)
      res++;
  ```

  优化的思路是：**我直接记录下有几个 `preSum[j]` 和 `preSum[i] - k` 相等，直接更新结果，就避免了内层的 for 循环**。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。

  **注意这里我们 `preSum` 记录的是前缀和, 该前缀和出现的次数的映射**。

  ```java
      //优化循环
      // for(int j=0;j < i; j++){
      //      if(preSum[i]-preSum[j]==k){
      //          res++;
          // }
      public int subarraySum(int[] nums, int k) {
          //定义前缀和，是前缀和-前缀和次数的映射
          //优化前缀和，次数
          //利用hashMap优化第二层循环
          HashMap<Integer,Integer> preSum = new HashMap<>();
  
          //初始化
          preSum.put(0,1);
  
          int res = 0,sum_i = 0;
          for(int i=0;i < nums.length;i++){
              //当前的前缀和
              sum_i += nums[i];
  
              //看存不存在互补的前缀和，preSum[j]==preSum[i]-k;
              int sum_j = sum_i - k;
              //0.
              if(preSum.containsKey(sum_j)){
                  res += preSum.get(sum_j);
              }
  			
              //1.
              //注意0和1的顺序不可以换，否则会算多
              //往HashMap中存放当前的前缀和
              preSum.put(sum_i,preSum.getOrDefault(sum_i,0)+1);
          }
          return res;
      }
  ```




# 链表

## 双指针

### 1. 普通双指针

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

- 递归

  子问题、递推关系、返回值、base case

```java
    //返回的是当前的节点
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        //base case
        if(list1==null){
            return list2;
        }
        if(list2==null){
            return list1;
        }


        //递推关系

        if(list1.val <= list2.val){
            list1.next = mergeTwoLists(list1.next,list2);
            return list1;
        }
        list2.next = mergeTwoLists(list1,list2.next);
        return list2;
        
    }
```



- 非递归

```java
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode p1 = list1;
        ListNode p2 = list2;
        ListNode dummy = new ListNode(-1); //虚拟头
        ListNode p = dummy;

        while(p1 != null && p2 != null){
            if(p1.val <= p2.val){
                p.next = p1;
                p1 = p1.next;
            }else{
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }

        if(p1 != null){
            p.next = p1;
        }

        if(p2 != null){
            p.next = p2;
        }

        return dummy.next;
    }
```

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```java
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0) return null;
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;

        //用最小堆去代替ListNode的数组，以此来快速获取最小值
        //priorityqueue默认最小堆
        PriorityQueue<ListNode> pq = new PriorityQueue<>(lists.length, (a, b)->(a.val - b.val));

        for(ListNode list:lists){
            if(list!=null){
                pq.offer(list);
            }
        }

        //比较并链接
        while(!pq.isEmpty()){
            ListNode minp = pq.poll();
            p.next = minp;
            if(minp.next!=null){
                minp = minp.next;
                pq.offer(minp);
            }
            p = p.next;
        }

        return dummy.next;
    }
```

-   自己写的：利用堆

```java
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0) return null;
        //关键在于如何快速从K个list中找到最小的
        //利用小根堆
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;

        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(new Comparator<ListNode>(){
            public int compare(ListNode l1,ListNode l2){
                return l1.val-l2.val;
            }
        });

        for(int i =0;i < lists.length;i++){
            if(lists[i]!=null){
                minHeap.add(lists[i]);
            }
        }

        while(!minHeap.isEmpty()){
            ListNode cur = minHeap.remove();
            if(cur.next!=null){
                minHeap.add(cur.next);
            }
            p.next = cur;
            p = p.next;
        }
        return dummy.next;
    }
```



### 2. 快慢指针

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```java
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode slow = head;
        ListNode fast = head;

        //先走n步
        for(int i=0;i < n;i++){
            fast = fast.next;
        }

        while(fast!=null && fast.next!=null){
            fast = fast.next;
            slow = slow.next;
        }
        if(fast!=null){
            slow.next = slow.next.next;
        }else{
            dummy.next = slow.next;
        }

        return dummy.next;
        

    }
```

#### [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

```java
    public ListNode middleNode(ListNode head) {
        //快慢指针，慢指针走一步，快指针走两步
        ListNode slow = head, fast = head;
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
```

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

- 把两个链表首尾相接，将问题转为计算这个环的起点

```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        //把两个链表首尾相接，将问题转为
        //如果链表中含有环，如何计算这个环的起点
        ListNode p = headA;
        while(p.next!=null){
            p = p.next;
        }
        p.next = headB;

        //headA作为新的链表
        ListNode slow = headA;
        ListNode fast = headA;
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            if(slow==fast){
                break;
            }
        }

        //判断一下是否有环
        //无环直接返回
        if(fast==null || fast.next==null){
            p.next = null;
            return null; 
        }

        //有环
        slow = headA;
        while(slow!=fast){
            slow = slow.next;
            fast = fast.next;
        }

        p.next = null;

        return slow;
    }
```

- 浪漫相遇法

```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1 = headA;
        ListNode p2 = headB;
        while(p1!=p2){
            if(p1!=null){
                p1 = p1.next;
            }else{
                p1 = headB;
            }

            if(p2!=null){
                p2 = p2.next;
            }else{
                p2 = headA;
            }
        }
        //不相交的情况就是p1=p2=null
        return p1;
    }
```



## 递归

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```java
    //递归解法:
    //1. 返回值：交换完成后子链表的头
    //2. 递推关系：p1(head),p2(head.next)。p1连p2后面交换完成的链表的值，p2连p1
    //3. base case : 当p1或者p2为空的时候停止递归（也就是head、head.next）
    public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }

        ListNode next = head.next;
        head.next = swapPairs(next.next);
        next.next = head;

        return next;
        
    }
```

#### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

题目：

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

思路：

```java
//递归
//1. 返回值：反转后链表的头
//2. 递推关系：head是当前节点，node是除head以外反转好的子链的头（不再是head.next），试着1->2->3->4走下就明白了
//head.next.next = head,head.next=null
//3. base case: head==null || head.next==null(没有办法链接了)
    public ListNode reverseList(ListNode head){
        //base case
        if(head==null || head.next==null){
            return head;
        }

        //递推关系
        ListNode node = reverseList(head.next);

        //反转操作
        head.next.next = head;
        head.next = null;
		
        //返回值
        return node;
    }
```

#### 反转链表的一部分

题目：将链表的前 n 个节点反转（n <= 链表长度）

思路：

```java
//递归
//1. 返回值：反转后链表的头
//2. 递推关系：head是当前节点，node是除head以外反转好的子链的头（不再是head.next），试着1->2->3->4走下就明白了
//head.next.next = head,head.next=successor
//3. base case: n==1
    public ListNode reverseN(ListNode head,int n){
        //base case
        if(n==1){
            //记录当前head的下一个节点
            successor = head.next;
            return head;
        }

        //递推关系
        ListNode node = reverseList(head.next,n-1);

        //反转操作
        head.next.next = head;
        head.next = successor;
		
        //返回值
        return node;
    }
```

#### 反转链表的一部分

题目：

现在解决我们最开始提出的问题，给一个索引区间 `[m,n]`（索引从 1 开始），仅仅反转区间中的链表元素

思路：

如果 `m == 1`，就相当于反转链表开头的 `n` 个元素

如果 `m != 1` 怎么办？如果我们把 `head` 的索引视为 1，那么我们是想从第 `m` 个元素开始反转对吧；如果把 `head.next` 的索引视为 1 呢？那么相对于 `head.next`，反转的区间应该是从第 `m - 1` 个元素开始的；那么对于 `head.next.next` 呢……

```java
//递归
//1. 返回值：反转后链表的头
//2. 递推关系：head是当前节点，node是除head以外反转好的子链的头（不再是head.next），试着1->2->3->4走下就明白了
//head.next.next = head,head.next=successor
//3. base case: m==1的反转前n个节点的情况
    public ListNode reverseBetween(ListNode head,int m,int n){
        //base case
        if(m==1){
            //记录当前head的下一个节点
           return reserveN(head,n); 
        }

        //递推关系
        head.next = reverseBetween(head.next,m-1,n-1);
		
        //返回值
        return head;
    }
```

#### [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

题目：将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

思路：

```java
//递归
//1. 返回值：合并后的链的尾
//2. 递推关系：
//- p1 < p2: 返回p1; p1.next = p1.next和p2的合并的头
//- p2 < p1: 返回p2; p2.next = p2.next和p1的合并的头
//3. base case: 
//- p1==null return p2
//- p2==null return p1
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null ||l2==null){
            return l1!=null?l1:l2;
        }

        if(l1.val <= l2.val){
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l2.next,l1);
            return l2;
        }

    }
```

#### *[234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

这递归的方法真牛逼

链表如何实现双指针，利用调用栈，利用递归参数，一个从前往后，一个从后往前。



给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

```java
//模拟双指针实现回文
//实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的，只不过我们利用的是递归函数的堆栈而已
//左侧
//1. 返回值：该串的左右指针是否相等
//2. 递推：res = 之前的结果res & 当前左右指针是否相等；left = left.next;
//3. base case：right==null

ListNode left;

boolean isPalindrome(ListNode head){
	left = head;
    return traverse(head);
}

boolean traverse(ListNode right){
	if(right==null) return true;
    
    boolean res = traverse(right.next);
    //后序
    res = res && (left.val==right.val);
    left = left.next;
    
    return res;
}
```



# 栈

## 普通栈

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

题目：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。

思路：一般是先判断完左括号，再判断右括号的情况

```java
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for(int i = 0;i < s.length();i++){
            char c = s.charAt(i);
            if(c =='{' || c=='(' || c=='['){
                stack.add(c);
            }
            //在循环里面空的情况是，只有右边括号，或者开头是右边括号，则必不匹配
            
            else if(stack.empty()){
                return false;
            }
            else if((stack.peek()=='{'&& c=='}') || (stack.peek()=='('&& c==')') || (stack.peek()=='['&& c==']')){
                stack.pop();
            }else{
                return false;
            }
        }
        return stack.empty();
    }
```

#### [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)

题目：只有满足下面几点之一，括号字符串才是有效的：

    它是一个空字符串，或者
    它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
    它可以被写作 (A)，其中 A 是有效字符串。

给定一个括号字符串 s ，移动N次，你就可以在字符串的任何位置插入一个括号。

    例如，如果 s = "()))" ，你可以插入一个开始括号为 "(()))" 或结束括号为 "())))" 。

返回 为使结果字符串 s 有效而必须添加的最少括号数。

错误解法：

```java
    //这种解法不可以，"()))(("
    public int minAddToMakeValid(String s) {
        // if(s.isEmpty()) return 0;
        int left = 0, right = 0;
        for(int i = 0;i < s.length();i++){
            char c = s.charAt(i);
            if(c=='(') left++;
            if(c==')') right++;
        }
        return Math.abs(left-right);
    }
```

思路：

```java
    public int minAddToMakeValid(String s) {
        int res = 0; //最后的结果
        int need = 0; //需要匹配的有括号的个数

        for(int i = 0;i < s.length();i++){
            char c = s.charAt(i);
            if(c=='(') need++;
            if(c==')') need--;
            if(need==-1){ //说明右括号多了
                need=0;
                res++;
            }
        }
        return res+need; //存在“))(”的情况

    }
```

#### [1541. 平衡括号字符串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string/)

题目：一个左括号，匹配两个右括号

思路：

```java
    public int minInsertions(String s) {
        int res = 0; //结果
        int need = 0; //需要匹配几个右括号
        for(int i=0;i < s.length();i++){
            char c = s.charAt(i);
            if(c=='(') {
                need += 2;
                //最后，判断在遇到左括号时，要判断右括号的需求量，因为左右括号的匹配是 1:2 的。若对右括号的需求量为奇数，则只需要插入一个右括号
                if(need % 2==1){ // 判断右括号的需求量是否为奇数
                    //插入一个右括号
                    res++; //把之前的结果加进去
                    need--;
                }
            }

            if(c==')') {
                need--;
                //及时判断
                if(need==-1){ //说明右括号多了
                    res++; //需要加一个左括号
                    need = 1; //需要再加一个右括号 
                }

            }

            
        }
        return res+need;
    }
```



## 单调栈

#### 普通数据的下一个更大的元素

![image-20220516151511676](appendix/0刷题/image-20220516151511676.png)

```java
    public int[] nextGreaterElements(int[] nums) {
        //如果不是循环数组
        Stack<Integer> s = new Stack<>();
        int[] res = new int[nums.length];

        for(int i = nums.length-1;i >=0;i-- ){
            while(!s.isEmpty() && nums[i] >= s.peek()){
                s.pop();
            }
            res[i] = s.isEmpty()? -1: s.peek();
            s.push(nums[i]);
        }

        return res;
    }
```



#### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

题目：给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。

数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。

思路：

1， 最简单的方式，**常用套路就是将数组长度翻倍**。

2，利用取模的方式，实现虚拟的数组长度翻倍。

```java
注意：index % n
```

```java
    public int[] nextGreaterElements(int[] temperatures) {
        int[] res = new int[temperatures.length];
        //栈中放tem
        Stack<Integer> s = new Stack<>();

        for(int i = temperatures.length*2-1;i>=0;i--){
            while(!s.empty() && s.peek() <= temperatures[ i % temperatures.length ]){
                s.pop();
            }
            res[i % temperatures.length] = s.empty()? -1 : s.peek();
            s.add(temperatures[i % temperatures.length]);
        }

        return res;
    }
```



#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

题目：给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

思路：保持单调递减的栈，也就是保证每个栈里的数被露出来

```java
    public int[] dailyTemperatures(int[] temperatures) {
        int[] res = new int[temperatures.length];
        Stack<Integer> s = new Stack<>();

        for(int i = temperatures.length-1;i>=0;i--){
            while(!s.empty() && temperatures[s.peek()] <= temperatures[i]){
                s.pop();
            }
            res[i] = s.empty()? 0: s.peek()-i;
            s.add(i);
        }

        return res;
    }
```



# 队列

#### *[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)（同剑指59)

题目：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

思路：

- **队列中的元素全都是单调递增（或递减）的**
- 队列中的元素必须是窗口里的

这道题我觉得必须使用队列的滑动窗口是因为要保留次小的进行比较。因为**因为如果减少的这个数恰好是 `A`（记录的最大值），就需要遍历所有数重新找新的最值**。

```java
    public int[] maxSlidingWindow(int[] nums, int k) {
        LinkedList<Integer> dp = new LinkedList<>();
        int [] res = new int[nums.length-k+1];

        //未形成窗口前
        for(int i = 0;i < k;i++){
            while(!dp.isEmpty() && dp.getLast() < nums[i]){
                dp.removeLast();
            }
            dp.addLast(nums[i]);
        }

        res[0] = dp.getFirst();

        //形成窗口后
        for(int i = k; i< nums.length;i++){
            if(!dp.isEmpty() && dp.getFirst()==nums[i-k]){
                dp.removeFirst();
            }
            while(!dp.isEmpty() && dp.getLast() < nums[i]){
                dp.removeLast();
            }
            dp.addLast(nums[i]);
            res[i-k+1] = dp.getFirst(); 
        }
        return res;
    }
```

-   注意：形成窗口前不是只放当前元素, 同样也是保持单调递减的队列！！！！

```java
    public int[] maxSlidingWindow(int[] nums, int k) {
        //利用双端队列
        //未形成窗口前
        //注意：不是只放最大元素，同样也是保持单调递减的队列！！！！
        LinkedList<Integer> q = new LinkedList<>();
        
        // q.addLast(nums[0]);
        // for(int i =1;i < k;i++){
        //     if(nums[i] > q.getLast()){
        //         q.removeLast();
        //         q.addLast(nums[i]);
        //     }
        // }
        // // System.out.println(q);

        int[] res = new int[nums.length-k+1];
      
        for(int i = 0;i < k;i++){
            while(!q.isEmpty() && q.getLast() < nums[i]){
                q.removeLast();
            }
            q.addLast(nums[i]);
        }

        res[0] = q.getFirst();

        for(int i = k;i < nums.length;i++){
            if(!q.isEmpty() && nums[i-k]==q.getFirst()){
                q.removeFirst();
            }
            while(!q.isEmpty() && q.getLast() < nums[i]){
                q.removeLast();
            }
            q.addLast(nums[i]);
            res[i-k+1] = q.getFirst();
            // System.out.println("nums[i]:"+nums[i]);
            // System.out.println("q:"+q);
            // System.out.println("res:" + Arrays.toString(res));
            // System.out.println();
        }
        
        return res;
    }
```



# 二叉树

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

- 遍历 + 变量（回溯）

```java
//1，遍历二叉树 + 变量=》回溯
//先序遍历
//base case: 到达叶子节点时，返回当前的值
//递推：在进入左右子树前 depth++,出来后,depth--
//返回值：NULL，有全局变量res
    int depth;
    int res;
    public int maxDepth(TreeNode root) {
        depth = 0;
        res = 0;
        
        if(root==null) return 0;
        
        recur(root);
        return res;
    }

    public void recur(TreeNode root){
        //base case 叶子节点
        if(root==null){
            res = Math.max(res,depth);
            return;
        }

        //当前节点
        depth++;
        recur(root.left);
        recur(root.right);
        depth--;
    }
```

- 分解子问题 + 返回值（变成求左右子树的最大值）

```java
    //2，分解成更小的问题 + 返回值 等于左右子树高度的最大值
    //后序遍历
//base case:到达叶子节点，返回当前层0
//递推：Math.max(left,right)+1
//返回值：当前节点的层数（右下自上增）
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        recur(root);

        return recur(root);
    }

    
    public int recur(TreeNode root){
        //base case
        if(root==null){
            return 0;
        }

        int left = recur(root.left);
        int right = recur(root.right);

        //递推
        return Math.max(left,right)+1;

    }
```

#### *[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

>   **任意一个结点，都要记录以此结点为根的直径情况：左子树高度+右子树高度**
>
>     //help返回的是以当前为根的二叉树的高度
>
>     //但是答案最后是max,因为max记录了路径
>
>     //help只用于left和right
>
>   ```java
>   int max = Integer.MIN_VALUE;
>       public int diameterOfBinaryTree(TreeNode root) {
>           if(root==null) return 0;
>           help(root);
>           return max;
>       }
>   
>       //help返回的是以当前为根的二叉树的高度
>       //但是答案最后是max,因为max记录了路径
>       //help只用于left和right
>   
>       public int help(TreeNode root) {
>           if(root==null) return 0;
>           int left = help(root.left);
>           int right = help(root.right);
>   
>           max = Math.max(max,right + left);
>           return Math.max(left,right) + 1;
>       }
>   ```
>
>   

- 分解子问题 + 返回值

```java
    //每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和
    //base case: 当二叉树达到叶子结点，返回0
    //递推关系：
    // int result = maxleft + maxright;
    // max = Math.max(result,max);
    //返回值：以当前节点为头的二叉树的最大高度

    int max;  //左右子树的最大深度之和
    public int diameterOfBinaryTree(TreeNode root) {
        max = 0;
        if(root==null) return 0;
        recur(root);
        return max;
    }

    //后序
    public int recur(TreeNode root){
        //base case
        if(root==null){
            return 0;
        }

        int maxleft = recur(root.left);
        int maxright = recur(root.right);

        //后序
        int result = maxleft + maxright;
        //更新最大值
        max = Math.max(result,max);

        //返回的是二叉树的高度
        return Math.max(maxleft,maxright) + 1;
    }
```

#### *[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

>   咳咳。这个题自己做出来了，但是觉得人家的层序写的太牛逼了，好好学习一波。条件只需要i<len-1时才next赋值，时间上也快很多
>
>   递归的解法也很牛逼，看看人家的三叉树

题目：

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

解法：

- 思维一：

  - 可以，让中间虚拟出一个节点，遍历三叉树

  - 抽出一个节点。让它左右节点做如下递推

  - 遍历：好像都可以，先序吧

  ```java
      // 递归遍历：
      // 可以，让中间虚拟出一个节点，遍历三叉树
      // 抽出一个节点。让它左右节点做如下递推
      // 遍历：好像都可以，先序吧
  
      //base case: 如果到叶子节点 return 
      //递推：
      //node1,node2
      //node1.left.next = node1.right
      //node2.left.next = node2.right
      //node1.right.next = node2.left
      //返回值：无
  
      public Node connect(Node root) {
          if(root==null){
              return null;
          }
          recur(root.left,root.right);
          return root;
      }
  
      public void recur(Node p1, Node p2){
          //base case
          if(p1==null || p2==null){
              return;
          }
  
          // 将传入的两个节点穿起来
          p1.next = p2;
  
          // 连接相同父节点的两个子节点
          recur(p1.left, p1.right);
          recur(p2.left,p2.right);
          // 连接跨越父节点的两个子节点
          recur(p1.right,p2.left);
      }
  ```

  

- 思维二：不可行

- 层序遍历

  ```java
      //层序遍历
      
      public Node connect(Node root) {
          if(root==null) return root;
  
          //队列
          LinkedList<Node> q = new LinkedList<>();
          q.addLast(root);
  
          //开始层序遍历
          while(!q.isEmpty()){
              int len = q.size();
              //一层从左到右依次遍历
              for(int i=0;i < len;i++){
  
                  Node cur = q.removeFirst();
                  
                  // if(!q.isEmpty()){
                  //这个条件不对，是到最后一个节点才没有
                  if(i < len-1){
                      cur.next = q.getFirst();
                  }
  
                  if(cur.left!=null){
                      q.addLast(cur.left);
                  }
  
                  if(cur.right!=null){
                      q.addLast(cur.right);
                  }
              }
              //一层结束了
          }
          return root;
      }
  ```

-   三刷：自己写得麻烦的遍历

    先链接左右孩子之间，再连接右孩子和左孩子

    ```java
        public Node connect(Node root) {
            //层序遍历
            Deque<Node> q = new LinkedList<>();
            if(root!=null) q.offer(root);
            
            while(!q.isEmpty()){
                int len = q.size();
                Node pre = null;
                for(int i = 0;i < len;i++){
                    Node cur = q.poll();
                    if(cur.left!=null && cur.right!=null){
                        q.offer(cur.left);
                        q.offer(cur.right);
                        cur.left.next = cur.right;
                        if(pre!=null) pre.right.next = cur.left;
                    }            
                    pre = cur; 
                }
            }
            return root;
        } 
    ```

    

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

**题目**：给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**解法：**

- 思维一：

  返回值为null，这是希望将其原地转换

   如果有返回值，则可以利用空间构造单链表,直接存储前序遍历的结果

  ```java
      //返回值为null，这是希望将其原地转换
      //如果有返回值，则可以利用空间构造单链表,直接存储前序遍历的结果
      TreeNode dummy = new TreeNode(-1);
      dummy.right = root;
      TreeNode p = dummy;
      public TreeNode flatten(TreeNode root) {
          //base case
          if(root==null) return;
  
          //递推
          p.right = root;
          p = p.right;
  
          flatten(root.left);
          flatten(root.right);
  
          return dummy.right;
      }
  ```

  

- 思维二：（一定要把图画出来，就会很清晰了）

  没有返回值，不能通过遍历的方式解决

  - 分解子问题：对于一个节点，返回以该节点为头的二叉树被拉平的链表的头

  - 抽出一个单个节点：把他的左右子树进行拉平，也就是拼接

  - 位置：后序

    ![](F:\xrz\桌面\Algorithm\notes\appendix\0刷题\4.png)

  ```java
      //没有返回值，不能通过遍历的方式解决
      //分解子问题：对于一个节点，返回以该节点为头的二叉树被拉平的链表的头
      //抽出一个单个节点：把他的左右子树进行拉平，也就是拼接
      //位置：后序
  
  	//base case:叶子节点,return
  	//递推：把他的左右子树进行拉平，也就是拼接
  	//返回值：无，原地
      public void flatten(TreeNode root) {
          if(root==null) return;
          recur(root);
      }
  
      //对于一个节点，返回以该节点为头的二叉树被拉平的链表的头
      public TreeNode recur(TreeNode root){
          //base case
          if(root==null) return null;
  
          //递推
          TreeNode l = recur(root.left);
          TreeNode r = recur(root.right);
  
          //抽出的一个节点要做的事情
          root.left = null;
          root.right = l;
  
          TreeNode p = root; //保留当前的root
          while(p.right!=null){
              p = p.right;
          }
  
          p.right = r;
  
          return root;
      }
  ```

#### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

    创建一个根节点，其值为 nums 中的最大值。
    递归地在最大值 左边 的 子数组前缀上 构建左子树。
    递归地在最大值 右边 的 子数组后缀上 构建右子树。

返回 nums 构建的 最大二叉树 。

思路：

```java
    //分解：先构造根，构造左子，构造右子，返回头
    //单独抽取一个节点。lm = 找到左边的最大值，root.left = lm,rm = 找到右边的最大值,root.right = rm
    //位置：先序

    //base case : 叶子结点
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return recur(nums,0,nums.length-1);
    }

    //在区间[low,high]里进行处理
    public TreeNode recur(int[] nums,int low,int high){
        if(low > high){
            return null;
        }

        //找到最大值,记录最大值的索引
        int maxindex = low;
        for(int i = low;i <= high;i++){
            if(nums[maxindex] < nums[i]){
                maxindex = i;
            }
        }

        // System.out.println(nums[maxindex] + "\t" + maxindex + "\t[" + low + "," + high + "]");

        //构造二叉树
        TreeNode root = new TreeNode(nums[maxindex]);

        root.left = recur(nums,low,maxindex-1);
        root.right = recur(nums,maxindex + 1,high);

        return root;
    }
```

#### *[652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

>   需要利用二叉树的序列化
>
>   这样只需要在遍历的时候进行保存就可以

题目：给定一棵二叉树 `root`，返回所有**重复的子树**。

思路：

将子树的**前序序列化**保留，以此来判断是否有重复，注意空值要填null

```java
    //分解：求子树
    //对于单个节点：把当前子树的先序遍历(序列化)放到hashmap中，已经当前所有子树存入hashmap，对比是否与当前序列有重复的，放入结果中
    //位置：后序

    //放序列，对应的次数
    HashMap<String,Integer> map; 
    List<TreeNode> ans;
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        map = new HashMap<>(); 
        ans = new ArrayList<>();
        recur(root);
        return ans;
    }

    //base case: root==null， 叶子节点，序列化“#”
    //递推：先加入hashmap,再判断是否重复
    //返回值：返回以当前节点为根的二叉树的前序序列化
    public String recur(TreeNode root){
        //base case
        if(root==null){
            return "#";
        }

        //先添加
        String serial = root.val + "," + recur(root.left) + "," + recur(root.right);
        map.put(serial,map.getOrDefault(serial,0)+1);

        //判断与当前序列（子树）是否有重复的
        if(map.get(serial)==2) ans.add(root);
        return serial;
    }
```

-   三刷：思路一样，但是时间很长

    因为递归套递归了

```java
    //将子树的先序遍历进行序列化，然后进行对比
    List<TreeNode> res = new LinkedList<>();
    HashMap<String,Integer> map = new HashMap<>();

    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {

        if(root==null) return res;
        //自上向下
        findDuplicateSubtrees(root.left);
        findDuplicateSubtrees(root.right);

        String tmp = series(root);
        // System.out.println("root:" + root.val + "\tString:"+ tmp);
        if(map.containsKey(tmp)){
            if(map.get(tmp) < 2) res.add(root);
        }
        map.put(tmp,map.getOrDefault(tmp,0)+1);

        return res;
    }

    //以树的每一个节点为根的子树，是否有相同的子结构
    public String series(TreeNode root){
        if(root==null) return "#,";

        String res = root.val +"," + series(root.left) + series(root.right);

        return res;
    }
```

```java
List<TreeNode> res = new LinkedList<>();
    HashMap<String,Integer> map = new HashMap<>();
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {

        if(root==null) return res;
        recur(root);
        return res;
        
    }

    //将子树的先序遍历进行序列化
    public String recur(TreeNode root){
        if(root==null) return "#,";

        String tmp = root.val +"," + recur(root.left) +"," + recur(root.right);

        //后序加入hashmap进行判断
        if(map.containsKey(tmp)){
            if(map.get(tmp) < 2) res.add(root);
        }
        map.put(tmp,map.getOrDefault(tmp,0)+1);

        return tmp;
    }
```



#### [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

```java
    private class Pair {
        int val, id;
        Pair(int val, int id) {
            // 记录数组的元素值
            this.val = val;
            // 记录元素在数组中的原始索引
            this.id = id;
        }
    }
    
    // 归并排序所用的辅助数组
    private Pair[] temp;
    // 记录每个元素后面比自己小的元素个数
    private int[] count;
    
    // 主函数
    public List<Integer> countSmaller(int[] nums) {
        int n = nums.length;
        count = new int[n];
        temp = new Pair[n];
        Pair[] arr = new Pair[n];
        // 记录元素原始的索引位置，以便在 count 数组中更新结果
        for (int i = 0; i < n; i++)
            arr[i] = new Pair(nums[i], i);
        
        // 执行归并排序，本题结果被记录在 count 数组中
        sort(arr, 0, n - 1);
        
        List<Integer> res = new LinkedList<>();
        for (int c : count) res.add(c);
        return res;
    }
    
    // 归并排序
    private void sort(Pair[] arr, int lo, int hi) {
        if (lo == hi) return;
        int mid = lo + (hi - lo) / 2;
        sort(arr, lo, mid);
        sort(arr, mid + 1, hi);
        merge(arr, lo, mid, hi);
    }
    
    // 合并两个有序数组
    private void merge(Pair[] arr, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; i++) {
            temp[i] = arr[i];
        }
        
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            //左边都合完了，还剩右边
            if (i == mid + 1) {
                arr[p] = temp[j++];
            //右边都合完了，还剩左边
            } else if (j == hi + 1) {
                arr[p] = temp[i++];
                // 更新 count 数组
                count[arr[p].id] += j - mid - 1;
            } else if (temp[i].val > temp[j].val) {
                arr[p] = temp[j++];
            } else {
                arr[p] = temp[i++];
                // 更新 count 数组
                count[arr[p].id] += j - mid - 1;
            }
        }
    }
```



#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)([1038. 从二叉搜索树到更大和树](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/))

题目：给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

![image-20220415090843559](F:\xrz\桌面\Algorithm\notes\appendix\0刷题\image-20220415090843559.png)

思路：

我们可以从结果观察到，右中左的顺序是在累加的，初始是最右边的元素

利用二叉搜索树的逆中序遍历是降序

```java
    //利用二叉搜索树的逆中序遍历是降序
    //我们可以从结果观察到，右中左的顺序是在累加的，初始是最右边的元素
    int sum;
    public TreeNode convertBST(TreeNode root) {
        sum = 0;
        recur(root);
        return root;
    }

    public void recur(TreeNode root){
        if(root==null) return;

        recur(root.right);
        sum += root.val;
        root.val = sum;
        recur(root.left);
    }
```

#### [1373. 二叉搜索子树的最大键值和](https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/)

给你一棵以 `root` 为根的 **二叉树** ，请你返回 **任意** 二叉搜索子树的最大键值和。

思路：

**当前节点需要做什么？**

1、左右子树是否是 BST。（一个树必然有BST子树，因为一个节点也算）

2、左子树的最大值和右子树的最小值。（是不是可以省略，加上自己看一下是不是BST）

3、左右子树的节点值之和。

- 先序的模板（递归套递归了）

```java
int max = 0;
public int maxSumBST(TreeNode root){
	recur(root);
    return max;
}

//遍历二叉树
public void recur(TreeNode root){
	if(root==null) return;
    
    //先序遍历
    
    //1.判断左右子树是否是BST
    if(isBST(root.left) || !isBST(root.right)){
		goto next;
    }
    //2.判断加上自己是不是BST
    if(!isBST(root)){
		goto next;
    }
    
    //3. 满足前面的条件，计算和
    int sum = findSum(root.left) + findSum(root.right) + root.val;
    max = Math.max(max,sum);
    
    
    //递归遍历左右子树
    next;
    recur(root.left);
    recur(root.right);
}

/* 计算以 root 为根的二叉树的节点和 */
int findSum(TreeNode root) {}

/* 判断以 root 为根的二叉树是否是 BST */
boolean isBST(TreeNode root) {}

```

- 后序，返回一些信息，让recur把其他辅助函数做的事情都做了

```java
class Solution {
    private int maxSum = 0;

    public int maxSumBST(TreeNode root) {
        if(root == null) {
            return 0;
        }
        recur(root);
        return maxSum;
    }

    public ReturnType recur(TreeNode root) {
        if(root == null) {
            return new ReturnType(true, Integer.MAX_VALUE, Integer.MIN_VALUE, 0);
        }
        ReturnType left = recur(root.left);
        ReturnType right = recur(root.right);
        //判断是否为BST 左右子树都是BST 并且左子树最大值小于根节点 右子树最小值大于根节点
        int val = root.val;
        if(left.isBST && right.isBST && val > left.maxVal && val < right.minVal) {
            int sum = left.sum + right.sum + root.val;
            maxSum = Math.max(sum, maxSum);
             //如果我们判断以 root 为根的二叉树是 BST，root.val一定大于left[1]吧,为什么要这样写
            //这跟我们对空节点的处理有关，我们处理空节点的时候，把它的最小值设成了正无穷，最大值设成了负无穷，如果不比较大小直接赋值的话，那么它们的父亲节点的最小值也变成正无穷了，最大值也变成负无穷了，只有和是对的
            int minVal = Math.min(left.minVal, val);
            int maxVal = Math.max(right.maxVal, val);
            // int minVal = left.minVal;
            // int maxVal = right.maxVal;
            return new ReturnType(true, minVal, maxVal, sum);
        } else {
            //不是bst 其他值无需计算
            return new ReturnType(false, 0, 0, 0);
        } 
    }

    class ReturnType {
        public boolean isBST;
        public int minVal;
        public int maxVal;
        public int sum;

        public ReturnType(boolean isBST, int minVal, int maxVal, int sum) {
            this.isBST = isBST;
            this.minVal = minVal;
            this.maxVal = maxVal;
            this.sum = sum;
        }  
    }
}
```

#### 完全二叉树

先判断是否是满二叉树，不是则按普通方法计算

```java
    public int countNodes(TreeNode root){
        TreeNode l = root,r = root;
        int hl = 0,hr = 0;
        while(l!=null){
            l = l.left;
            hl++;
        }
        while(r!=null){
            r = r.right;
            hr++;
        }
        
        // 如果左右子树的高度相同，则是一棵满二叉树
        if(hr==hl){
            return (int)Math.pow(2,hl)-1;
        }
        
        // 如果左右高度不同，则按照普通二叉树的逻辑计算
        return 1 + countNodes(root.left) + countNodes(root.right); 
    }
```

复杂度分析：O(logN*logN)

直觉感觉好像最坏情况下是 O(N*logN) 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归。**但这两个递归只有一个会真的递归下去，另一个一定会触发 `hl == hr` 而立即返回，不会递归下去**。因为**一棵完全二叉树的两棵子树，至少有一棵是满二叉树**。

![image-20220415131950200](\appendix\2总结——4数据结构_二叉树\image-20220415131950200.png)



由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 `hl == hr`，只消耗 O(logN) 的复杂度而不会继续递归。

综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN).



#### 层序遍历建二叉树

```java
class Solution {
    //结构
    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        public TreeNode(int x) {
            this.val = x;
        }
    }

//    public TreeNode createTree(int[] data,int size){
//        if(size==0) return null;
//        //队列
//        LinkedList<TreeNode> q = new LinkedList<>();
//        //入第一个节点
//        TreeNode head = new TreeNode(data[0]);
//        q.offer(head);
//
//        int idx = 1;
//        while(!q.isEmpty() && idx < size){
////            System.out.print(idx + " ");
//            TreeNode cur = q.poll();
//            //这个是你考虑的特殊情况,当前节点为-1,左右孩子也是-1，则建树的节点赋值为null，但队列中的值为TreeNode(-1)
//            if(cur.val==-1){
//                cur.left = null;
//                q.offer(new TreeNode(-1));
//                cur.right = null;
//                q.offer(new TreeNode(-1));
//                idx = idx + 2;
//            }else{
//                //左孩子
//                    //不为空
//                if(data[idx]!=-1){
//                    cur.left = new TreeNode(data[idx]);
//                    q.offer(cur.left);
//                    //为空：建树的节点赋值为null，但队列中的值为TreeNode(-1)
//                }else{
//                    cur.left = null;
//                    q.offer(new TreeNode(-1));
//                }
//                idx++;
//
//                //右孩子
//                    //不为空
//                if(data[idx]!=-1){
//                    cur.right = new TreeNode(data[idx]);
//                    q.offer(cur.right);
//                    //为空：建树的节点赋值为null，但队列中的值为TreeNode(-1)
//                }else{
//                    cur.right = null;
//                    q.offer(new TreeNode(-1));
//                }
//                idx++;
//            }
//        }
////        System.out.println();
//        return head;
//    }

    public TreeNode createTree(int[] data,int size){
        if(size==0) return null;
        //队列
        LinkedList<TreeNode> q = new LinkedList<>();
        //入第一个节点
        TreeNode head = new TreeNode(data[0]);
        q.offer(head);

        int idx = 1;
        while(!q.isEmpty() && idx < size){
//            System.out.print(idx + " ");
            TreeNode cur = q.poll();
            //这个是你考虑的特殊情况,当前节点为-1,左右孩子也是-1，则建树的节点赋值为null，但队列中的值为TreeNode(-1)
            if(cur==null){
                idx = idx + 2;
                q.offer(null);
                q.offer(null);
            }else{
                //左孩子
                if(data[idx]!=-1){
                    cur.left = new TreeNode(data[idx]);
                }
                idx++;

                //右孩子
                if(data[idx]!=-1){
                    cur.right = new TreeNode(data[idx]);
                }
                idx++;
                q.offer(cur.left);
                q.offer(cur.right);
            }
        }
//        System.out.println();
        return head;
    }

    public void preOrder(TreeNode head){
        if(head==null) return;

        System.out.print(head.val + " ");
        preOrder(head.left);
        preOrder(head.right);
    }

    public void inOrder(TreeNode head){
        if(head==null) return;

        inOrder(head.left);
        System.out.print(head.val + " ");
        inOrder(head.right);
    }

    public void postOrder(TreeNode head){
        if(head==null) return;

        postOrder(head.left);
        postOrder(head.right);
        System.out.print(head.val + " ");
    }

    public static void main(String[] args) {
        Solution tree = new Solution();
        int[] data = {9, 8, 7, 6, -1, 5, -1, 4, -1, -1, -1, -1, 3, -1};

        //建树
        TreeNode head = tree.createTree(data, data.length);

        //前序
        tree.preOrder(head);
        System.out.println();

        //中序
        tree.inOrder(head);
        System.out.println();

        //后序
        tree.postOrder(head);
        System.out.println();

    }

}
```

# DFS

回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法。

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```java
//无论变量是不是全局的，在内存空间里是一个，则就是全局共享的，就需要回溯
    //如果每一次的path和res都是新申请的空间，则不需要进行回溯
    //记录结果
    List<List<Integer>> res;
    //记录path
    LinkedList<Integer> path;
    //记录是否被used
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        //暴力回溯

        res = new LinkedList<>();
        path = new LinkedList<>();
        //记录已经做过的决定和当前可以做的选择
        used = new boolean[nums.length];

        backtrack(nums);

        return res;
    }

    void backtrack(int[] nums) {
        //触发的结束条件
        if(path.size()==nums.length){
            res.add(new LinkedList(path));
            return;
        }

        //排除不合法的选择
        for(int i=0;i<nums.length;i++){
            if(used[i]){
                continue;
            }

            //做选择
            path.add(nums[i]);
            used[i] = true;

            //进行下一层决策树
            backtrack(nums);

            //撤销选择
            path.removeLast();
            used[i] = false;
        }
    }
```

#### *[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

>   三刷：
>
>   刚开始先初始化一个矩阵，用'.'填充
>
>   利用String.copyValueOf(row)将二维矩阵中的一行转为字符串

```java
List<List<String>> res;

    public List<List<String>> solveNQueens(int n) {
        //把N皇后的问题抽象成从每一行开始放。
        //只用记录每一行中列的位置
        res = new LinkedList<>();
        char[][] board = new char[n][n];
        for(char[] c:board){
            Arrays.fill(c,'.');
        }
        backtrack(board,0);
        return res;
    }
    
    //row表示当前在第几行
    public void backtrack(char[][] board,int row){
        //终止条件
        if(row==board.length){
            res.add(charToList(board));
            return;
        }

        //当前的行的每一列都可以做选择，再排除掉那些不可能的列
        for(int col=0;col < board.length;col++){
            if(!isValid(board,row,col)){
                continue;
            }

            //做出选择
            board[row][col] = 'Q';
            //继续进入下一层
            backtrack(board,row+1);
            //撤销选择
            board[row][col] = '.';
        }
    }

    //把当前的矩阵转换为列表
    public List<String> charToList(char[][] board){
        List<String> list = new ArrayList<>();
        for(char[] row:board){
            list.add(String.copyValueOf(row));
        }
        return list;
    }

    //查看是否有效位
    //只用看左上 上 右上是否符合规范
    public boolean isValid(char[][] board,int row,int col){
        int n = board.length;
        //检查列是否有冲突
        for(int  i=0;i<n;i++){
            if(board[i][col]=='Q') return false;
        }

        //检查右上是否有冲突
        for(int i = row-1,j = col+1;i>=0 && j<n;i--,j++){
            if(board[i][j]=='Q') return false;
        }

        //检查左上是否有冲突
        for(int i = row-1,j = col-1;i>=0 && j>=0;i--,j--){
            if(board[i][j]=='Q') return false;
        }

        return true;
    }
```



####  **[698. 划分为k个相等的子集](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/)

>   从桶的角度思考！

- 优化一

    ```java
    //==============================================================================
        //DFS暴力深搜 + memo,优化
        //有些组合在此之前已经出现过了，只是装i桶和装j桶不一样 ，我们可以用memo进行备忘录，
        //在装满一个桶时记录当前 used 的状态，如果当前 used 的状态是曾经出现过的，那就不用再继续穷举，从而起到剪枝避免冗余计算的作用。
        //存储方式：把数组转为hashSet的键的方式进行存储
    
        HashMap<String, Boolean> memo = new HashMap<>();
        public boolean canPartitionKSubsets(int[] nums, int k) {
            //排除一些情况
            if(k > nums.length) return false;
            int sum = 0;
            for(int num:nums){
                sum += num;
            }
            if(sum%k!=0) return false;
    
            boolean[] used = new boolean[nums.length];
            int target = sum/k;
            
    
            return backtrack(nums,k,target,0,0,used);
    
        }
    
        //现在的k号桶正在思考是否应该把nums[i]装进来，目前k号桶已经装的数字之和是curSum
        //used表示某个数组是否已经被装到桶中
        //target是目标和
        boolean backtrack(int[] nums,int k,int target,int curSum,int idx,boolean[] used){
    
            //base case 所有桶都装满了
            if(k==0) return true;
    
            // 将 used 的状态转化成形如 [true, false, ...] 的字符串
            // 便于比较和存入 HashMap
            String state = Arrays.toString(used);
    
            //当前桶装满了
            if(curSum==target){
                //让下一个桶开始选
                // k--会出错,应该传--k
                // Boolean res =  backtrack(nums,k--,target,0,0,used);
                Boolean res =  backtrack(nums,k-1,target,0,0,used);
                //记录状态
                
                memo.put(state, res);
                //
                return res;
                
            }
    
            //如果当前状态曾今计算过，就直接返回，不要再递归穷举了
            if(memo.containsKey(state)){
                return memo.get(state);
            }
    
            //做选择
            for(int j = idx;j < nums.length;j++){
                if(used[j]) continue;
                if(nums[j] + curSum > target) continue;
    
                used[j] = true;
                curSum += nums[j]; 
                if(backtrack(nums,k,target,curSum,j+1,used)){
                    return true;
                }
                //撤销
                used[j] = false;
                curSum -= nums[j];
            }
            //穷举完都装不完当前的桶
            return false;
        }
    ```

- 优化二：

    ```java
    //==============================================================================
        //DFS暴力深搜 + memo,优化
        //有些组合在此之前已经出现过了，只是装i桶和装j桶不一样 ，我们可以用memo进行备忘录，
        //在装满一个桶时记录当前 used 的状态，如果当前 used 的状态是曾经出现过的，那就不用再继续穷举，从而起到剪枝避免冗余计算的作用。
        //存储方式：把数组转为hashSet的键的方式进行存储
        //优化2：不用数组进行存储，用位
        //用整数 used 的第 i 位（(used >> i) & 1）的 1/0 来表示 used[i] 的 true/false
    
        HashMap<Integer, Boolean> memo = new HashMap<>();
        public boolean canPartitionKSubsets(int[] nums, int k) {
            //排除一些情况
            if(k > nums.length) return false;
            int sum = 0;
            for(int num:nums){
                sum += num;
            }
            if(sum%k!=0) return false;
    
            int used = 0;
            int target = sum/k;
            
    
            return backtrack(nums,k,target,0,0,used);
    
        }
    
        //现在的k号桶正在思考是否应该把nums[i]装进来，目前k号桶已经装的数字之和是curSum
        //used表示某个数组是否已经被装到桶中
        //target是目标和
        boolean backtrack(int[] nums,int k,int target,int curSum,int idx,int used){
    
            //base case 所有桶都装满了
            if(k==0) return true;
    
            //当前桶装满了
            if(curSum==target){
                //让下一个桶开始选
                // k--会出错,应该是因为改变了k的值所以后面都应该要回溯
                // 不是 ，
                // Boolean res =  backtrack(nums,k--,target,0,0,used);
                Boolean res =  backtrack(nums,k-1,target,0,0,used);
                //记录状态
                
                memo.put(used, res);
                //
                return res;
                
            }
    
            //如果当前状态曾今计算过，就直接返回，不要再递归穷举了
            if(memo.containsKey(used)){
                return memo.get(used);
            }
    
            //做选择
            for(int j = idx;j < nums.length;j++){
                //如果是第j位为1则代表用过了
                if(((used >> j) & 1) == 1) continue;
                if(nums[j] + curSum > target) continue;
    
                used |= 1 << j;
                curSum += nums[j]; 
                if(backtrack(nums,k,target,curSum,j+1,used)){
                    return true;
                }
                //撤销
                used ^= 1 << j;
                curSum -= nums[j];
            }
            //穷举完都装不完当前的桶
            return false;
        }
    ```

    



#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```
    List<List<Integer>> res = new LinkedList<>();
    // 记录回溯算法的递归路径
    LinkedList<Integer> track = new LinkedList<>();

    // 主函数
    public List<List<Integer>> subsets(int[] nums) {
        backtrack(nums, 0);
        return res;
    }

    // 回溯算法核心函数，遍历子集问题的回溯树
    void backtrack(int[] nums, int start) {
        //base case
    //     //nums.length==start时，将空集加入结果，不会进入循环，程序结束

        // 前序位置，每个节点的值都是一个子集
        res.add(new LinkedList<>(track));
    
        // 回溯算法标准框架
        for (int i = start; i < nums.length; i++) {
            // 做选择
            track.addLast(nums[i]);
            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            backtrack(nums, i + 1);
            // 撤销选择
            track.removeLast();
        }
    }
```



#### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

```java
    // 主函数
    List<List<Integer>> res = new LinkedList<>();
    // 记录回溯算法的递归路径
    LinkedList<Integer> track = new LinkedList<>();

    // 主函数
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        //排序：让相邻的一样的节点去剪枝
        Arrays.sort(nums);
        backtrack(nums, 0);
        return res;
    }

    // 回溯算法核心函数，遍历子集问题的回溯树
    void backtrack(int[] nums, int start) {
        //base case
    //     //nums.length==start时，将空集加入结果，不会进入循环，程序结束

        // 前序位置，每个节点的值都是一个子集
        res.add(new LinkedList<>(track));
    
        // 回溯算法标准框架
        for (int i = start; i < nums.length; i++) {
            
            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            if(i > start && nums[i]==nums[i-1]){
                continue;
            }
            // 做选择
            track.addLast(nums[i]);
            backtrack(nums, i + 1);
            // 撤销选择
            track.removeLast();
        }
    }
```



#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

```java
    List<List<Integer>> res = new LinkedList<>();
    // 记录回溯算法的递归路径
    LinkedList<Integer> track = new LinkedList<>();

    // 主函数
    public List<List<Integer>> combine(int n,int k) {
        backtrack(1,n,k);
        return res;
    }

    // 回溯算法核心函数，遍历子集问题的回溯树
    void backtrack(int start, int n,int k) {
        //base case
        // 遍历到了第 k 层，收集当前节点的值
        if(track.size()==k){
            res.add(new LinkedList<>(track));
            return;
        }
    
        // 回溯算法标准框架
        for (int i = start; i <= n; i++) {
            // 做选择
            track.addLast(i);
            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            backtrack(i+1,n,k);
            // 撤销选择
            track.removeLast();
        }
    }
```



#### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。 

```java
    List<List<Integer>> res = new LinkedList<>();
    // 记录回溯算法的递归路径
    LinkedList<Integer> track = new LinkedList<>();
    int curSum = 0;

    // 主函数
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        if(candidates.length==0) return res;
        //排序：让相邻的一样的节点去剪枝
        Arrays.sort(candidates);
        // System.out.println(Arrays.toString(candidates));
        backtrack(candidates,0,target);
        return res;
    }

    // 回溯算法核心函数，遍历子集问题的回溯树
    void backtrack(int[] candidates, int start,int target) {
        //base case
        // 
        if(curSum==target){
            res.add(new LinkedList<>(track));
            return;
        }

        //剪枝，不可
        if(curSum > target) return;

        // 回溯算法标准框架
        for (int i = start; i < candidates.length; i++) {

            if(i>start && candidates[i]==candidates[i-1]){
                continue;
            }

            // 做选择
            track.add(candidates[i]);
            curSum += candidates[i];

            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            backtrack(candidates,i+1,target);

            // 撤销选择
            track.removeLast();
            curSum -= candidates[i];
            }
        }
```

##### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

```java
    List<List<Integer>> res = new LinkedList<>();
    // 记录回溯算法的递归路径
    LinkedList<Integer> track = new LinkedList<>();
    int curSum = 0;

    // 主函数
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if(candidates.length==0) return res;
        //排序：让相邻的一样的节点去剪枝
        Arrays.sort(candidates);
        // System.out.println(Arrays.toString(candidates));
        backtrack(candidates,0,target);
        return res;
    }

    // 回溯算法核心函数，遍历子集问题的回溯树
    void backtrack(int[] candidates, int start,int target) {
        //base case
        // 
        if(curSum==target){
            res.add(new LinkedList<>(track));
            return;
        }

        //base case
        if(curSum > target) return;

        // 回溯算法标准框架
        for (int i = start; i < candidates.length; i++) {

            if(i>start && candidates[i]==candidates[i-1]){
                continue;
            }

            // 做选择
            track.add(candidates[i]);
            curSum += candidates[i];

            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            backtrack(candidates,i,target);

            // 撤销选择
            track.removeLast();
            curSum -= candidates[i];
            }
        }
```



#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

```java
    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> path = new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        used = new boolean[nums.length];
        //排序：为剪枝做准备
        Arrays.sort(nums);
        recur(nums,0);
        return res;
    }

    public void recur(int[] nums,int s){

        //base case
        if(path.size()==nums.length){
            res.add(new LinkedList(path));
            return;
        }

        for(int i = 0; i<nums.length;i++){
            //1.used
            //2.保持相邻元素相等，且相对位置不变
            if(used[i] || i > 0 && nums[i]==nums[i-1] && !used[i-1]){
                continue;
            }

            //选择
            used[i] = true;
            path.addLast(nums[i]);

            //递归
            recur(nums,i+1);

            //撤销选择
            path.removeLast();
            used[i] = false;
        }
    }
```



#### 5.3 元素无重可复选

**标准的全排列算法利用 `used` 数组进行剪枝，避免重复使用同一个元素。如果允许重复使用元素的话，直接放飞自我，去除所有 `used` 数组的剪枝逻辑就行了**。

```java
List<List<Integer>> res = new LinkedList<>();
LinkedList<Integer> track = new LinkedList<>();

public List<List<Integer>> permuteRepeat(int[] nums) {
    backtrack(nums);
    return res;
}

// 回溯算法核心函数
void backtrack(int[] nums) {
    // base case，到达叶子节点
    if (track.size() == nums.length) {
        // 收集叶子节点上的值
        res.add(new LinkedList(track));
        return;
    }

    // 回溯算法标准框架
    for (int i = 0; i < nums.length; i++) {
        // 做选择
        track.add(nums[i]);
        // 进入下一层回溯树
        backtrack(nums);
        // 取消选择
        track.removeLast();
    }
}
```



#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

[FloodFill 算法](https://mp.weixin.qq.com/s/Y7snQIraCC6PRhj9ZSnlzw)

题目：

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

思路：

在主函数中找到一个以1开头的节点，将结果++，然后利用dfs遍历相邻的陆地，用水把其淹了

解法：

```java
    public int numIslands(char[][] grid) {
        int res = 0;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]=='1'){
                    res++;
                    dfs(grid,i,j);
                }
            }
        }
        return res;
    }

    //从节点(i,j)开始进行dfs遍历，把相邻节点的陆地用水淹了
    public void dfs(char[][] grid,int i,int j){

        int[] dx = {1,-1,0,0};
        int[] dy = {0,0,1,-1};
        
        //base case
        if(i < 0 || i >= grid.length || j < 0 ||j >= grid[0].length){
            return;
        }

        if(grid[i][j]=='0'){
            return;
        }

        grid[i][j]='0';

        for(int k=0;k < 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            dfs(grid,x,y);
        }

    }
```

#### *[1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

>   先用水把边界淹了，因为矩阵边界里为陆地的，已经不是封闭岛屿了

题目：

二维矩阵 `grid` 由 `0` （土地）和 `1` （水）组成。岛是由最大的4个方向连通的 `0` 组成的群，封闭岛是一个 `完全` 由1包围（左、上、右、下）的岛。

思路：

封闭岛的周围是水，所以矩阵的边界都不是封闭岛，需要将边界的先用水淹掉，再按上题计算就可以了

解法：

```java
    public int closedIsland(int[][] grid) {
        //先淹边界的陆地

        for(int i = 0;i< grid[0].length;i++){
            //上
            dfs(grid,0,i);
            //下
            dfs(grid,grid.length-1,i);
        }

        for(int i = 0;i < grid.length;i++){
            //左
            dfs(grid,i,0);
            //右
            dfs(grid,i,grid[0].length-1);
        }

        int res = 0;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==0){
                    res++;
                    dfs(grid,i,j);
                }
            }
        }
        return res;
    }

    //从节点(i,j)开始进行dfs遍历，把相邻节点的陆地用水淹了
    public void dfs(int[][] grid,int i,int j){

        int[] dx = {1,-1,0,0};
        int[] dy = {0,0,1,-1};
        
        //base case
        if(i < 0 || i >= grid.length || j < 0 ||j >= grid[0].length){
            return;
        }

        if(grid[i][j]==1){
            return;
        }

        grid[i][j]=1;

        for(int k=0;k < 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            dfs(grid,x,y);
        }

    }
```

#### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)

题目：

给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量

说人话就是，求封闭岛屿的面积，封闭岛屿是由0包裹的

思路：

和1254一样,就是排除完边界的以后，不用递归

解法：

```java
    public int numEnclaves(int[][] grid) {
        
        //先淹边界的陆地

        for(int i = 0;i< grid[0].length;i++){
            //上
            dfs(grid,0,i);
            //下
            dfs(grid,grid.length-1,i);
        }

        for(int i = 0;i < grid.length;i++){
            //左
            dfs(grid,i,0);
            //右
            dfs(grid,i,grid[0].length-1);
        }

        int res = 0;
        //数一下剩下的陆地不用递归
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    res+=1;
                    // dfs(grid,i,j);
                }
            }
        }
        return res;
    }

    //从节点(i,j)开始进行dfs遍历，把相邻节点的陆地用水淹了
    public void dfs(int[][] grid,int i,int j){

        int[] dx = {1,-1,0,0};
        int[] dy = {0,0,1,-1};
        
        //base case
        if(i < 0 || i >= grid.length || j < 0 ||j >= grid[0].length){
            return;
        }

        if(grid[i][j]==0){
            return;
        }

        grid[i][j]=0;

        for(int k=0;k < 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            dfs(grid,x,y);
        }

    }
```

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

题目：

给你一个大小为 m x n 的二进制矩阵 grid 。

岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

岛屿的面积是岛上值为 1 的单元格的数目。

计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。

思路：

**大体思路和之前完全一样，只不过 `dfs` 函数淹没岛屿的同时，还应该想办法记录这个岛屿的面积**。给 `dfs` 函数设置返回值，记录每次淹没的陆地的个数

解法：

注意避坑

```java
    public int maxAreaOfIsland(int[][] grid) {
        int max = 0;
        for(int i = 0;i < grid.length;i++){
            for(int j=0;j < grid[0].length;j++){
                if(grid[i][j]==1){
                    int res = dfs(grid,i,j);
                    max = Math.max(res,max);
                }
            }
        }
        return max;
    }

    //从节点(i,j)开始进行dfs遍历，把相邻节点的陆地用水淹了
    
    public int dfs(int[][] grid,int i,int j){

        int[] dx = {1,-1,0,0};
        int[] dy = {0,0,1,-1};
        
        //base case
        if(i < 0 || i >= grid.length || j < 0 ||j >= grid[0].length){
            return 0;
        }

        if(grid[i][j]==0){
            return 0;
        }

        //当前节点
        grid[i][j]=0;
        int res = 1; //别忘加上当前的格子

        for(int k=0;k < 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            res += dfs(grid,x,y);
        }

        return res;
    }
```

#### *[1905. 统计子岛屿](https://leetcode-cn.com/problems/count-sub-islands/)

>   //需要先把不符合要求的子岛屿淹了，不能只是这样简单的判断，不然会有情况没排除，比如第一个示例的最后一个1，就会多算

题目：

给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。

如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。

请你返回 grid2 中 子岛屿 的 数目 。

思路：

当岛屿 `B` 中所有陆地在岛屿 `A` 中也是陆地的时候，岛屿 `B` 是岛屿 `A` 的子岛。

**反过来说，如果岛屿 `B` 中存在一片陆地，在岛屿 `A` 的对应位置是海水，那么岛屿 `B` 就不是岛屿 `A` 的子岛**。

那么，我们只要遍历 `grid2` 中的所有岛屿，把那些不可能是子岛的岛屿排除掉，剩下的就是子岛。

解法：

```java
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        //先淹掉不符合要求的岛屿：也就是grid2中岛屿位置（1）在grid1中的是海水（0）
        for(int i = 0;i < grid2.length;i++){
            for(int j = 0;j < grid2[0].length;j++){
                if(grid1[i][j]==0 && grid2[i][j]==1){
                    dfs(grid2,i,j);
                }
            }
        }

        //再统计符合要求的子岛屿
        int res = 0;
        for(int i = 0;i < grid2.length;i++){
            for(int j = 0;j < grid2[0].length;j++){
                if(grid2[i][j]==1){
                    res++;
                    dfs(grid2,i,j);
                }
            }
        }

        return res;
    }

    public void dfs(int[][] grid,int i ,int j){
        //base case
        if(i<0 || i>=grid.length ||j<0||j>=grid[0].length){
            return;
        }

        if(grid[i][j]==0){
            return;
        }

        grid[i][j] = 0;

        int[] dx = {-1,1,0,0};
        int[] dy = {0,0,-1,1};
        for(int k=0;k<4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            dfs(grid,x,y);
        }
    }
```

#### *694.不同岛屿的数量

>   这题是把图的遍历顺序进行序列化，是把四个方向(上下左右)抽象成1,2,3,4，选择为+（先序），撤销为负（后序）

题目：

题目还是输入一个二维矩阵，`0` 表示海水，`1` 表示陆地，这次让你计算 **不同的 (distinct)** 岛屿数量

思路:

很显然我们得想办法把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。**首先，对于形状相同的岛屿，如果从同一起点出发，`dfs` 函数遍历的顺序肯定是一样的**。因为遍历顺序是写死在你的递归函数里面的

![image-20220423133724888](file://F:\xrz\%E6%A1%8C%E9%9D%A2\Algorithm\notes\appendix\2%E6%80%BB%E7%BB%93%E2%80%94%E2%80%947DFS%E5%92%8C%E5%9B%9E%E6%BA%AF\image-20220423133724888.png?lastModify=1653276681)

如果我用分别用 `1, 2, 3, 4` 代表上下左右，用 `-1, -2, -3, -4` 代表上下左右的撤销，那么可以这样表示它们的遍历顺序：

2, 4, 1, -1, -4, -2

注意：

至于为什么初始调用 `dfs` 函数时的 `dir` 参数可以随意写，这里涉及 DFS 和回溯算法的一个细微差别，前文  [图算法基础](https://labuladong.gitee.io/algo/2/20/48/) 有写，这里就不展开了

因为回溯关注的是边，而不是节点，看回溯树

解法：

```java
int numDistinctIslands(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    // 记录所有岛屿的序列化结果
    HashSet<String> islands = new HashSet<>();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                // 淹掉这个岛屿，同时存储岛屿的序列化结果
                StringBuilder sb = new StringBuilder();
                // 初始的方向可以随便写，不影响正确性
                dfs(grid, i, j, sb, 666);
                islands.add(sb.toString());
            }
        }
    }
    // 不相同的岛屿数量
    return islands.size();
}

void dfs(int[][] grid, int i, int j, StringBuilder sb, int dir) {
    int m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n 
        || grid[i][j] == 0) {
        return;
    }
    // 前序遍历位置：进入 (i, j)
    grid[i][j] = 0;
    sb.append(dir).append(',');
    
    dfs(grid, i - 1, j, sb, 1); // 上
    dfs(grid, i + 1, j, sb, 2); // 下
    dfs(grid, i, j - 1, sb, 3); // 左
    dfs(grid, i, j + 1, sb, 4); // 右
    
    // 后序遍历位置：离开 (i, j)
    sb.append(-dir).append(',');
}

```



注意和图里的onPath的区别

这个 `onPath` 数组的操作很像  [回溯算法核心套路](https://labuladong.gitee.io/algo/4/29/105/) 中做「做选择」和「撤销选择」，区别在于位置：回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 `onPath` 数组的操作在 for 循环外面。

在 for 循环里面和外面唯一的区别就是对根节点的处理。

比如下面两种多叉树的遍历：

```

onpath
void traverse(TreeNode root) {
    if (root == null) return;
    System.out.println("enter: " + root.val);
    for (TreeNode child : root.children) {
        traverse(child);
    }
    System.out.println("leave: " + root.val);
}

回溯
void traverse(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        System.out.println("enter: " + child.val);
        traverse(child);
        System.out.println("leave: " + child.val);
    }
}

```

前者会正确打印所有节点的进入和离开信息，而后者唯独会少打印整棵树根节点的进入和离开信息。

**为什么回溯算法框架会用后者？因为回溯算法关注的不是节点，而是树枝**。



# 图

## 遍历

#### [797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

![image-20220418105146327](appendix\0刷题\image-20220418105146327.png)

```java
//因为是无环图，所以不用visit
    // 记录所有路径
    List<List<Integer>> res = new LinkedList<>();
    // 维护递归过程中经过的路径
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        //graph是邻接表,其长度表示有几个节点
        traverse(graph, 0);
        return res;  
    }

    //s为遍历的当前节点
    //多叉树的先序遍历
    public void traverse(int[][] graph, int s){
        //添加节点到路径
        path.addLast(s);

        //base case
        if(s==graph.length-1){
            res.add(new LinkedList<>(path));
            ////移除叶子节点(也就是题目中的n)
            /////如果此处注释掉，那么最后的removeLast也可以保证n节点的移除
            // path.removeLast();
            // return;
        }
        
        //递归每个相邻节点
        for(int v:graph[s]){
            traverse(graph,v);
        }

        //移除非叶子节点的节点(除n外的节点)
        path.removeLast();
    }
```



## 环检测

#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

- DFS

  ```java
      //两个节点不重复，这么做会减少计算量，如果碰到visited被标记为true，则说明前面已经对这个节点之后的样子做出判断了，无须再进行延伸，所以减少计算量
      boolean[] visited;//（代表以这个节点为头的路径是否有判断过）
      boolean[] onPath; //记录当前路径上存在的节点（只代表一条路径）
      //有环就是当前路径上存在两个一样的节点
  
      // 记录图中是否有环
      boolean hasCycle = false;
  
      public boolean canFinish(int numCourses, int[][] prerequisites) {
          List<Integer>[] graph = buildGraph(numCourses,prerequisites);
  
          visited = new boolean[numCourses];
          onPath = new boolean[numCourses];  
  
          //因为图不是连通的，所以需要遍历每个节点
          for (int i = 0; i < numCourses; i++) {
              // 遍历图中的所有节点
              traverse(graph, i);
          }
  
          // 只要没有循环依赖可以完成所有课程
          return !hasCycle;  
      }
  
      void traverse(List<Integer>[] graph, int i){
          //base case
          if(onPath[i]==true) {
              hasCycle = true;
              return;
          }
  
          if(visited[i]==true) return;
          
          //先序代码的位置
          visited[i] = true;
          onPath[i] = true;
          for(int v : graph[i]){
              traverse(graph,v);
          }
  
          onPath[i] = false;
      }
  
      List<Integer>[] buildGraph(int numCourses, int[][] prerequisites){
          //图中共有numCourses个节点
          //二维数组，采用邻接表的方式表示图
          List<Integer>[] graph = new LinkedList[numCourses];
          
          for(int i = 0;i < numCourses;i++){
              //graph[i]中放得i节点到其他的节点的节点列表
              graph[i] = new LinkedList<>();
          }
  
          for(int[] edge:prerequisites){
              int from= edge[1],to = edge[0];
              // 添加一条从 from 指向 to 的有向边
              // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
              graph[from].add(to);
          }
  
          return graph;
      }
  ```

- BFS

  ```java
      //bfs
      //构建入度
      int[] indegree;
      public boolean canFinish(int numCourses, int[][] prerequisites) {
          //建图 + 记录入度
          indegree = new int[numCourses];
          List<Integer>[] graph = buildGraph(numCourses,prerequisites);
  
          System.out.println(Arrays.toString(indegree));
          
          //根据入度初始化队列中的节点,找没有入度的点作为拓扑排序的起点
          Queue<Integer> q = new LinkedList<>();
          for(int i=0;i < indegree.length;i++){
              if(indegree[i]==0){
                  //节点i没有入度，即没有依赖的节点，可以直接学
                  //所以可以作为拓排序的起点，加入队列
                  q.offer(i);
              }
          }
  
          //记录遍历的节点个数,用来判断节点是否遍历完，也就是最后是不是会成环
          int cnt = 0;
  
          //两种遍历方式都可以
          //1.
          // while(!q.isEmpty()){
          //     //弹出节点cur，并把他指向的节点的入度减一
          //     cnt++;
          //     int cur = q.poll();
          //     for(int next : graph[cur]){
          //         indegree[next]--;
          //         if(indegree[next]==0){
          //             q.offer(next);
          //         } 
          //     }
          // }
  
          //2.
          while(!q.isEmpty()){
              //弹出节点cur，并把他指向的节点的入度减一
              int len = q.size();
              //每一层
              for(int i = 0;i < len;i++){
                  cnt++;
                  int cur = q.poll();
                  //操作，将所有指向节点的入度都减1
                  for(int next : graph[cur]){
                      indegree[next]--;
                      if(indegree[next]==0){
                          q.offer(next);
                      } 
                  }
              }
          }
  
          return cnt == numCourses;
      }
  
      List<Integer>[] buildGraph(int numCourses, int[][] prerequisites){
          //图中共有numCourses个节点
          //二维数组，采用邻接表的方式表示图
          List<Integer>[] graph = new LinkedList[numCourses];
          
          for(int i = 0;i < numCourses;i++){
              //graph[i]中放得i节点到其他的节点的节点列表
              graph[i] = new LinkedList<>();
          }
  
          for(int[] edge:prerequisites){
              int from= edge[1],to = edge[0];
              // 添加一条从 from 指向 to 的有向边
              // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
              graph[from].add(to);
              // 构建入度
              indegree[to]++;
          }
  
          return graph;
      }
  ```


## 拓扑排序

#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

- DFS

  后序逆序

  ```java
  //两个节点不重复，这么做会减少计算量，如果碰到visited被标记为true，则说明前面已经对这个节点之后的样子做出判断了，无须再进行延伸，所以减少计算量
      boolean[] visited;//（代表以这个节点为头的路径是否有判断过）
      boolean[] onPath; //记录当前路径上存在的节点（只代表一条路径）
      //有环就是当前路径上存在两个一样的节点
      // 记录后序遍历结果
      List<Integer> postorder = new ArrayList<>();
  
      // 记录图中是否有环
      boolean hasCycle = false;
  
      public int[] findOrder(int numCourses, int[][] prerequisites) {
          List<Integer>[] graph = buildGraph(numCourses,prerequisites);
  
          visited = new boolean[numCourses];
          onPath = new boolean[numCourses];
  
          //因为图不是连通的，所以需要遍历每个节点
          for (int i = 0; i < numCourses; i++) {
              // 遍历图中的所有节点
              traverse(graph, i);
          }
  
          if(hasCycle){
              return new int[]{};
          }
  
          Collections.reverse(postorder);
          int[] res = new int[numCourses];
          for(int i=0;i < numCourses;i++){
              res[i] = postorder.get(i);
          }
  
          return res;
      }
  
      void traverse(List<Integer>[] graph, int i){
          //base case
          if(onPath[i]==true) {
              hasCycle = true;
              return;
          }
  
          if(visited[i]==true) return;
          
          //先序代码的位置
          visited[i] = true;
          onPath[i] = true;
          for(int v : graph[i]){
              traverse(graph,v);
          }
  
          //后序代码的位置
          //加入当前节点，邻接表，也就是i
          postorder.add(i);
          onPath[i] = false;
      }
  
      List<Integer>[] buildGraph(int numCourses, int[][] prerequisites){
          //图中共有numCourses个节点
          //二维数组，采用邻接表的方式表示图
          List<Integer>[] graph = new LinkedList[numCourses];
          
          for(int i = 0;i < numCourses;i++){
              //graph[i]中放得i节点到其他的节点的节点列表
              graph[i] = new LinkedList<>();
          }
  
          for(int[] edge:prerequisites){
              int from= edge[1],to = edge[0];
              // 添加一条从 from 指向 to 的有向边
              // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
              graph[from].add(to);
          }
  
          return graph;
      }
  ```

- BFS

  ```java
      //bfs
      //构建入度
      int[] indegree;
      public int[] findOrder(int numCourses, int[][] prerequisites) {
          //建图 + 记录入度
          indegree = new int[numCourses];
          List<Integer>[] graph = buildGraph(numCourses,prerequisites);
  
          
          //根据入度初始化队列中的节点,找没有入度的点作为拓扑排序的起点
          Queue<Integer> q = new LinkedList<>();
          for(int i=0;i < indegree.length;i++){
              if(indegree[i]==0){
                  //节点i没有入度，即没有依赖的节点，可以直接学
                  //所以可以作为拓排序的起点，加入队列
                  q.offer(i);
              }
          }
  
          //记录遍历的节点个数,用来判断节点是否遍历完，也就是最后是不是会成环
          int cnt = 0;
          //记录结果
          int[] res = new int[numCourses];
  
          //两种遍历方式都可以
          //1.
          // while(!q.isEmpty()){
          //     //弹出节点cur，并把他指向的节点的入度减一
          //     res[cnt++] = cur;
          //     int cur = q.poll();
          //     for(int next : graph[cur]){
          //         indegree[next]--;
          //         if(indegree[next]==0){
          //             q.offer(next);
          //         } 
          //     }
          // }
  
          //2.
          while(!q.isEmpty()){
              //弹出节点cur，并把他指向的节点的入度减一
              int len = q.size();
              //每一层
              for(int i = 0;i < len;i++){
                  
                  int cur = q.poll();
                  // 弹出节点的顺序即为拓扑排序结果
                  res[cnt++] = cur;
                  //操作，将所有指向节点的入度都减1
                  for(int next : graph[cur]){
                      indegree[next]--;
                      if(indegree[next]==0){
                          q.offer(next);
                      } 
                  }
              }
          }
  		
          //看是否有环
          return cnt==numCourses? res : new int[]{};
      }
  
      List<Integer>[] buildGraph(int numCourses, int[][] prerequisites){
          //图中共有numCourses个节点
          //二维数组，采用邻接表的方式表示图
          List<Integer>[] graph = new LinkedList[numCourses];
          
          for(int i = 0;i < numCourses;i++){
              //graph[i]中放得i节点到其他的节点的节点列表
              graph[i] = new LinkedList<>();
          }
  
          for(int[] edge:prerequisites){
              int from= edge[1],to = edge[0];
              // 添加一条从 from 指向 to 的有向边
              // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
              graph[from].add(to);
              // 构建入度
              indegree[to]++;
          }
  
          return graph;
      }
  ```




# 数学

## 位运算

### **x & (x - 1) 用于消去x最后一位的1**

- **用 O(1) 时间检测整数 n 是否是 2 的幂次**

    N如果是2的幂次，则N满足两个条件：

    1.N >0

    2.N的二进制表示中只有一个1

    ```java
    2^0 = 1 = 0b0001
    2^1 = 2 = 0b0010
    2^2 = 4 = 0b0100
    ```

    因为N的二进制表示中只有一个1，所以使用N & (N - 1)将N唯一的一个1消去，应该返回0

    #### [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)

    如果存在一个整数 `x` 使得 `n == 2x` ，则认为 `n` 是 2 的幂次方。

    ```java
        public boolean isPowerOfTwo(int n) {
            if(n<=0) return false;
            
            int res = n & (n-1);
            return res==0?true:false;
        }
    ```

    

- **计算在一个 32 位的整数的二进制表式,有多少个1**

    不断使用 x & (x - 1) 消去x最后一位的1，计算总共消去了多少次即可

    #### [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

    ```java
        // you need to treat n as an unsigned value
        public int hammingWeight(int n) {
            int count = 0;
            while(n!=0){
                n = n&(n-1);
                count++;
            }
    
            return count;
        }
    ```

    


### a ^ b ^ b = a，a^0=a ，a^a=0

- **只有一个数出现一次，剩下都出现两次，找出出现一次的数**

    因为只有一个数恰好出现一个，剩下的都出现过两次，所以只要将所有的数异或起来，就可以得到唯一的那个数

    #### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

    ```java
        public int singleNumber(int[] nums) {
            int res = 0;
            for(int num:nums){
                res = num ^ res;
            }
            return res;
        }
    ```

-   [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

    为了容易理解，我们假设先把索引补一位，然后让每个元素和自己相等的索引相对应：

    ![image-20220505170034450](appendix/0刷题/image-20220505170034450.png)

    ```java
        public int missingNumber(int[] nums) {
            int res = 0;
            res = res ^nums.length;
            for(int i = 0;i < nums.length;i++){
                res = i^nums[i]^res;
            }
            return res;
        }
    ```

    

- **只有一个数出现一次，剩下都出现三次，找出出现一次的**

    方法一：状态机

    方法二：循环（计算模3结果，或等在一起）

    ![image-20220505170922710](appendix/0刷题/image-20220505170922710.png)

    ```java
        public int singleNumber(int[] nums) {
            int[] count = new int[32];
            //统计好每一位为1的数量
            for(int num:nums){
                for(int i =0;i<32;i++){
                    count[i] += num & 1;
                    num = num >>> 1;
                }
            }
            // System.out.println("count:" + Arrays.toString(count));
            int res = 0;
            for(int i=0;i < 32;i++){
                res <<= 1;
                // System.out.print("31-i:" + (31-i));
                // System.out.print("  count[31-i]:" + count[31-i]);
                res = res | count[31-i]%3;
                // System.out.print("    res1:" + res);
                // res <<= 1;
                // System.out.print("    res2:" + res);
                // System.out.println();
            }
    
            //不可以写成这样，因为当i= 31时，已经不能往右移了，但还是往右移了，已经越界了，再左移没用了,所以得写到前面
            //return res>>=1
            return res;
        }
    ```

    



- **只有两个数出现一次，剩下都出现两次，找出出现一次的**

    因为a!=b!=0，所以a和b必然至少有一位不一样，不妨设最右边的1不一样，按此规则进行分组，分别异或，由于其他数出现两次，就会被异或掉，分别只剩下a和b

### 异或

异或表示无进位加法，加法可表示为无进位加法和进位

- 不用加减乘除做加法

    无进位加法：异或  a

    进位：与运算后左移1  b

    （和 s ）=（非进位和 n ），（进位 c）

    当c ==0，返回n

[剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

利用位运算：将问题分解为【无进位加法+进位】

无进位加法：异或

进位：与运算后左移1（只是进位）

（和 s ）=（非进位和 n ）+（进位 c）。即可将 s=a+b转化为：s=a+b⇒s=n+c

循环求 n和 c ，直至进位 c=0；此时 s=n，返回 n 即可

不用考虑负数，负数是一样的

- 递归

    ```java
        public int add(int a, int b) {
            if(b==0) return a;
    
            return add(a^b, (a&b) << 1);
        }
    ```

- 迭代

    ```java
        //迭代
        public int add(int a, int b) {
            while(b != 0) { // 当进位为 0 时跳出
                int c = (a & b) << 1;  // c = 进位
                a ^= b; // a = 非进位和
                b = c; // b = 进位
            }
            return a;
        }
    ```



## 阶乘

[172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

题目：给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

解析：

两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 = 2 x 5。**问题转化为：`n!` 最多可以分解出多少个因子 2 和 5**？这个主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。**问题转化为：`n!` 最多可以分解出多少个因子 5**？

125！：

125/（5^1） = 25

125/（5^2） = 5

125/（5^3） = 1

所以最后为31个0

代码：

```java
    public int trailingZeroes(int n) {
        int res = 0;
        while(n!=0){
            res += n/5;
            n = n/5;
        }
        return res;
    }
```



[793. 阶乘函数后 K 个零](https://leetcode-cn.com/problems/preimage-size-of-factorial-zeroes-function/)

分析：

一个直观地暴力解法就是穷举呗，因为随着 `n` 的增加，`n!` 肯定是递增的，`trailingZeroes(n!)` 肯定也是递增的

**对于这种具有单调性的函数，用 for 循环遍历，可以用二分查找进行降维打击**

搜索有多少个 `n` 满足 `trailingZeroes(n) == K`，其实就是在问，**满足条件的 `n` 最小是多少，最大是多少，最大值和最小值一减，就可以算出来有多少个 `n` 满足条件了**，对吧？那不就是  [二分查找](https://labuladong.gitee.io/algo/2/18/26/) 中「搜索左侧边界」和「搜索右侧边界」这两个事儿嘛？这道题目实际上给了限制，`K` 是在 `[0, 10^9]` 区间内的整数，也就是说，`trailingZeroes(n)` 的结果最多可以达到 `10^9`。

然后我们可以反推，当 `trailingZeroes(n)` 结果为 `10^9` 时，`n` 为多少？这个不需要你精确计算出来，你只要找到一个数 `hi`，使得 `trailingZeroes(hi)` 比 `10^9` 大，就可以把 `hi` 当做正无穷，作为搜索区间的上界。

刚才说了，`trailingZeroes` 函数是单调函数，那我们就可以猜，先算一下 `trailingZeroes(INT_MAX)` 的结果，比 `10^9` 小一些，那再用 `LONG_MAX` 算一下，远超 `10^9` 了，所以 `LONG_MAX` 可以作为搜索的上界。

**注意为了避免整型溢出的问题，`trailingZeroes` 函数需要把所有数据类型改成 long**：

**在区间 `[0, LONG_MAX]` 中寻找满足 `trailingZeroes(n) == K` 的左侧边界和右侧边界**。

代码：

```java
    // //利用二分法进行优化，求左右边界
    // //暴力遍历会超时
    // public int preimageSizeFZF(int k) {
    //     int cnt = 0;
    //     long tmp = k;
    //     long n = 0;
    //     while(tmp <= k){
    //         tmp = trailingZeroes(n++);
    //         if(tmp == k) cnt++;
    //         if(tmp > k) break;
    //     }
    //     return cnt;
    // }

    public int preimageSizeFZF(int k) {
        return (int)(right_bound(k)-left_bound(k)+1);
    }


    //利用二分法查找左右边界n的左右边界
    //左边界为0,右边界推演出来为Long.MAX_VALUE
    //查找左边界
    //左闭右开
    long left_bound(int target){
        long low = 0,high = Long.MAX_VALUE;
        while(low < high){
            long mid = low +(high-low)/2;
            if(trailingZeroes(mid) < target){
                low = mid + 1;
            }else if(trailingZeroes(mid) > target){
                high = mid;
            }else{
                high = mid;
            }
        } 
        return low;
    }

    //查找右边界
    long right_bound(int target){
        long low = 0,high = Long.MAX_VALUE;
        while(low < high){
            long mid = low +(high-low)/2;
            if(trailingZeroes(mid) < target){
                low = mid + 1;
            }else if(trailingZeroes(mid) > target){
                high = mid;
            }else{
                low = mid + 1;
            }
        } 
        return low-1;
    }

    long trailingZeroes(long n) {
        long res = 0;
        while(n!=0){
            res += n/5;
            n = n/5;
        }
        return res;
    }
```

## 素数判断

 [204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

定义：如果一个数如果只能被 1 和它本身整除，那么这个数就是素数。

解析：

```java
12 = 2 × 6
12 = 3 × 4
12 = sqrt(12) × sqrt(12)
12 = 4 × 3
12 = 6 × 2
```

如果在 `[2,sqrt(n)]` 这个区间之内没有发现可整除因子，就可以直接断定 `n` 是素数

筛选法:素数的倍数一定不是素数

冗余：

比如 `n = 25`，`i = 5` 时算法会标记 5 × 2 = 10，5 × 3 = 15 等等数字，但是这两个数字已经被 `i = 2` 和 `i = 3` 的 2 × 5 和 3 × 5 标记了。

我们可以稍微优化一下，让 `j` 从 `i` 的平方开始遍历，而不是从 `2 * i` 开始

```java
    public int countPrimes(int n) {
        boolean[] flag  = new boolean[n];
        Arrays.fill(flag,true);

        for(int i = 2;i*i <n;i++){
            if(flag[i]){
                //如果i是素数，则它的倍数一定不是
                for(int j = i*i;j < n;j+=i){
                    flag[j] = false;
                }
            }
        }

        //计算结果,记得从2开始
        int count = 0;
        for(int i = 2;i<n;i++){
            if(flag[i]){
                count++;
            }
        }

        return count;
    }
```



## 超级次方

 [372. 超级次方](https://leetcode-cn.com/problems/super-pow/)

题目：你的任务是计算 `ab` 对 `1337` 取模，`a` 是一个正整数，`b` 是一个非常大的正整数且会以数组形式给出。

难点：

**一是如何处理用数组表示的指数**？

![image-20220506094816489](appendix/0刷题/image-20220506094816489.png)



**二是如何得到求模之后的结果**？

```java
(a * b) % k = (a % k)(b % k) % k
```

**三是如何高效进行幂运算**？

![image-20220506095131068](appendix/0刷题/image-20220506095131068.png)

代码：

```java
    public int superPow(int a, int[] b) {
        if(a==1) return 1;
        int len = b.length;
        return superRecur(a,b,len-1);
    }

    //拆分
    public int superRecur(int a,int[] b,int idx){
        if(idx == -1) return 1;
        int x1 = myPow(a,b[idx]);

        int x2 = myPow(superRecur(a,b,idx-1),10);

        return (x1*x2)%1337;
    }

    //快速幂,b是幂
	//注意此处求余，只要是a的地方都求余
    public int myPow(int a,int b){
        int res = 1;
        a = a%1337;
        while(b != 0){
            if((b&1)==1){
                res*= a%1337;
            }
            //base每次向左移，幂逐位取
            a = a*a%1337;
            b = b>>1;
        }

        return res%1337;
    }
```



## 同时寻找缺失和重复的元素

 [645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)

```java
    public int[] findErrorNums(int[] nums) {
        //排序
        Arrays.sort(nums);
        // System.out.println(Arrays.toString(nums));

        int pre = 0;
        int[] res = new int[2];
        for(int i=0;i<nums.length;i++){
            //重复的数字,相邻
            if(nums[i]==pre){
                res[0] = nums[i];
            //缺失的元素，相差大于1
            }else if(nums[i]-pre > 1){
                res[1] = pre+1;
            }
            pre = nums[i];

            //如果缺失的是最后一个元素
            if(nums[nums.length-1]!=nums.length){
                res[1] = nums.length;
            }
        }
        return res;
    }
```



## 随机抽取元素

**蓄水池抽样算法**

若 `nums` 并不是在初始化时完全给出，而是持续以「流」的形式给出，且数据流的很长，不便进行预处理的话，我们只能使用「蓄水池抽样」的方式求解。

 [382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

题目：

给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 **被选中的概率一样** 。

思路：

**当遇到第 `i` 个元素时，应该有 `1/i` 的概率选择该元素，`1 - 1/i` 的概率保持原有的选择**。

![image-20220506122913909](appendix/0刷题/image-20220506122913909.png)

第 `i` 个元素被选择的概率是 `1/i`，不选择`i+1`的元素，以此类推，相乘就是第 `i` 个元素最终被选中的概率，就是 `1/n`。

代码：

```java
class Solution {
    ListNode head;

    public Solution(ListNode head) {
        this.head = head;
    }
    
    public int getRandom() {
        //随机数
        Random r = new Random();
        int cnt = 0, res = 0;
        ListNode cur = this.head;
        while(cur!=null){
            // 生成一个 [0, cnt) 之间的整数
            // 这个整数等于 0 的概率就是 1/cnt
            cnt++;
            if(r.nextInt(cnt)==0){
                res = cur.val;
            }
            cur = cur.next;
        }
        return res;
    }
}
```

题目：

```java
/* 返回链表中 k 个随机节点的值 */
int[] getRandom(ListNode head, int k) {
    Random r = new Random();
    int[] res = new int[k];
    ListNode p = head;

    // 前 k 个元素先默认选上
    for (int j = 0; j < k && p != null; j++) {
        res[j] = p.val;
        p = p.next;
    }

    int i = k;
    // while 循环遍历链表
    while (p != null) {
        // 生成一个 [0, i) 之间的整数
        int j = r.nextInt(++i);
        // 这个整数小于 k 的概率就是 k/i
        if (j < k) {
            res[j] = p.val;
        }
        p = p.next;
    }
    return res;
}
```





 [398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)

题目：
给你一个可能含有 **重复元素** 的整数数组 `nums` ，请你随机输出给定的目标数字 `target` 的索引。你可以假设给定的数字一定存在于数组中。

代码：

```java
class Solution {

    int[] nums;

    public Solution(int[] nums) {
        this.nums = nums;
    }
    
    public int pick(int target) {
        Random r = new Random();
        int cnt = 0, res = 0;
        for(int i = 0; i < nums.length;i++){
            if(nums[i]==target){
                cnt++;
                if(r.nextInt(cnt)==0) res = i;
            }
        }
        return res;
    }
}
```



## 脑筋急转弯

[292. Nim 游戏](https://leetcode-cn.com/problems/nim-game/)

代码：

```java
    public boolean canWinNim(int n) {
        return n % 4 != 0;
    }
```



 [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

代码：

```java
//先手足够聪明 必赢
boolean stoneGame(int[] piles) {
    return true;
}
```



 [319. 灯泡开关](https://leetcode-cn.com/problems/bulb-switcher/)

代码：

```java
    public int bulbSwitch(int n) {
        return (int)Math.sqrt(n);
    }
```



## 洗牌算法

**前提：产生的结果必须有 n! 种可能，否则就是错误的。**

```java
// 得到一个在闭区间 [min, max] 内的随机整数
int randInt(int min, int max);

void shuffle(int[] arr) {
    int n = arr.length();
    for (int i = 0 ; i < n; i++) {
        int rand = randInt(i, n - 1);
        swap(arr[i], arr[rand]);
    }
}
```



# 贪心

## 区间调度（最大不相交子集）

```java
public int intervalSchedule(int[][] intvs) {
    if (intvs.length == 0) return 0;
    // 按 end 升序排序
    Arrays.sort(intvs, new Comparator<int[]>() {
        public int compare(int[] a, int[] b) {
            return a[1] - b[1];
        }
    });
    // 至少有一个区间不相交
    int count = 1;
    // 排序后，第一个区间就是 x
    int x_end = intvs[0][1];
    for (int[] interval : intvs) {
        int start = interval[0];
        if (start >= x_end) {
            // 找到下一个选择的区间了
            count++;
            x_end = interval[1];
        }
    }
    return count;
}

```

#### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

```java
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals.length==0) return 0;

        //按end进行排序
        //容易发生溢出
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int a[],int b[]){
                return a[1]-b[1];
            }
        });

        int count = 0;
        int x_end = intervals[0][1];
        for(int[] interval:intervals){
            int s = interval[0];
            if(s < x_end){
                count++;
            }else{
                //大于的时候更新
                x_end = interval[1];
            }
        }

        return count-1;
    }
```

#### [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

这个问题和区间调度算法一模一样！如果最多有 `n` 个不重叠的区间，那么就至少需要 `n` 个箭头穿透所有区间。只是有一点不一样，在 `intervalSchedule` 算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠。

![image-20220503133619674](appendix/0刷题/image-20220503133619674.png)

```java
    public int findMinArrowShots(int[][] intervals) {
        if(intervals.length==0) return 0;

        //按end进行排序
        //直接return a[1]-b[1];会发生溢出
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] point1, int[] point2) {
                if (point1[1] > point2[1]) {
                    return 1;
                } else if (point1[1] < point2[1]) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
       
    //    System.out.print(Arrays.deepToString(intervals));

       int count = 1;
       int x_end = intervals[0][1];
       for(int[] interval:intervals){
            int s = interval[0];
            //计算最大的不重叠子区间的个数，注意边界
            if(s > x_end){
                count++;
                x_end = interval[1];
            }
        }

        return count;
    }
```



## 区间问题（不是贪心）

技巧：

**1、排序**。常见的排序方法就是按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序。当然，如果你非要按照终点排序，无非对称操作，本质都是一样的。

**2、画图**。就是说不要偷懒，勤动手，两个区间的相对位置到底有几种可能，不同的相对位置我们的代码应该怎么去处理

### 区间覆盖

#### [1288. 删除被覆盖区间](https://leetcode-cn.com/problems/remove-covered-intervals/)

![image-20220503145029921](appendix/0刷题/image-20220503145029921.png)

```java
int removeCoveredIntervals(int[][] intvs) {
    // 按照起点升序排列，起点相同时降序排列
    Arrays.sort(intvs, (a, b) -> {
        if (a[0] == b[0]) {
            return b[1] - a[1];
        }
        return a[0] - b[0]; 
    });

    // 记录合并区间的起点和终点
    int left = intvs[0][0];
    int right = intvs[0][1];
    
    int res = 0;
    for (int i = 1; i < intvs.length; i++) {
        int[] intv = intvs[i];
        // 情况一，找到覆盖区间
        if (left <= intv[0] && right >= intv[1]) {
            res++;
        }
        // 情况二，找到相交区间，合并
        if (right >= intv[0] && right <= intv[1]) {
            right = intv[1];
        }
        // 情况三，完全不相交，更新起点和终点
        if (right < intv[0]) {
            left = intv[0];
            right = intv[1];
        }
    }
    
    return intvs.length - res;
}

```

![image-20220503145051546](appendix/0刷题/image-20220503145051546.png)

解法：

```java
    public int removeCoveredIntervals(int[][] intervals) {
        //起点按照升序排列，起点相同，则终点按降序
        Arrays.sort(intervals,(a,b)->{
            if(a[0]==b[0]){
                return b[1]-a[1];
            }else{
                return a[0]-b[0];
            }
        });

        //删除没有被覆盖的区间
        int left = intervals[0][0];
        int right = intervals[0][1];
        int count = 1;
        for(int i = 1;i<intervals.length;i++){
            int[] cur = intervals[i];
            //非覆盖区间
            if(right < cur[1]){
                ++count;
                right = cur[1];
            }
        }
        return count;
    }
```



### 区间合并

#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

![image-20220503145455762](appendix/0刷题/image-20220503145455762.png)

```java
    public int[][] merge(int[][] intervals) {
        if(intervals.length==0) return new int[0][2];

        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[0]-b[0];
            }
        });

        List<int[]> res = new ArrayList<int[]>();
        for(int i = 0;i<intervals.length;i++){
            int left = intervals[i][0];
            int right = intervals[i][1];
            //不相交
            if(res.size()==0 || res.get(res.size()-1)[1]<left){
                res.add(new int[]{left,right});
            }else{ //相交
                res.get(res.size()-1)[1] = Math.max(res.get(res.size()-1)[1],right);
            }
        }

        return res.toArray(new int[res.size()][]);
    }
```





### 区间交集

#### [间列表的交集](https://leetcode-cn.com/problems/interval-list-intersections/)

首先，**对于两个区间**，我们用`[a1,a2]`和`[b1,b2]`表示在`A`和`B`中的两个区间，那么什么情况下这两个区间**没有交集**呢：

![image-20220503145946377](appendix/0刷题/image-20220503145946377.png)

只有这两种情况，写成代码的条件判断就是这样：

```
if b2 < a1 or a2 < b1:
    [a1,a2] 和 [b1,b2] 无交集
```

那么，什么情况下，两个区间存在交集呢？根据命题的否定，上面逻辑的否命题就是存在交集的条件：

```
# 不等号取反，or 也要变成 and
if b2 >= a1 and a2 >= b1:
    [a1,a2] 和 [b1,b2] 存在交集
```

接下来，两个区间存在交集的情况有哪些呢？穷举出来：

![image-20220503150001298](appendix/0刷题/image-20220503150001298.png)

我们惊奇地发现，交集区间是有规律的！如果交集区间是`[c1,c2]`，那么`c1=max(a1,b1)`，`c2=min(a2,b2)`！这一点就是寻找交集的核心，我们把代码更进一步：

```
while i < len(A) and j < len(B):
    a1, a2 = A[i][0], A[i][1]
    b1, b2 = B[j][0], B[j][1]
    if b2 >= a1 and a2 >= b1:
        res.append([max(a1, b1), min(a2, b2)])
    # ...
```

最后一步，我们的指针`i`和`j`肯定要前进（递增）的，什么时候应该前进呢？

是否前进，只取决于`a2`和`b2`的大小关系：

```
while i < len(A) and j < len(B):
    # ...
    if b2 < a2:
        j += 1
    else:
        i += 1
```

解法：

```java
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        int i =0,j = 0;
        List<int[]> res = new ArrayList<>();

        //题目说已经排好序了，所以不用继续排序了
        while(i < firstList.length && j < secondList.length){
            int a1 = firstList[i][0],a2 = firstList[i][1];
            int b1 = secondList[j][0],b2 = secondList[j][1];
            int c1 = Math.max(a1,b1);
            int c2 = Math.min(a2,b2);
            //如果这个区间成立
            if(c1 <= c2){
                res.add(new int[]{c1,c2});
            }
        
            //指针前进
            if(a2 < b2){
                i++;
            }else{
                j++;
            }
        }

        return res.toArray(new int[res.size()][]);
    }
```

```java
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        int i =0,j = 0;
        List<int[]> res = new ArrayList<>();

        //题目说已经排好序了，所以不用继续排序了
        while(i < firstList.length && j < secondList.length){
            int a1 = firstList[i][0],a2 = firstList[i][1];
            int b1 = secondList[j][0],b2 = secondList[j][1];
            //两个区间存在交集
            if(b1 <= a2  && a1 <= b2){
                int c1 = Math.max(a1,b1);
                int c2 = Math.min(a2,b2);
                res.add(new int[]{c1,c2});
            }
            //指针前进
            if(b2 < a2){
                j++;
            }else{
                i++;
            }
        }

        return res.toArray(new int[res.size()][]);
    }
```



# 分治算法

 [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)

```java
    //返回当前表达式，只单层嵌套的可能的计算结果
    //增加备忘录进行优化,当前表达式+结果
    HashMap<String,List<Integer>> memo = new HashMap<>();
    public List<Integer> diffWaysToCompute(String expression) {

        if(memo.containsKey(expression)) return memo.get(expression);
        //本次表达式的返回结果
        List<Integer> res = new LinkedList<>();
        for(int i=0;i < expression.length();i++){
            char c = expression.charAt(i);
            //如果是运算符就进行分割
            //分
            if(c=='+' || c=='-' || c=='*'){
                List<Integer> left =  diffWaysToCompute(expression.substring(0,i));
                List<Integer> right =  diffWaysToCompute(expression.substring(i+1,expression.length()));
                //治
                for(int l:left){
                    for(int r:right){
                        if(c=='+') res.add(l+r);
                        else if(c=='-') res.add(l-r);
                        else if(c=='*') res.add(l*r);
                    }
                }
            }
        }

        //base case
        //说明表达式里没有一个运算符了,就是一个数的时候，即为答案
        if(res.isEmpty()){
            res.add(Integer.parseInt(expression));
        }

        memo.put(expression,res);
        return res;
    }
```

