# 存储方式: 数组

数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）

# 技巧

## 双指针

双指针技巧是经常用到的，双指针技巧主要分为两类：**左右指针**和**快慢指针**。所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行，一快一慢。

### 快慢指针

#### 1. 原地修改数组

#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)（1）

题目：原地删除重复元素

思路：

让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就赋值给 `slow` 并让 `slow` 前进一步。

这样，就保证了 `nums[0..slow]` 都是无重复的元素，当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]` 就是整个数组去重之后的结果。

#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)（2）

题目：原地删除重复元素

#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)（1）

题目：给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

思路：如果 `fast` 遇到值为 `val` 的元素，则直接跳过，否则就赋值给 `slow` 指针，并让 `slow` 前进一步。保证了 `nums[0..slow]` 都是无val的元素。nums[slow]` 赋值然后再给 `slow++`，这样可以保证 `nums[0..slow-1]` 是不包含值为 `val` 的元素的，最后的结果数组长度就是 `slow。

#### [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)（2）

题目：给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

思路：

相当于移除 `nums` 中的所有 0，然后再把后面的元素都赋值为 0 即可。

#### 2.滑动窗口

要点：

1) 只往一个方向动，从左往右

2. 主要涉及字符串数组
3. 一般设计为左闭右开，合理。 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

模板：**扩大窗口就是right++，收缩窗口就是left++**


```c++
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移（增大）窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移（缩小）窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)（1hashmap存词频）

题目：给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

思路：

1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

> PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 `left = right = 0` 时区间 `[0, 0)` 中没有元素，但只要让 `right` 向右移动一位，区间 `[0, 1)` 就包含一个元素 `0` 了。如果你设置为两端都开的区间，那么让 `right` 向右移动一位后开区间 `(0, 1)` 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 `[0, 0]` 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。

2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。

注意：

1. 初始化 `window` 和 `need` 两个哈希表，记录窗口中的字符和需要凑齐的字符。**其中 `valid` 变量表示窗口中满足 `need` 条件的字符个数**，如果 `valid` 和 `need.size` 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 `T`。

2. **套模板思考**：

   1、当移动 `right` 扩大窗口，即加入字符时，应该更新哪些数据？

   2、什么条件下，窗口应该暂停扩大，开始移动 `left` 缩小窗口？

   3、当移动 `left` 缩小窗口，即移出字符时，应该更新哪些数据？

   4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？
   
   ```tex
   四个问题：
   right扩大时，更新windows,valid
   left在valid==need.size()缩小窗口，(right-left < minlen)记录更小的结果
   left缩小窗时，更新windows,valid,start,minlen
   结果在缩小窗口时获取
   ```
   
   

#### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)（2）

题目：

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true` ；否则，返回 `false` 。

换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

思路：

1、本题移动 `left` 缩小窗口的时机是窗口大小大于 `t.size()` 时，应为排列嘛，显然长度应该是一样的。

2、当发现 `valid == need.size()` 时，就说明窗口中就是一个合法的排列，所以立即返回 `true`。

至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。

```tex
四个问题：
right扩大时，更新windows,valid
left在窗口大小大于t.size()时收缩，等于时返回结果
left缩小窗时，更新windows,valid
结果在缩小窗口时获取
```

#### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)（3）

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)（hashmap存索引值，不能单纯套模板）

题目：给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

思路：

1，左闭右开，hashmap中放的是索引值而不是单纯的次数
        

2，扩大right
        

3，left缩小窗口的时候，要注意不是单纯的left++，要判断当前left的位置和这个字符上一次出现的索引+1的大小，考虑abba和pwwkew的情况
        4，结果在缩小窗口之后
        

5，更新添加的hashmap的位置

```tex
四个问题：
right扩大时，暂时什么也不更新
left在出现重复字符时收缩
left缩小时，暂时什么也不更新
结果在缩小窗口之后获取，然后要更新windows和maxlen
```



### 左右指针 

#### 1. 二分查找

- 基础框架

  ```java
  int binarySearch(int[] nums, int target) {
      int left = 0, right = ...;
  
      while(...) {
          int mid = left + (right - left) / 2;
          if (nums[mid] == target) {
              ...
          } else if (nums[mid] < target) {
              left = ...
          } else if (nums[mid] > target) {
              right = ...
          }
      }
      return ...;
  }
  ```

  - **为什么 while 循环的条件中是 <=，而不是 <**？

    搜索区间[left, right]，**搜索区间为空的时候应该终止**while循环。

    1）`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**。

    2）`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索

  - **为什么 `left = mid + 1`，`right = mid - 1`？**

    发现索引 `mid` 不是要找的 `target`，去搜索区间 `[left, mid-1]` 或者区间 `[mid+1, right]`

  - **此算法有什么缺陷**？

    不能寻找左右侧边界的二分搜索

- 寻找左边界的二分

  ```java
  int left_bound(int[] nums, int target) {
      if (nums.length == 0) return -1;
      int left = 0;
      int right = nums.length; // 注意
      
      while (left < right) { // 注意
          int mid = left + (right - left) / 2;
          if (nums[mid] == target) {
              right = mid;
          } else if (nums[mid] < target) {
              left = mid + 1;
          } else if (nums[mid] > target) {
              right = mid; // 注意
          }
      }
      return left;
  }
  //不会存在越界处理，左闭右闭要单独处理越界
  ```

  - **为什么 while 中是 `<` 而不是 `<=`**?

    用相同的方法分析，因为 `right = nums.length` 而不是 `nums.length - 1`。因此每次循环的「搜索区间」是 `[left, right)` 左闭右开。

    `while(left < right)` 终止的条件是 `left == right`，此时搜索区间 `[left, left)` 为空，所以可以正确终止

  - 左侧边界的含义

    这个索引 1 的含义可以解读为「`nums` 中小于 2 的元素有 1 个」。

    比如对于有序数组 `nums = [2,3,5,7]`, `target = 1`，算法会返回 0，含义是：`nums` 中小于 1 的元素有 0 个。

    再比如说 `nums = [2,3,5,7], target = 8`，算法会返回 4，含义是：`nums` 中小于 8 的元素有 4 个。

  - **为什么 `left = mid + 1`，`right = mid` ？和之前的算法不一样**？

    因为我们的「搜索区间」是 `[left, right)` 左闭右开，所以当 `nums[mid]` 被检测之后，下一步应该去 `mid` 的左侧或者右侧区间搜索，即 `[left, mid)` 或 `[mid + 1, right)`。

  - **为什么该算法能够搜索左侧边界**？

    对于 `nums[mid] == target` 这种情况的处理：

    ```java
        if (nums[mid] == target)
            right = mid;
    ```

    可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 `right`，在区间 `[left, mid)` 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。

  - **为什么返回 `left` 而不是 `right`**？

    都是一样的，因为 while 终止的条件是 `left == right`

- 寻找右侧边界的二分

  ```java
  int right_bound(int[] nums, int target) {
      if (nums.length == 0) return -1;
      int left = 0, right = nums.length;
      
      while (left < right) {
          int mid = left + (right - left) / 2;
          if (nums[mid] == target) {
              left = mid + 1; // 注意
          } else if (nums[mid] < target) {
              left = mid + 1;
          } else if (nums[mid] > target) {
              right = mid;
          }
      }
      return left - 1; // 注意
  }
  ```

  - **为什么这个算法能够找到右侧边界**？

    关键点还是这里：

    ```java
    if (nums[mid] == target) {
        left = mid + 1;
    ```

    当 `nums[mid] == target` 时，不要立即返回，而是增大「搜索区间」的左边界 `left`，使得区间不断向右靠拢，达到锁定右侧边界的目的。

  - **为什么最后返回 `left - 1` 而不像左侧边界的函数，返回 `left`？**

    while 循环的终止条件是 `left == right`，也可以返回`right-1`。因为我们对 `left` 的更新必须是 `left = mid + 1`，就是说 while 循环结束时，`nums[left]` 一定不等于 `target` 了，而 `nums[left-1]` 可能是 `target`

    ```java
    // 增大 left，锁定右侧边界
    if (nums[mid] == target) {
        left = mid + 1;
        // 这样想: mid = left - 1
    ```

- 总结

  **第一个，最基本的二分查找算法**：

  ```python
  因为我们初始化 right = nums.length - 1
  所以决定了我们的「搜索区间」是 [left, right]
  所以决定了 while (left <= right)
  同时也决定了 left = mid+1 和 right = mid-1
  
  因为我们只需找到一个 target 的索引即可
  所以当 nums[mid] == target 时可以立即返回
  ```

  **第二个，寻找左侧边界的二分查找**：

  ```python
  因为我们初始化 right = nums.length
  所以决定了我们的「搜索区间」是 [left, right)
  所以决定了 while (left < right)
  同时也决定了 left = mid + 1 和 right = mid
  
  因为我们需找到 target 的最左侧索引
  所以当 nums[mid] == target 时不要立即返回
  而要收紧右侧边界以锁定左侧边界
  ```

  **第三个，寻找右侧边界的二分查找**：

  ```python
  因为我们初始化 right = nums.length
  所以决定了我们的「搜索区间」是 [left, right)
  所以决定了 while (left < right)
  同时也决定了 left = mid + 1 和 right = mid
  
  因为我们需找到 target 的最右侧索引
  所以当 nums[mid] == target 时不要立即返回
  而要收紧左侧边界以锁定右侧边界
  
  又因为收紧左侧边界时必须 left = mid + 1
  所以最后无论返回 left 还是 right，必须减一
  ```

   左闭右闭

  ```java
  int binary_search(int[] nums, int target) {
      int left = 0, right = nums.length - 1; 
      while(left <= right) {
          int mid = left + (right - left) / 2;
          if (nums[mid] < target) {
              left = mid + 1;
          } else if (nums[mid] > target) {
              right = mid - 1; 
          } else if(nums[mid] == target) {
              // 直接返回
              return mid;
          }
      }
      // 直接返回
      return -1;
  }
  
  int left_bound(int[] nums, int target) {
      int left = 0, right = nums.length - 1;
      while (left <= right) {
          int mid = left + (right - left) / 2;
          if (nums[mid] < target) {
              left = mid + 1;
          } else if (nums[mid] > target) {
              right = mid - 1;
          } else if (nums[mid] == target) {
              // 别返回，锁定左侧边界
              right = mid - 1;
          }
      }
      // 最后要检查 left 越界的情况
      if (left >= nums.length || nums[left] != target) {
          return -1;
      }
      return left;
  }
  
  int right_bound(int[] nums, int target) {
      int left = 0, right = nums.length - 1;
      while (left <= right) {
          int mid = left + (right - left) / 2;
          if (nums[mid] < target) {
              left = mid + 1;
          } else if (nums[mid] > target) {
              right = mid - 1;
          } else if (nums[mid] == target) {
              // 别返回，锁定右侧边界
              left = mid + 1;
          }
      }
      // 最后要检查 right 越界的情况
      if (right < 0 || nums[right] != target) {
          return -1;
      }
      return right;
  }
  ```

#### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

先找左边界，再找右边界

#### 2. 其他

#### 3. 从中心向两端扩

```tex
//中心扩展法
    //从左到右，依次以字符为中心轴进行判断，双指针
    //但是要注意偶数长度的子串的遍历，并不是以某个字符为轴对称，需要将中心点由一个扩展到2个
    //例如：ababa
    //abab这个字符串并不是某个字符的中心点，无法遍历到，则无法判断是否是回文
```

#### [647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)



