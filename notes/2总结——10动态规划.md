# 动态规划

**动态规划问题的一般形式就是求最值**。比如说让你求**最长**递增子序列呀，**最小**编辑距离呀等等。

**存在「重叠子问题」**：没有重叠子问题，所以我们简单地求最值肯定用不出动态规划（备忘录优化）

​	**可以通过先将递归框架抽出来看，有无值会使递归参数重合**

**具备「最优子结构」**：子问题独立，可以改造

**正确的「状态转移方程」**

斐波那契数列o(2^n)

```java
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}

```

**带备忘录的递归解法**(o(n))

```java
int fib(int N) {
    // 备忘录全初始化为 0
    int[] memo = new int[N + 1];
    // 进行带备忘录的递归
    return helper(memo, N);
}

int helper(int[] memo, int n) {
    // base case
    if (n == 0 || n == 1) return n;
    // 已经计算过，不用再计算了
    if (memo[n] != 0) return memo[n];
    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
}

```

![image-20220427084709646](appendix\2总结——10动态规划\image-20220427084709646.png)

![image-20220427084721469](appendix\2总结——10动态规划\image-20220427084721469.png)

**`dp` 数组的迭代（递推）解法**

```java
int fib(int N) {
    if (N == 0) return 0;
    int[] dp = new int[N + 1];
    // base case
    dp[0] = 0; dp[1] = 1;
    // 状态转移
    for (int i = 2; i <= N; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[N];
}

```

![image-20220427084840237](appendix\2总结——10动态规划\image-20220427084840237.png)

> - dp[i]:
>   - 确定状态：原问题和子问题中变化的变量（目标金额）
>
> - 初始值：
> - 结果：





#### 子序列问题结题模板

你求一个**最长子序列**，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**。



**`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度**





## debug 递归的小技巧

https://labuladong.gitee.io/algo/3/23/74/

```java
// 全局变量，记录递归函数的递归层数
int count = 0;

// 输入 n，打印 n 个 tab 缩进
void printIndent(int n) {
    for (int i = 0; i < n; i++) {
        printf("   ");
    }
}
```

例子：

- 原本代码

```java
int dp(string& ring, int i, string& key, int j) {
    /* base case */
    if (j == key.size()) {
        return 0;
    }

    /* 状态转移 */
    int res = INT_MAX;
    for (int k : charToIndex[key[j]]) {
        res = min(res, dp(ring, j, key, i + 1));
    }

    return res;
}

```

- 添加调试（在递归函数开头，和每个return语句前加）

```java
int count = 0;
void printIndent(int n) {
    for (int i = 0; i < n; i++) {
        printf("   ");
    }
}

int dp(string& ring, int i, string& key, int j) {
    // printIndent(count++);
    // printf("i = %d, j = %d\n", i, j);
    
    if (j == key.size()) {
        // printIndent(--count);
        // printf("return 0\n");
        return 0;
    }
    
    int res = INT_MAX;
    for (int k : charToIndex[key[j]]) {
        res = min(res, dp(ring, j, key, i + 1));
    }
    
    // printIndent(--count);
    // printf("return %d\n", res);
    return res;
}

```

- 结果

可以得到递归树

![image-20220427124120890](appendix\2总结——10动态规划\image-20220427124120890.png)