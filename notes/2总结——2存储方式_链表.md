# 存储方式: 链表

数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）

# 技巧

## 双指针

技巧：

链表中有一个很重要的技巧是：**假链头dummy**，依次简化代码和一些情况。

解释：

由于在进行链表操作时，尤其是删除节点时，经常会因为对当前节点进行操作而导致内存或指针出现问题。有两个小技巧可以解决这个问题：一是尽量处理当前节点的下一个节点而非当前节点本身，二是建立一个虚拟节点 (dummy node)，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个 dummy 存在，返回 dummy->next 即可。

#### 1. 普通双指针

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

题目：输入两个有序链表，请你把他俩合并成一个新的有序链表。

思路：p1,p2分别指向两个链表，求最小值。（使用dummy简化代码）

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

题目：给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

思路：重点在于如何找到K个链表中的最小值，此处采用最小堆的方式

优先队列 `pq` 中的元素个数最多是 `k`，所以一次 `poll` 或者 `add` 方法的时间复杂度是 `O(logk)`；所有的链表节点都会被加入和弹出 `pq`，**所以算法整体的时间复杂度是 `O(Nlogk)`，其中 `k` 是链表的条数，`N` 是这些链表的节点总数**。



#### 2. 快慢指针

在链表中，主要是使用快慢指针

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

题目：给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

思路：先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步。`p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时前进了 `n - k` 步，`p2` 也从 `head` 开始前进了 `n - k` 步，停留在第 `n - k + 1` 个节点上，即恰好停链表的倒数第 `k` 个节点。

#### [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

题目：给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

思路：我们让两个指针 `slow` 和 `fast` 分别指向链表头结点 `head`。

**每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步，这样，当 `fast` 走到链表末尾时，`slow` 就指向了链表中点**。



#### 判断链表中是否包含环

思路：每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

```java
    public ListNode isCycle(ListNode head) {
        //快慢指针，慢指针走一步，快指针走两步
        ListNode slow = head, fast = head;
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            //快慢指针相遇，说明有环
            if(fast==slow){
				return true;
            }
        }
        return false;
    }
```



#### 链表中有环，返回环的起点

思路：每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。当两个指针相遇时，把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，再次相遇之处就是环的起点。

解释：

假设当第一次快慢指针相遇时，slow走了k步，则fast必走了2k步, 而k必然是环的长度

![](appendix\链表环起点.png)

假设相遇点距离环起点为m, 根据上图的slow，head和环起点相距k-m步；根据fast，相遇点距离环起点也是k-m步，所以把快慢指针中的任一个重新指向head，再一次走k-m步后，再次相遇，此时就是环起点。

![](appendix\链表环起点1.png)

```java
    public ListNode Start(ListNode head) {
        //快慢指针，慢指针走一步，快指针走两步
        ListNode slow = head, fast = head;
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            //快慢指针相遇，说明有环
            if(fast==slow){
				break;
            }
        }
        
        if(fast==null || fast.next==null){
			//说明无环
            return null;
        }
        
        //任一一个指针回到起点
        slow = head;
        while(slow!=fast){
			slow = slow.next;
            fast = fast.next;
        }
        //再次相遇就是起点
        return slow;
    }
```



#### 链表中无环，返回链表的第一个公共节点

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

（[剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)）

**思路一：**

**解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`**。

所以，我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`

```java
//双指针浪漫相遇法
    //两个链表长度分别为L1+C、L2+C， C为公共部分的长度
    // 第一个人走了L1+C步后，回到第二个人起点走L2步；
    // 第2个人走了L2+C步后，回到第一个人起点走L1步。 
    // 当两个人走的步数都为L1+L2+C时就两个人就相爱了
```

**思路二：**

把两条链表首尾相连，即把问题转换为了`链表中有环，返回环的起点`的问题。

