# 二叉树

## 纲领

### 1. 二叉树的套路和重要性

二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「**遍历**」的思维模式。【**[回溯算法核心框架](https://labuladong.gitee.io/algo/4/29/104/)**】

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。【**[动态规划核心框架](https://labuladong.gitee.io/algo/3/23/68/)**】

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

其实，**快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历**。

- 快排框架

  ```java
  void sort(int[] nums, int lo, int hi) {
      /****** 前序遍历位置 ******/
      // 通过交换元素构建分界点 p
      int p = partition(nums, lo, hi);
      /************************/
  
      sort(nums, lo, p - 1);
      sort(nums, p + 1, hi);
  }
  ```

- 归并框架

  ```java
  // 定义：排序 nums[lo..hi]
  void sort(int[] nums, int lo, int hi) {
      int mid = (lo + hi) / 2;
      // 排序 nums[lo..mid]
      sort(nums, lo, mid);
      // 排序 nums[mid+1..hi]
      sort(nums, mid + 1, hi);
  
      /****** 后序位置 ******/
      // 合并 nums[lo..mid] 和 nums[mid+1..hi]
      merge(nums, lo, mid, hi);
      /*********************/
  }
  ```

  

### 2. 深入理解前中后序

#### 2.1 遍历框架

- 数组

  - 迭代

    ```java
    void traverse(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
    
        }
    }
    ```

  - 递归

    ```java
    void traverse(int[] arr, int i){
    	if(i==arr.length){
    		return;
        }
        //前序
        traverse(arr,i+1);
        //后序
    }
    ```

- 链表

  - 迭代

    ```java
    void traverse(ListNode head) {
        for (ListNode p = head; p != null; p = p.next) {
    
        }
    }
    ```

  - 递归

    ```java
    void traverse(ListNode head){
    	if(head==null){
    		return;
        }
        //前序
        traverse(head.next);
        //后序
    }
    ```

- 二叉树（递归）

  ```java
  void traverse(TreeNode root) {
      if (root == null) {
          return;
      }
      // 前序位置
      traverse(root.left);
      // 中序位置
      traverse(root.right);
      // 后序位置
  }
  ```

  **二叉树这种结构无非就是二叉链表**，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。

#### 2.2 理解前中后序

- 链表

  **所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候**，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

  ![](appendix\1.png)

  **对应题：倒数 打印链表**

- 二叉树

  **前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

  前序位置的代码在刚刚进入一个二叉树节点的时候执行；

  后序位置的代码在将要离开一个二叉树节点的时候执行；

  中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

  <img src="appendix\2.png" style="zoom:50%;" />

  二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考**每一个节点应该做什么**，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

  ```tex
  为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。
  ```
  
  **对应题：二叉树的最大深度**
  
  - 解法一：
  
    ```java
    //1，遍历二叉树 + 变量=》回溯
    //先序遍历
    //base case: 到达叶子节点时，返回当前的值
    //递推：在进入左右子树前 depth++,出来后,depth--
    //返回值：NULL，有全局变量res
        int depth;
        int res;
        public int maxDepth(TreeNode root) {
            depth = 0;
            res = 0;
            
            if(root==null) return 0;
            
            recur(root);
            return res;
        }
    
        public void recur(TreeNode root){
            //base case 叶子节点
            if(root==null){
                res = Math.max(res,depth);
                return;
            }
    
            //当前节点
            depth++;
            recur(root.left);
            recur(root.right);
            depth--;
        }
    ```
  
  - 解法二：
  
    ```java
        //2，分解成更小的问题 + 返回值 等于左右子树高度的最大值
        //后序遍历
    //base case:到达叶子节点，返回当前层0
    //递推：Math.max(left,right)+1
    //返回值：当前节点的层数（右下自上增）
        public int maxDepth(TreeNode root) {
            if(root==null) return 0;
            recur(root);
    
            return recur(root);
        }
    
        
        public int recur(TreeNode root){
            //base case
            if(root==null){
                return 0;
            }
    
            int left = recur(root.left);
            int right = recur(root.right);
    
            //递推
            return Math.max(left,right)+1;
    
        }
    ```

- 二叉树的前序遍历（中后序相同）

  - 利用全局变量保存遍历结果

    ```java
    List<Integer> res = new LinkedList<>();
    
    // 返回前序遍历结果
    List<Integer> preorderTraverse(TreeNode root) {
        traverse(root);
        return res;
    }
    
    // 二叉树遍历函数
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // 前序位置
        res.add(root.val);
        traverse(root.left);
        traverse(root.right);
    }
    ```

  - 不利用全局变量保存遍历结果

    分解问题：**一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果**

    ```java
    // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果
    List<Integer> preorderTraverse(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) {
            return res;
        }
        // 前序遍历的结果，root.val 在第一个
        res.add(root.val);
        // 利用函数定义，后面接着左子树的前序遍历结果
        res.addAll(preorderTraverse(root.left));
        // 利用函数定义，最后接着右子树的前序遍历结果
        res.addAll(preorderTraverse(root.right));
    
        return res;
    }
    ```

#### 2.3 前中后序位置的特殊之处

前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上。**但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

##### 2.3.1 先序和后序

- 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

  ```java
  // 二叉树遍历函数
  void traverse(TreeNode root, int level) {
      if (root == null) {
          return;
      }
      // 前序位置
      printf("节点 %s 在第 %d 层", root, level);
      traverse(root.left, level + 1);
      traverse(root.right, level + 1);
  }
  
  // 这样调用
  traverse(root, 1);
  ```

- 如何打印出每个节点的左右子树各有多少节点？

  ```java
  // 定义：输入一棵二叉树，返回这棵二叉树的节点总数
  int count(TreeNode root) {
      if (root == null) {
          return 0;
      }
      int leftCount = count(root.left);
      int rightCount = count(root.right);
      // 后序位置
      printf("节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点",
              root, leftCount, rightCount);
  
      return leftCount + rightCount + 1;
  }
  ```

  这两个问题的根本区别在于：一个节点在第几层，你从**根节点遍历过来的过程就能顺带记录**；而以一个节点为根的整棵子树有多少个节点，你需要**遍历完子树**之后才能数清楚。

  总结：

  **一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**

- 例题

  #### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

  给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

  ```java
      //每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和
      //base case: 当二叉树达到叶子结点，返回0
      //递推关系：
      // int result = maxleft + maxright;
      // max = Math.max(result,max);
      //返回值：以当前节点为头的二叉树的最大高度
  
  	int max;  //左右子树的最大深度之和
      public int diameterOfBinaryTree(TreeNode root) {
          max = 0;
          if(root==null) return 0;
          recur(root);
          return max;
      }
  
      //后序
      public int recur(TreeNode root){
          //base case
          if(root==null){
              return 0;
          }
  
          int maxleft = recur(root.left);
          int maxright = recur(root.right);
  
          //后序
          int result = maxleft + maxright;
          //更新最大值
          max = Math.max(result,max);
  
          //返回的是二叉树的高度
          return Math.max(maxleft,maxright) + 1;
      }
  ```

  

##### 2.3.2 中序

中序的特殊一般在BST



#### 2.4 层序遍历

- 模板

  ```java
  ```

  
