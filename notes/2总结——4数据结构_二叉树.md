# 二叉树

## 纲领

### 1. 二叉树的套路和重要性

二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「**遍历**」的思维模式。【**[回溯算法核心框架](https://labuladong.gitee.io/algo/4/29/104/)**】

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。【**[动态规划核心框架](https://labuladong.gitee.io/algo/3/23/68/)**】

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

其实，**快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历**。

- 快排框架

  ```java
  void sort(int[] nums, int lo, int hi) {
      /****** 前序遍历位置 ******/
      // 通过交换元素构建分界点 p
      int p = partition(nums, lo, hi);
      /************************/
  
      sort(nums, lo, p - 1);
      sort(nums, p + 1, hi);
  }
  ```

- 归并框架

  ```java
  // 定义：排序 nums[lo..hi]
  void sort(int[] nums, int lo, int hi) {
      int mid = (lo + hi) / 2;
      // 排序 nums[lo..mid]
      sort(nums, lo, mid);
      // 排序 nums[mid+1..hi]
      sort(nums, mid + 1, hi);
  
      /****** 后序位置 ******/
      // 合并 nums[lo..mid] 和 nums[mid+1..hi]
      merge(nums, lo, mid, hi);
      /*********************/
  }
  ```

  

### 2. 深入理解前中后序

#### 2.1 遍历框架

- 数组

  - 迭代

    ```java
    void traverse(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
    
        }
    }
    ```

  - 递归

    ```java
    void traverse(int[] arr, int i){
    	if(i==arr.length){
    		return;
        }
        //前序
        traverse(arr,i+1);
        //后序
    }
    ```

- 链表

  - 迭代

    ```java
    void traverse(ListNode head) {
        for (ListNode p = head; p != null; p = p.next) {
    
        }
    }
    ```

  - 递归

    ```java
    void traverse(ListNode head){
    	if(head==null){
    		return;
        }
        //前序
        traverse(head.next);
        //后序
    }
    ```

- 二叉树（递归）

  ```java
  void traverse(TreeNode root) {
      if (root == null) {
          return;
      }
      // 前序位置
      traverse(root.left);
      // 中序位置
      traverse(root.right);
      // 后序位置
  }
  ```

  **二叉树这种结构无非就是二叉链表**，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。

#### 2.2 理解前中后序

- 链表

  **所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候**，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

  ![](appendix\1.png)

  **对应题：倒数 打印链表**

- 二叉树

  **前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

  前序位置的代码在刚刚进入一个二叉树节点的时候执行；

  后序位置的代码在将要离开一个二叉树节点的时候执行；

  中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

  <img src="appendix\2.png" style="zoom:50%;" />

  二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考**每一个节点应该做什么**，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

  ```tex
  为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。
  ```
  
  **对应题：二叉树的最大深度**
  
  - 解法一：
  
    ```java
    //1，遍历二叉树 + 变量=》回溯
    //先序遍历
    //base case: 到达叶子节点时，返回当前的值
    //递推：在进入左右子树前 depth++,出来后,depth--
    //返回值：NULL，有全局变量res
        int depth;
        int res;
        public int maxDepth(TreeNode root) {
            depth = 0;
            res = 0;
            
            if(root==null) return 0;
            
            recur(root);
            return res;
        }
    
        public void recur(TreeNode root){
            //base case 叶子节点
            if(root==null){
                res = Math.max(res,depth);
                return;
            }
    
            //当前节点
            depth++;
            recur(root.left);
            recur(root.right);
            depth--;
        }
    ```
  
  - 解法二：
  
    ```java
        //2，分解成更小的问题 + 返回值 等于左右子树高度的最大值
        //后序遍历
    //base case:到达叶子节点，返回当前层0
    //递推：Math.max(left,right)+1
    //返回值：当前节点的层数（右下自上增）
        public int maxDepth(TreeNode root) {
            if(root==null) return 0;
            recur(root);
    
            return recur(root);
        }
    
        
        public int recur(TreeNode root){
            //base case
            if(root==null){
                return 0;
            }
    
            int left = recur(root.left);
            int right = recur(root.right);
    
            //递推
            return Math.max(left,right)+1;
    
        }
    ```

- 二叉树的前序遍历（中后序相同）

  - 利用全局变量保存遍历结果

    ```java
    List<Integer> res = new LinkedList<>();
    
    // 返回前序遍历结果
    List<Integer> preorderTraverse(TreeNode root) {
        traverse(root);
        return res;
    }
    
    // 二叉树遍历函数
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // 前序位置
        res.add(root.val);
        traverse(root.left);
        traverse(root.right);
    }
    ```

  - 不利用全局变量保存遍历结果

    分解问题：**一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果**

    ```java
    // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果
    List<Integer> preorderTraverse(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) {
            return res;
        }
        // 前序遍历的结果，root.val 在第一个
        res.add(root.val);
        // 利用函数定义，后面接着左子树的前序遍历结果
        res.addAll(preorderTraverse(root.left));
        // 利用函数定义，最后接着右子树的前序遍历结果
        res.addAll(preorderTraverse(root.right));
    
        return res;
    }
    ```

#### 2.3 前中后序位置的特殊之处

前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上。**但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

##### 2.3.1 先序和后序

- 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

  ```java
  // 二叉树遍历函数
  void traverse(TreeNode root, int level) {
      if (root == null) {
          return;
      }
      // 前序位置
      printf("节点 %s 在第 %d 层", root, level);
      traverse(root.left, level + 1);
      traverse(root.right, level + 1);
  }
  
  // 这样调用
  traverse(root, 1);
  ```

- 如何打印出每个节点的左右子树各有多少节点？

  ```java
  // 定义：输入一棵二叉树，返回这棵二叉树的节点总数
  int count(TreeNode root) {
      if (root == null) {
          return 0;
      }
      int leftCount = count(root.left);
      int rightCount = count(root.right);
      // 后序位置
      printf("节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点",
              root, leftCount, rightCount);
  
      return leftCount + rightCount + 1;
  }
  ```

  这两个问题的根本区别在于：一个节点在第几层，你从**根节点遍历过来的过程就能顺带记录**；而以一个节点为根的整棵子树有多少个节点，你需要**遍历完子树**之后才能数清楚。

  总结：

  **一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**

- 例题

  #### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

  给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

  ```java
      //每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和
      //base case: 当二叉树达到叶子结点，返回0
      //递推关系：
      // int result = maxleft + maxright;
      // max = Math.max(result,max);
      //返回值：以当前节点为头的二叉树的最大高度
  
  	int max;  //左右子树的最大深度之和
      public int diameterOfBinaryTree(TreeNode root) {
          max = 0;
          if(root==null) return 0;
          recur(root);
          return max;
      }
  
      //后序
      public int recur(TreeNode root){
          //base case
          if(root==null){
              return 0;
          }
  
          int maxleft = recur(root.left);
          int maxright = recur(root.right);
  
          //后序
          int result = maxleft + maxright;
          //更新最大值
          max = Math.max(result,max);
  
          //返回的是二叉树的高度
          return Math.max(maxleft,maxright) + 1;
      }
  ```

  

##### 2.3.2 中序

中序的特殊一般在BST



#### 2.4 层序遍历

- 模板

  ```java
  // 输入一棵二叉树的根节点，层序遍历这棵二叉树
  void levelTraverse(TreeNode root) {
      if (root == null) return;
      Queue<TreeNode> q = new LinkedList<>();
      q.offer(root);
  
      // 从上到下遍历二叉树的每一层
      while (!q.isEmpty()) {
          int sz = q.size();
          // 从左到右遍历每一层的每个节点
          for (int i = 0; i < sz; i++) {
              TreeNode cur = q.poll();
              // 将下一层节点放入队列
              if (cur.left != null) {
                  q.offer(cur.left);
              }
              if (cur.right != null) {
                  q.offer(cur.right);
              }
          }
      }
  }
  ```
  
  while 循环和 for 循环分管从上到下和从左到右的遍历,如图所示
  
  ![](appendix\3.png)

当然这个框架还可以灵活修改，题目不需要记录层数（步数）时可以去掉上述框架中的 for 循环，比如前文  [Dijkstra 算法](https://labuladong.gitee.io/algo/2/20/55/) 中计算加权图的最短路径问题，详细探讨了 BFS 算法的扩展。

值得一提的是，有些很明显需要用层序遍历技巧的二叉树的题目，也可以用递归遍历的方式去解决，而且技巧性会更强，非常考察你对前中后序的把控。



#### 层序遍历建树

```java
class Solution {
    //结构
    public static class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        public TreeNode(int x) {
            this.val = x;
        }
    }

//    public TreeNode createTree(int[] data,int size){
//        if(size==0) return null;
//        //队列
//        LinkedList<TreeNode> q = new LinkedList<>();
//        //入第一个节点
//        TreeNode head = new TreeNode(data[0]);
//        q.offer(head);
//
//        int idx = 1;
//        while(!q.isEmpty() && idx < size){
////            System.out.print(idx + " ");
//            TreeNode cur = q.poll();
//            //这个是你考虑的特殊情况,当前节点为-1,左右孩子也是-1，则建树的节点赋值为null，但队列中的值为TreeNode(-1)
//            if(cur.val==-1){
//                cur.left = null;
//                q.offer(new TreeNode(-1));
//                cur.right = null;
//                q.offer(new TreeNode(-1));
//                idx = idx + 2;
//            }else{
//                //左孩子
//                    //不为空
//                if(data[idx]!=-1){
//                    cur.left = new TreeNode(data[idx]);
//                    q.offer(cur.left);
//                    //为空：建树的节点赋值为null，但队列中的值为TreeNode(-1)
//                }else{
//                    cur.left = null;
//                    q.offer(new TreeNode(-1));
//                }
//                idx++;
//
//                //右孩子
//                    //不为空
//                if(data[idx]!=-1){
//                    cur.right = new TreeNode(data[idx]);
//                    q.offer(cur.right);
//                    //为空：建树的节点赋值为null，但队列中的值为TreeNode(-1)
//                }else{
//                    cur.right = null;
//                    q.offer(new TreeNode(-1));
//                }
//                idx++;
//            }
//        }
////        System.out.println();
//        return head;
//    }

    public TreeNode createTree(int[] data,int size){
        if(size==0) return null;
        //队列
        LinkedList<TreeNode> q = new LinkedList<>();
        //入第一个节点
        TreeNode head = new TreeNode(data[0]);
        q.offer(head);

        int idx = 1;
        while(!q.isEmpty() && idx < size){
//            System.out.print(idx + " ");
            TreeNode cur = q.poll();
            //这个是你考虑的特殊情况,当前节点为-1,左右孩子也是-1，则建树的节点赋值为null，但队列中的值为TreeNode(-1)
            if(cur==null){
                idx = idx + 2;
                q.offer(null);
                q.offer(null);
            }else{
                //左孩子
                if(data[idx]!=-1){
                    cur.left = new TreeNode(data[idx]);
                }
                idx++;

                //右孩子
                if(data[idx]!=-1){
                    cur.right = new TreeNode(data[idx]);
                }
                idx++;
                q.offer(cur.left);
                q.offer(cur.right);
            }
        }
//        System.out.println();
        return head;
    }

    public void preOrder(TreeNode head){
        if(head==null) return;

        System.out.print(head.val + " ");
        preOrder(head.left);
        preOrder(head.right);
    }

    public void inOrder(TreeNode head){
        if(head==null) return;

        inOrder(head.left);
        System.out.print(head.val + " ");
        inOrder(head.right);
    }

    public void postOrder(TreeNode head){
        if(head==null) return;

        postOrder(head.left);
        postOrder(head.right);
        System.out.print(head.val + " ");
    }

    public static void main(String[] args) {
        Solution tree = new Solution();
        int[] data = {9, 8, 7, 6, -1, 5, -1, 4, -1, -1, -1, -1, 3, -1};

        //建树
        TreeNode head = tree.createTree(data, data.length);

        //前序
        tree.preOrder(head);
        System.out.println();

        //中序
        tree.inOrder(head);
        System.out.println();

        //后序
        tree.postOrder(head);
        System.out.println();

    }

}
```





## 思维

### 1. 思维模板

- 思维一：是否可以通过遍历一遍二叉树得到答案？【遍历】【回溯】

  `traverse` 函数 + 外部变量

- 思维二：是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？【分解问题】【动态规划】【后序】

  `traverse` 函数 + 返回值

无论使用哪种思维模式，都需要思考：**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。



### 2. 题

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

- 思维一：

  - 可以。通过遍历，翻转每个节点的左右节点。
  - 单独抽出一个节点，需要让该节点的左右节点进行交换。
  - 什么时候做，前中后都可。

  ```java
  //方法一：遍历
  //可以。通过遍历，翻转每个节点的左右节点。
  //单独抽出一个节点，需要让该节点的左右节点进行交换。
  //什么时候做，前中后都可。
  
  //base case: 叶子节点返回null
  //递推：左右节点交换
  //返回值：以当前节点为树的交换后的头
      public TreeNode invertTree(TreeNode root) {
          //base case
          if(root==null) return root;
  
          TreeNode tmp = root.left;
          root.left = root.right;
          root.right = tmp;
  
          invertTree(root.left);
          invertTree(root.right);
  
          return root;
      }
  ```

- 思维二：

  - 可以。分解为交换左右两棵子树的子问题。
  - 单独抽出一个节点，需要让该节点的左右**子树**进行交换。
  - 什么时候做，后序。

  ```java
  //方法二：分解
  // - 可以。分解为交换左右两棵子树的子问题。
  // - 单独抽出一个节点，需要让该节点的左右**子树**进行交换。
  // - 什么时候做，后序。
  
  //base case: 叶子节点返回null
  //递推：左右子树交换
  //返回值：以当前节点为树的交换后的头
      public TreeNode invertTree(TreeNode root) {
          //base case
          if(root==null) return root;
  
          TreeNode l = invertTree(root.left);
          TreeNode r = invertTree(root.right);
  
          root.left = r;
          root.right = l;
  
          return root;
      }
  }
  ```

#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

题目：

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

解法：

- 思维一：

  - 可以，让中间虚拟出一个节点，遍历三叉树

  - 抽出一个节点。让它左右节点做如下递推

  - 遍历：好像都可以，先序吧

  ```java
      // 递归遍历：
      // 可以，让中间虚拟出一个节点，遍历三叉树
      // 抽出一个节点。让它左右节点做如下递推
      // 遍历：好像都可以，先序吧
  
      //base case: 如果到叶子节点 return 
      //递推：
      //node1,node2
      //node1.left.next = node1.right
      //node2.left.next = node2.right
      //node1.right.next = node2.left
      //返回值：无
  
      public Node connect(Node root) {
          if(root==null){
              return null;
          }
          recur(root.left,root.right);
          return root;
      }
  
      public void recur(Node p1, Node p2){
          //base case
          if(p1==null || p2==null){
              return;
          }
  
          // 将传入的两个节点穿起来
          p1.next = p2;
  
          // 连接相同父节点的两个子节点
          recur(p1.left, p1.right);
          recur(p2.left,p2.right);
          // 连接跨越父节点的两个子节点
          recur(p1.right,p2.left);
      }
  ```

  

- 思维二：不可行

- 层序遍历

  ```java
      //层序遍历
      
      public Node connect(Node root) {
          if(root==null) return root;
  
          //队列
          LinkedList<Node> q = new LinkedList<>();
          q.addLast(root);
  
          //开始层序遍历
          while(!q.isEmpty()){
              int len = q.size();
              //一层从左到右依次遍历
              for(int i=0;i < len;i++){
  
                  Node cur = q.removeFirst();
                  
                  // if(!q.isEmpty()){
                  //这个条件不对，是到最后一个节点才没有
                  if(i < len-1){
                      cur.next = q.getFirst();
                  }
  
                  if(cur.left!=null){
                      q.addLast(cur.left);
                  }
  
                  if(cur.right!=null){
                      q.addLast(cur.right);
                  }
              }
              //一层结束了
          }
          return root;
      }
  ```

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

**题目**：给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**解法：**

- 思维一：

  返回值为null，这是希望将其原地转换

   如果有返回值，则可以利用空间构造单链表,直接存储前序遍历的结果

  ```java
      //返回值为null，这是希望将其原地转换
      //如果有返回值，则可以利用空间构造单链表,直接存储前序遍历的结果
      TreeNode dummy = new TreeNode(-1);
      dummy.right = root;
      TreeNode p = dummy;
      public TreeNode flatten(TreeNode root) {
          //base case
          if(root==null) return;
  
          //递推
          p.right = root;
          p = p.right;
  
          flatten(root.left);
          flatten(root.right);
  
          return dummy.right;
      }
  ```

  

- 思维二：（一定要把图画出来，就会很清晰了）

    没有返回值，不能通过遍历的方式解决

  - 分解子问题：对于一个节点，返回以该节点为头的二叉树被拉平的链表的头

  - 抽出一个单个节点：把他的左右子树进行拉平，也就是拼接

  - 位置：后序

    ![](appendix\4.png)

  ```java
      //没有返回值，不能通过遍历的方式解决
      //分解子问题：对于一个节点，返回以该节点为头的二叉树被拉平的链表的头
      //抽出一个单个节点：把他的左右子树进行拉平，也就是拼接
      //位置：后序
  
  	//base case:叶子节点,return
  	//递推：把他的左右子树进行拉平，也就是拼接
  	//返回值：无，原地
      public void flatten(TreeNode root) {
          if(root==null) return;
          recur(root);
      }
  
      //对于一个节点，返回以该节点为头的二叉树被拉平的链表的头
      public TreeNode recur(TreeNode root){
          //base case
          if(root==null) return null;
  
          //递推
          TreeNode l = recur(root.left);
          TreeNode r = recur(root.right);
  
          //抽出的一个节点要做的事情
          root.left = null;
          root.right = l;
  
          TreeNode p = root; //保留当前的root
          while(p.right!=null){
              p = p.right;
          }
  
          p.right = r;
  
          return root;
      }
  ```

## 构造

**二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

#### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

    创建一个根节点，其值为 nums 中的最大值。
    递归地在最大值 左边 的 子数组前缀上 构建左子树。
    递归地在最大值 右边 的 子数组后缀上 构建右子树。

返回 nums 构建的 最大二叉树 。

思路：

```java
    //分解：先构造根，构造左子，构造右子，返回头
    //单独抽取一个节点。lm = 找到左边的最大值，root.left = lm,rm = 找到右边的最大值,root.right = rm
    //位置：先序

    //base case : 叶子结点
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return recur(nums,0,nums.length-1);
    }

    //在区间[low,high]里进行处理
    public TreeNode recur(int[] nums,int low,int high){
        if(low > high){
            return null;
        }

        //找到最大值,记录最大值的索引
        int maxindex = low;
        for(int i = low;i <= high;i++){
            if(nums[maxindex] < nums[i]){
                maxindex = i;
            }
        }

        // System.out.println(nums[maxindex] + "\t" + maxindex + "\t[" + low + "," + high + "]");

        //构造二叉树
        TreeNode root = new TreeNode(nums[maxindex]);

        root.left = recur(nums,low,maxindex-1);
        root.right = recur(nums,maxindex + 1,high);

        return root;
    }
```

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

![](appendix\5.png)

```java
    //1,分解： 根，左子树，右子树
    //2,抽出一个节点。找到根，root.left = 左子树的根，root.right = 右子树的根
    //root = preorder[preStart]
    //root.left = recur(preorder,preStart+1,preStart+leftsize,inorder,inStart,inindex-1);
    // root.right = recur(preorder,preStart+leftsize+1,preEnd,inorder,inindex+1,inEnd);
    //3,位置：先序

    //base case:区间里没有元素了，返回null
    //递推：
    //root = preorder[preStart]
    //root.left = recur(preorder,preStart+1,preStart+leftsize,inorder,inStart,inindex-1);
    // root.right = recur(preorder,preStart+leftsize+1,preEnd,inorder,inindex+1,inEnd);
    //返回值：当前区间构建的树的根


    //利用hashmap存取下标和元素的对应关系，优化在inorder中找跟的index,因为没有重复的元素了
    HashMap<Integer,Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i = 0;i < inorder.length;i++){
            map.put(inorder[i],i);
        }

        return recur(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }

    public TreeNode recur(int[] preorder, int preStart, int preEnd,int[] inorder,int inStart,int inEnd){
        //base case
        if(preStart > preEnd){
            return null;
        }
        //
        int rootval = preorder[preStart];
        int inindex = map.get(rootval);

        TreeNode root = new TreeNode(rootval);
        int leftsize = inindex - inStart;
        root.left = recur(preorder,preStart+1,preStart+leftsize,inorder,inStart,inindex-1);
        root.right = recur(preorder,preStart+leftsize+1,preEnd,inorder,inindex+1,inEnd);

        return root;
    }
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

![](appendix\6.png)

```java
    HashMap<Integer,Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] inorder, int[] postorder ) {
        for(int i = 0;i < inorder.length;i++){
            map.put(inorder[i],i);
        }

        return recur(inorder,0,inorder.length-1,postorder,0,postorder.length-1);
    }

    public TreeNode recur(int[] inorder, int inStart, int inEnd,int[] postorder,int posStart,int posEnd){
        //base case
        if(inStart > inEnd){
            return null;
        }
        //
        int rootval = postorder[posEnd];
        // System.out.println(rootval+"\t"+inStart+"\t"+inEnd);
        // System.out.println(rootval+"\t"+posStart+"\t"+posEnd);
        // System.out.println(rootval);
        int inindex = map.get(rootval);

        TreeNode root = new TreeNode(rootval);
        int leftsize = inindex - inStart;
        root.left = recur(inorder,inStart,inindex-1,postorder,posStart,posStart+leftsize-1);
        root.right = recur(inorder,inindex+1,inEnd,postorder,posStart+leftsize,posEnd-1);

        return root;
    }
```

#### [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

题目：

给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 任何 一个。

思路：

由于前序和后序不能确定唯一的二叉树，可以假定root.left = preorder[left+1]

![](appendix\7.png)

方法与之前类似, 就是要注意base case

```java
    //假设左子树的根是先序遍历的之前的根的下一个值
    HashMap<Integer,Integer> map = new HashMap<>();
    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        for(int i = 0;i < postorder.length;i++){
            map.put(postorder[i],i);
        }

        return recur(preorder,0,preorder.length-1,postorder,0,postorder.length-1);
    }

    public TreeNode recur(int[] preorder, int preStart, int preEnd,int[] postorder,int postStart,int postEnd){
        //base case
        if(preStart > preEnd){
            return null;
        }

        //当没有左孩子
        if(preStart + 1 > preEnd){
            return new TreeNode(preorder[preStart]);
        }
        //递推
        int rootval = preorder[preStart];
        int leftval = preorder[preStart + 1];
        int postindex = map.get(leftval);

        TreeNode root = new TreeNode(rootval);

        int leftSize = postindex - postStart + 1;
        root.left = recur(preorder,preStart+1,preStart+leftSize,postorder,postStart,postindex);
        root.right = recur(preorder,preStart+leftSize+1,preEnd,postorder,postindex+1,postEnd-1);

        return root;
    }
```

#### [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

题目：给定一棵二叉树 `root`，返回所有**重复的子树**。

思路：

将子树的**前序序列化**保留，以此来判断是否有重复，注意空值要填null

```java
    //分解：求子树
    //对于单个节点：把当前子树的先序遍历(序列化)放到hashmap中，已经当前所有子树存入hashmap，对比是否与当前序列有重复的，放入结果中
    //位置：后序

    //放序列，对应的次数
    HashMap<String,Integer> map; 
    List<TreeNode> ans;
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        map = new HashMap<>(); 
        ans = new ArrayList<>();
        recur(root);
        return ans;
    }

    //base case: root==null， 叶子节点，序列化“#”
    //递推：先加入hashmap,再判断是否重复
    //返回值：返回以当前节点为根的二叉树的前序序列化
    public String recur(TreeNode root){
        //base case
        if(root==null){
            return "#";
        }

        //先添加
        String serial = root.val + "," + recur(root.left) + "," + recur(root.right);
        map.put(serial,map.getOrDefault(serial,0)+1);

        //判断与当前序列（子树）是否有重复的
        if(map.get(serial)==2) ans.add(root);
        return serial;
    }
```



## 序列化

#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

- 序列化：简单的先序遍历

  ```java
      // 利用简单的先序遍历
      public String serialize(TreeNode root) {
          //序列化 变成字符串
          //base case
          StringBuilder res = new StringBuilder();
  
          if(root==null) return "#,";
  
          res.append(root.val + ",");
          res.append(serialize(root.left));
          res.append(serialize(root.right));
  
          return res.toString();
      }
  ```

  

- 反序列化：要注意将元素存入全局队列中再利用根左右的顺序构建二叉树

  ```java
      //精髓在于放入队列中
      Queue<String> q;
      // Decodes your encoded data to tree.
      public TreeNode deserialize(String data) {
          String[] numbers = data.split(",");
          q = new LinkedList<String>();
          
          //添加到队列
          for(int i=0;i<numbers.length;i++){
              q.offer(numbers[i]);
          }
  
          return recur();
      }
  
  
      //先序构建树
      //根+左+右
      public TreeNode recur(){
          String value = q.poll();
  
          if(value.equals("#")){
              return null;
          }
  
          TreeNode node = new TreeNode(Integer.valueOf(value));
          node.left  = recur();
          node.right = recur();
  
          return node;
      }
  ```



## 归并排序与二叉树后序遍历

#### 归并排序（[912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)）

- 思路

  **所有递归的算法，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码。你要写递归算法，本质上就是要告诉每个节点需要做什么**。

  归并排序的过程可以在逻辑上抽象成一棵二叉树，树上的每个节点的值可以认为是 `nums[lo..hi]`，叶子节点的值就是数组中的单个元素，正如后序遍历的处理顺序：

  ![](appendix\2总结——4数据结构_二叉树\8.png)

  ```java
    public void mergeSort(int[] numbers){
        if(numbers==null || numbers.length < 2 ) return;
  
        mergeSort(numbers,0,numbers.length-1);
  
        System.out.println(Arrays.toString(numbers));
  
    }
  
    //先排左边，再排右边，再合并
    public void mergeSort(int[] numbers,int low,int high){
        //base case
        if(low==high) return;
  
        System.out.println(low+"  ----   "+high);
  
        int mid = low + (high-low)/2;
        //[low,mid]
        mergeSort(numbers,low,mid);
        //[mid+1,high]
        mergeSort(numbers,mid+1,high);
        merge(numbers,low,mid,high);
    }
    // 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组
    public void merge(int[] numbers,int low, int mid,int high){
        int[] help = new int[high-low+1];
        int p1 = low;
        int p2 = mid + 1;
        int idx = 0;
        while(p1<=mid && p2<=high){
            if(numbers[p1] < numbers[p2]){
                help[idx] = numbers[p1++];
            }
            else if(numbers[p1] >= numbers[p2]){
                help[idx] = numbers[p2++];
            }
            idx++;
        }
  
        while(p1<=mid){
            help[idx++] = numbers[p1++];
        }
  
        while(p2<=high){
            help[idx++] = numbers[p2++];
        }
  
        //复制回去
        for(int i = low;i <= high;i++){
            numbers[i] = help[i-low];
        }
    }
  
    public static void main(String[] args) {
        MergeSort1 test = new MergeSort1();
        int[] data  = {73,74,75,71,69,72,76,73};
        test.mergeSort(data);
    }
  ```

  ```java
  class Merge {
  
      // 用于辅助合并有序数组
      private static int[] temp;
  
      public static void sort(int[] nums) {
          // 先给辅助数组开辟内存空间
          temp = new int[nums.length];
          // 排序整个数组（原地修改）
          sort(nums, 0, nums.length - 1);
      }
  
      // 定义：将子数组 nums[lo..hi] 进行排序
      private static void sort(int[] nums, int lo, int hi) {
          if (lo == hi) {
              // 单个元素不用排序
              return;
          }
          // 这样写是为了防止溢出，效果等同于 (hi + lo) / 2
          int mid = lo + (hi - lo) / 2;
          // 先对左半部分数组 nums[lo..mid] 排序
          sort(nums, lo, mid);
          // 再对右半部分数组 nums[mid+1..hi] 排序
          sort(nums, mid + 1, hi);
          // 将两部分有序数组合并成一个有序数组
          merge(nums, lo, mid, hi);
      }
  
      // 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组
      private static void merge(int[] nums, int lo, int mid, int hi) {
          // 先把 nums[lo..hi] 复制到辅助数组中
          // 以便合并后的结果能够直接存入 nums
          for (int i = lo; i <= hi; i++) {
              temp[i] = nums[i];
          }
  
          // 数组双指针技巧，合并两个有序数组
          int i = lo, j = mid + 1;
          for (int p = lo; p <= hi; p++) {
              if (i == mid + 1) {
                  // 左半边数组已全部被合并
                  nums[p] = temp[j++];
              } else if (j == hi + 1) {
                  // 右半边数组已全部被合并
                  nums[p] = temp[i++];
              } else if (temp[i] > temp[j]) {
                  nums[p] = temp[j++];
              } else {
                  nums[p] = temp[i++];
              }
          }
      }
  }
  
  ```

  

- 时间复杂度

  **执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数**。

  所以从整体上看，这个二叉树的高度是 `logN`，其中每一层的元素个数就是原数组的长度 `N`，所以总的时间复杂度就是 `O(NlogN)`。

#### [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

```java
    private class Pair {
        int val, id;
        Pair(int val, int id) {
            // 记录数组的元素值
            this.val = val;
            // 记录元素在数组中的原始索引
            this.id = id;
        }
    }
    
    // 归并排序所用的辅助数组
    private Pair[] temp;
    // 记录每个元素后面比自己小的元素个数
    private int[] count;
    
    // 主函数
    public List<Integer> countSmaller(int[] nums) {
        int n = nums.length;
        count = new int[n];
        temp = new Pair[n];
        Pair[] arr = new Pair[n];
        // 记录元素原始的索引位置，以便在 count 数组中更新结果
        for (int i = 0; i < n; i++)
            arr[i] = new Pair(nums[i], i);
        
        // 执行归并排序，本题结果被记录在 count 数组中
        sort(arr, 0, n - 1);
        
        List<Integer> res = new LinkedList<>();
        for (int c : count) res.add(c);
        return res;
    }
    
    // 归并排序
    private void sort(Pair[] arr, int lo, int hi) {
        if (lo == hi) return;
        int mid = lo + (hi - lo) / 2;
        sort(arr, lo, mid);
        sort(arr, mid + 1, hi);
        merge(arr, lo, mid, hi);
    }
    
    // 合并两个有序数组
    private void merge(Pair[] arr, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; i++) {
            temp[i] = arr[i];
        }
        
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            //左边都合完了，还剩右边
            if (i == mid + 1) {
                arr[p] = temp[j++];
            //右边都合完了，还剩左边
            } else if (j == hi + 1) {
                arr[p] = temp[i++];
                // 更新 count 数组
                count[arr[p].id] += j - mid - 1;
            } else if (temp[i].val > temp[j].val) {
                arr[p] = temp[j++];
            } else {
                arr[p] = temp[i++];
                // 更新 count 数组
                count[arr[p].id] += j - mid - 1;
            }
        }
    }
```

#### [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

```java
    int res;
    public int reversePairs(int[] numbers){
        if(numbers==null || numbers.length < 2 ) return 0;

        res  = 0;
        mergeSort(numbers,0,numbers.length-1);
        return res;
    
    }

    //先排左边，再排右边，再合并
    public void mergeSort(int[] numbers,int low,int high){
        //base case
        if(low==high) return;

        int mid = low + (high-low)/2;
        //[low,mid]
        mergeSort(numbers,low,mid);
        //[mid+1,high]
        mergeSort(numbers,mid+1,high);
        merge(numbers,low,mid,high);
    }

    // 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组
    public void merge(int[] numbers,int low, int mid,int high){
        int[] help = new int[high-low+1];
        int p1 = low;
        int p2 = mid + 1;
        int idx = 0;
        while(p1<=mid && p2<=high){
            if(numbers[p1] <= numbers[p2]){
                help[idx] = numbers[p1++];
            }
            else if(numbers[p1] > numbers[p2]){
                help[idx] = numbers[p2++];
                res += mid-p1+1;
            }
            idx++;
        }

        while(p1<=mid){
            help[idx++] = numbers[p1++];
        }

        while(p2<=high){
            help[idx++] = numbers[p2++];
        }

        //复制回去
        for(int i = low;i <= high;i++){
            numbers[i] = help[i-low];
        }
    }
```



## 二叉搜索树（特性）

**BST 的特性：**

1、对于 BST 的每一个节点 `node`，左子树节点的值都比 `node` 的值要小，右子树节点的值都比 `node` 的值大。

2、对于 BST 的每一个节点 `node`，它的左侧子树和右侧子树都是 BST。

3、从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）。

**直接基于 BST 的数据结构：** 

- AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；

- B+ 树，线段树等结构都是基于 BST 的思想来设计的。

#### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```java
    //遍历
    //抽出一个单独的节点：k，cnt++, 判断cnt是否等于k
    //返回值：当前的节点

    //base case:叶子结点，
    int res;
    int cnt;
    public int kthSmallest(TreeNode root, int k) {
        res = 0;
        cnt = 0;
        recur(root,k);
        return res;
    }

    void recur(TreeNode root, int k){
        if(root==null) return;
        recur(root.left,k);
        cnt++;
        if(k==cnt){
            res =  root.val;
            return;
        }
        recur(root.right,k);
    }
```

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```java
    //逆中序遍历的做法
    //抽出一个单个节点：cnt++;cnt?=k
    //返回值：空
    int res;
    int cnt;
    public int kthLargest(TreeNode root, int k) {
        res =0;
        cnt =0;
        recur(root,k);
        return res;
    }

    public void recur(TreeNode root, int k){
        if(root==null) return;

        recur(root.right,k);
        cnt++;
        if(cnt==k){
            res = root.val;
            return;
        }
        recur(root.left,k);
    }
```

#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)([1038. 从二叉搜索树到更大和树](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/))

题目：给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

![image-20220415090843559](appendix\2总结——4数据结构_二叉树\image-20220415090843559.png)

思路：

我们可以从结果观察到，右中左的顺序是在累加的，初始是最右边的元素

利用二叉搜索树的逆中序遍历是降序

```java
    //利用二叉搜索树的逆中序遍历是降序
    //我们可以从结果观察到，右中左的顺序是在累加的，初始是最右边的元素
    int sum;
    public TreeNode convertBST(TreeNode root) {
        sum = 0;
        recur(root);
        return root;
    }

    public void recur(TreeNode root){
        if(root==null) return;

        recur(root.right);
        sum += root.val;
        root.val = sum;
        recur(root.left);
    }
```

## 二叉搜索树（基操）

常用思路：

```java
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

#### 判断是否是二叉搜索树

- 错误做法

  ```java
  boolean isValidBST(TreeNode root) {
      if (root == null) return true;
      if (root.left != null && root.val <= root.left.val)
          return false;
      if (root.right != null && root.val >= root.right.val)
          return false;
  
      return isValidBST(root.left)
          && isValidBST(root.right);
  }
  
  ```

  出现问题的原因在于，对于每一个节点 `root`，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，`root` 的整个左子树都要小于 `root.val`，整个右子树都要大于 `root.val`。比如下图：

  ![image-20220414135818386](appendix\2总结——4数据结构_二叉树\image-20220414135818386.png)

- 正确(后序遍历)：**限定以 root 为根的子树节点必须满足 max.val > root.val > min.val**

  对于某一个节点 `root`，他只能管得了自己的左右子节点，怎么把 `root` 的约束传递给左右子树呢？**通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧**

  思路：限定以 root 为根的子树节点必须满足 max.val > root.val > min.val

  ```java
  boolean isValidBST(TreeNode root) {
      return isValidBST(root, null, null);
  }
  
  /* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
  //参数：当前根节点，当前根节点的树的最小值，当前根节点树的最大值
  boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
      // base case
      if (root == null) return true;
      // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
      if (min != null && root.val <= min.val) return false;
      if (max != null && root.val >= max.val) return false;
      // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
      return isValidBST(root.left, min, root) 
          && isValidBST(root.right, root, max);
  }
  
  ```

- 另一种思路: **中序是升序，记录上一个节点的值**

  ```java
  //上一个值
  	//注意一定要用long型，不然int的边界会有问题，因为val是int型，处理测试用例：[-2147483648]
  	long pre=Long.MIN_VALUE; 
      public boolean isValidBST(TreeNode root) {
          if(root==null){
              return true;
          }
          
          boolean left = isValidBST(root.left);
  
          if(!left) return false; 
  
          if(pre >= root.val) return false;
          pre = root.val;
  
          return isValidBST(root.right);
      }
  ```
  
  

#### 在 BST 中搜索元素

#### [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 root 和一个整数值 val。

你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

```java
//利用bst,左小右大
//而不是完全的遍历
    public TreeNode searchBST(TreeNode root, int val) {
        //二叉搜索树
        if(root==null){
            return null;
        }

        if(root.val < val){
            return searchBST(root.right,val);
        }

        if(root.val > val){
            return searchBST(root.left,val);
        }

        //root.val==val
        return root;
    }
```

#### 在 BST 中插入一个数

思路：

找位置，插入

**一旦涉及「改」，函数就要返回 `TreeNode` 类型，并且对递归调用的返回值进行接收**

```java
TreeNode insertIntoBST(TreeNode root, int val) {
	if(root==null) return root;
    
    if(root.val < val){
		root.right = insertIntoBST(root.right,val);
    }
    
    if(root.val > val){
		root.left = insertIntoBST(root.left,val);
    }
    
    return root;
}
```

#### 在 BST 中删除一个数

思路：

找位置，**删除**（分为三种情况）

1. A 恰好是末端节点，两个子节点都为空

   ![image-20220415095507050](\appendix\2总结——4数据结构_二叉树\image-20220415095507050.png)

2. A 只有一个非空子节点，那么它要让这个孩子接替自己的位置

   ![image-20220415095525358](\appendix\2总结——4数据结构_二叉树\image-20220415095525358.png)

3. A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。两种方式都可以，目前选第二种

   ![image-20220415095543397](\appendix\2总结——4数据结构_二叉树\image-20220415095543397.png)

```java
TreeNode insertIntoBST(TreeNode root, int val) {
	if(root.val==key) {
        //删除操作分为三种情况
        //1. A 恰好是末端节点，两个子节点都为空
        if(root.left==null && root.right==null){
			return null;
        }
        //2. A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。
        if(root.left==null  || root.right==null){
			return root.right==null? root.left:root.right;
        }
       	
        //3.A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。两种方式都可以，目前选第二种
        if(root.left!=null && root.right!=null){
            // 找到右子树的最小节点minRight
			TreeNode minRight = getMin(root.right);
            // 把 root 改成 minRight
            root.val = minRight.val;
            // 转而去删除 minRight
            root.right = deleteNode(root.right,minRight.val);
        }
       
    }else if(root.val < val){
        root.right = deleteNode(root.right,val);
		
    }else if(root.val > val){
		root.left = deleteNode(root.left,val);
    }
    
    return root;
}

//获取右子树的最小值,在最左下角的位置
TreeNode getMin(TreeNode node){
	while(node.left!=null){
        node = node.left;
    }
    return node;
}
```

#### [1373. 二叉搜索子树的最大键值和](https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/)

给你一棵以 `root` 为根的 **二叉树** ，请你返回 **任意** 二叉搜索子树的最大键值和。

思路：

**当前节点需要做什么？**

1、左右子树是否是 BST。（一个树必然有BST子树，因为一个节点也算）

2、左子树的最大值和右子树的最小值。

3、左右子树的节点值之和。

- 先序的模板（递归套递归了）

```java
int max = 0;
public int maxSumBST(TreeNode root){
	recur(root);
    return max;
}

//遍历二叉树
public void recur(TreeNode root){
	if(root==null) return;
    
    //先序遍历
    
    //1.判断左右子树是否是BST
    if(isBST(root.left) || !isBST(root.right)){
		goto next;
    }
    //2.判断加上自己是不是BST
    if(!isBST(root)){
		goto next;
    }
    
    //3. 满足前面的条件，计算和
    int sum = findSum(root.left) + findSum(root.right) + root.val;
    max = Math.max(max,sum);
    
    
    //递归遍历左右子树
    next:
    recur(root.left);
    recur(root.right);
}

/* 计算以 root 为根的二叉树的节点和 */
int findSum(TreeNode root) {}

/* 判断以 root 为根的二叉树是否是 BST */
boolean isBST(TreeNode root) {}

```

- 后序，返回一些信息，让recur把其他辅助函数做的事情都做了【利用套路】

```java
class Solution {
    private int maxSum = 0;

    public int maxSumBST(TreeNode root) {
        if(root == null) {
            return 0;
        }
        recur(root);
        return maxSum;
    }

    public ReturnType recur(TreeNode root) {
        if(root == null) {
            return new ReturnType(true, Integer.MAX_VALUE, Integer.MIN_VALUE, 0);
        }
        ReturnType left = recur(root.left);
        ReturnType right = recur(root.right);
        //判断是否为BST 左右子树都是BST 并且左子树最大值小于根节点 右子树最小值大于根节点
        int val = root.val;
        if(left.isBST && right.isBST && val > left.maxVal && val < right.minVal) {
            int sum = left.sum + right.sum + root.val;
            maxSum = Math.max(sum, maxSum);
             //如果我们判断以 root 为根的二叉树是 BST，root.val一定大于left[1]吧,为什么要这样写
            //这跟我们对空节点的处理有关，我们处理空节点的时候，把它的最小值设成了正无穷，最大值设成了负无穷，如果不比较大小直接赋值的话，那么它们的父亲节点的最小值也变成正无穷了，最大值也变成负无穷了，只有和是对的
            int minVal = Math.min(left.minVal, val);
            int maxVal = Math.max(right.maxVal, val);
            // int minVal = left.minVal;
            // int maxVal = right.maxVal;
            return new ReturnType(true, minVal, maxVal, sum);
        } else {
            //不是bst 其他值无需计算
            return new ReturnType(false, 0, 0, 0);
        } 
    }

    class ReturnType {
        public boolean isBST;
        public int minVal;
        public int maxVal;
        public int sum;

        public ReturnType(boolean isBST, int minVal, int maxVal, int sum) {
            this.isBST = isBST;
            this.minVal = minVal;
            this.maxVal = maxVal;
            this.sum = sum;
        }  
    }
}
```

#### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

- 利用性质递归遍历(先序遍历)

  ```java
      public boolean verifyPostorder(int[] postorder) {
          return recur(postorder, 0, postorder.length - 1);
      }
      //利用先序遍历，先判断当前子树序列是否合适，再判断左子序列，再判断右子序列
      //后序遍历，postorder[e]为根
      boolean recur(int[] postorder, int i, int j) {
          //base case 叶子节点及空节点返回true,有等于号
          if(i >= j) return true;
          int p = i;
  
          //1.划分左右子树
          //从左到右找到第一个比根大的节点，作为左右子树的分界线
          while(postorder[p] < postorder[j]) p++;
          
          //2. 判断当前节点是否合适
          //r之后都为右子树，看能否走到底
          int m = p;
          while(postorder[p] > postorder[j]) p++;
  
          //3. 返回
          return p == j && recur(postorder, i, m - 1) && recur(postorder, m, j - 1);
      }
  ```

- 利用单调栈（只让根右进栈）

  ```java
      public boolean verifyPostorder(int[] postorder) {
          //辅助栈，维护一个单调递增的栈，也就是只让根和右孩子入栈，当前节点作为别人的右孩子的时候入栈
          Stack<Integer> s = new Stack<>();
  
          //
          int root = Integer.MAX_VALUE;
          for(int i = postorder.length-1;i>=0;i--){
              //判断当前序列是否是递减的，如果不是则为false
              if(postorder[i] > root) return false;
  
              //维护单调递减的栈
              while(!s.isEmpty() && s.peek() > postorder[i]){
                  root = s.pop();
              }
  
              s.add(postorder[i]);
          }
  
          return true;
      }
  ```

#### [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

- 分析不同的情况，先序遍历，根据大小值优化

  ```java
      //先序从上向下进行遍历，最近公共祖先，注意判断所有情况
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          //base case 空节点
          if(root==null || root == p || root==q) return root;
  
          if(p.val < root.val && q.val < root.val){
              return lowestCommonAncestor(root.left,p,q);
          }
  
          if(p.val > root.val && q.val > root.val){
              return lowestCommonAncestor(root.right,p,q);
          }
  
          //是p q在不同树上的时候
          return root;
      }
  ```

  



#### [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

- 先序遍历

```java
    //先序从上向下进行遍历，最近公共祖先，注意判断所有情况
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //base case 空节点 以及 先序判断当前节点的情况
        if(root==null || root == p || root==q) return root;

        //然后去左子树找，再去右子树找
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);

        if(left==null) return right;
        if(right==null) return left;

        return root;
    }
```



## 计算二叉树的节点数

#### 普通二叉树

时间复杂度：nlogn

```java
public int countNodes(TreeNode root){
	if(root == null) return 0;
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

#### 满二叉树（完全满的）

节点总数count 和树的高度h有关系

count = 2^h -1

```java
public int countNodes(TreeNode root){
    int h = 0;
    while(root!=null){
		root = root.left;
        h++;
    }
    return (int)Math.pow(2,h)-1;
}
```

#### 完全二叉树

先判断是否是满二叉树，不是则按普通方法计算

```java
    public int countNodes(TreeNode root){
        TreeNode l = root,r = root;
        int hl = 0,hr = 0;
        while(l!=null){
            l = l.left;
            hl++;
        }
        while(r!=null){
            r = r.right;
            hr++;
        }
        
        // 如果左右子树的高度相同，则是一棵满二叉树
        if(hr==hl){
            return (int)Math.pow(2,hl)-1;
        }
        
        // 如果左右高度不同，则按照普通二叉树的逻辑计算
        return 1 + countNodes(root.left) + countNodes(root.right); 
    }
```

复杂度分析：O(logN*logN)

直觉感觉好像最坏情况下是 O(N*logN) 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归。**但这两个递归只有一个会真的递归下去，另一个一定会触发 `hl == hr` 而立即返回，不会递归下去**。因为**一棵完全二叉树的两棵子树，至少有一棵是满二叉树**。

![image-20220415131950200](appendix\2总结——4数据结构_二叉树\image-20220415131950200.png)



由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 `hl == hr`，只消耗 O(logN) 的复杂度而不会继续递归。

综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN).



## 快速排序与二叉树的先序遍历

#### [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

给你一个整数数组 `nums`，请你将该数组升序排列。

```java
    //快速排序(类似于二叉树的先序遍历)
    //1.选择基准值：在待排序列中，按照某种方式挑出一个元素，作为基准值。
    //2.分割操作：以该基准值在序列中的实际位置，把序列分成两个子序列，一边是比它大的值，另外一边是比它小的值。
    //3.递归：对两个子序列进行快排，直到序列为空或者只有一个元素。

    public int[] sortArray(int[] arr) {
        if(arr==null || arr.length<2) return arr;

        quickSort(arr,0,arr.length-1);

        return arr;
    }

    public void quickSort(int[] arr,int s,int e){
        //base case
        if(s>=e) return;

        //随机交换最后一个
        swap(arr, s + (int) (Math.random() * (e - s + 1)), e);
        int m = partition(arr,s,e);
        quickSort(arr,s,m-1);
        quickSort(arr,m+1,e);
    }

    // arr[L..R]上，以arr[R]位置的数做划分值
    // <= X > X
    // <= X X

    public int partition(int[] arr,int s, int e){
        if(s > e) return -1;
        if(s == e) return s;

        int index = s;
        int lessEqual = s-1;
        while(index < e){
            if(arr[index] < arr[e]){
                swap(arr,++lessEqual,index++);
            }else {
                index++;
            }
        }
        swap(arr,++lessEqual,e);
        return lessEqual;
    }

    public void swap(int[]arr,int i,int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
```





