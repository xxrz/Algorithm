# 二叉树

## 纲领

### 1. 二叉树的套路和重要性

二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「**遍历**」的思维模式。【**[回溯算法核心框架](https://labuladong.gitee.io/algo/4/29/104/)**】

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「**分解问题**」的思维模式。【**[动态规划核心框架](https://labuladong.gitee.io/algo/3/23/68/)**】

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

其实，**快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历**。

- 快排框架

  ```java
  void sort(int[] nums, int lo, int hi) {
      /****** 前序遍历位置 ******/
      // 通过交换元素构建分界点 p
      int p = partition(nums, lo, hi);
      /************************/
  
      sort(nums, lo, p - 1);
      sort(nums, p + 1, hi);
  }
  ```

- 归并框架

  ```java
  // 定义：排序 nums[lo..hi]
  void sort(int[] nums, int lo, int hi) {
      int mid = (lo + hi) / 2;
      // 排序 nums[lo..mid]
      sort(nums, lo, mid);
      // 排序 nums[mid+1..hi]
      sort(nums, mid + 1, hi);
  
      /****** 后序位置 ******/
      // 合并 nums[lo..mid] 和 nums[mid+1..hi]
      merge(nums, lo, mid, hi);
      /*********************/
  }
  ```

  

### 2. 深入理解前中后序

#### 2.1 遍历框架

- 数组

  - 迭代

    ```java
    void traverse(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
    
        }
    }
    ```

  - 递归

    ```java
    void traverse(int[] arr, int i){
    	if(i==arr.length){
    		return;
        }
        //前序
        traverse(arr,i+1);
        //后序
    }
    ```

- 链表

  - 迭代

    ```java
    void traverse(ListNode head) {
        for (ListNode p = head; p != null; p = p.next) {
    
        }
    }
    ```

  - 递归

    ```java
    void traverse(ListNode head){
    	if(head==null){
    		return;
        }
        //前序
        traverse(head.next);
        //后序
    }
    ```

- 二叉树（递归）

  ```java
  void traverse(TreeNode root) {
      if (root == null) {
          return;
      }
      // 前序位置
      traverse(root.left);
      // 中序位置
      traverse(root.right);
      // 后序位置
  }
  ```

  **二叉树这种结构无非就是二叉链表**，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。

#### 2.2 理解前中后序

- 链表

  **所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候**，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

  ![](appendix\1.png)

  **对应题：倒数 打印链表**

- 二叉树

  **前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

  前序位置的代码在刚刚进入一个二叉树节点的时候执行；

  后序位置的代码在将要离开一个二叉树节点的时候执行；

  中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

  <img src="appendix\2.png" style="zoom:50%;" />

  二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考**每一个节点应该做什么**，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

  ```tex
  为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。
  ```
  
  **对应题：二叉树的最大深度**
  
  - 解法一：
  
    ```java
    //1，遍历二叉树 + 变量=》回溯
    //先序遍历
    //base case: 到达叶子节点时，返回当前的值
    //递推：在进入左右子树前 depth++,出来后,depth--
    //返回值：NULL，有全局变量res
        int depth;
        int res;
        public int maxDepth(TreeNode root) {
            depth = 0;
            res = 0;
            
            if(root==null) return 0;
            
            recur(root);
            return res;
        }
    
        public void recur(TreeNode root){
            //base case 叶子节点
            if(root==null){
                res = Math.max(res,depth);
                return;
            }
    
            //当前节点
            depth++;
            recur(root.left);
            recur(root.right);
            depth--;
        }
    ```
  
  - 解法二：
  
    ```java
        //2，分解成更小的问题 + 返回值 等于左右子树高度的最大值
        //后序遍历
    //base case:到达叶子节点，返回当前层0
    //递推：Math.max(left,right)+1
    //返回值：当前节点的层数（右下自上增）
        public int maxDepth(TreeNode root) {
            if(root==null) return 0;
            recur(root);
    
            return recur(root);
        }
    
        
        public int recur(TreeNode root){
            //base case
            if(root==null){
                return 0;
            }
    
            int left = recur(root.left);
            int right = recur(root.right);
    
            //递推
            return Math.max(left,right)+1;
    
        }
    ```

- 二叉树的前序遍历（中后序相同）

  - 利用全局变量保存遍历结果

    ```java
    List<Integer> res = new LinkedList<>();
    
    // 返回前序遍历结果
    List<Integer> preorderTraverse(TreeNode root) {
        traverse(root);
        return res;
    }
    
    // 二叉树遍历函数
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // 前序位置
        res.add(root.val);
        traverse(root.left);
        traverse(root.right);
    }
    ```

  - 不利用全局变量保存遍历结果

    分解问题：**一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果**

    ```java
    // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果
    List<Integer> preorderTraverse(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) {
            return res;
        }
        // 前序遍历的结果，root.val 在第一个
        res.add(root.val);
        // 利用函数定义，后面接着左子树的前序遍历结果
        res.addAll(preorderTraverse(root.left));
        // 利用函数定义，最后接着右子树的前序遍历结果
        res.addAll(preorderTraverse(root.right));
    
        return res;
    }
    ```

#### 2.3 前中后序位置的特殊之处

前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上。**但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

##### 2.3.1 先序和后序

- 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

  ```java
  // 二叉树遍历函数
  void traverse(TreeNode root, int level) {
      if (root == null) {
          return;
      }
      // 前序位置
      printf("节点 %s 在第 %d 层", root, level);
      traverse(root.left, level + 1);
      traverse(root.right, level + 1);
  }
  
  // 这样调用
  traverse(root, 1);
  ```

- 如何打印出每个节点的左右子树各有多少节点？

  ```java
  // 定义：输入一棵二叉树，返回这棵二叉树的节点总数
  int count(TreeNode root) {
      if (root == null) {
          return 0;
      }
      int leftCount = count(root.left);
      int rightCount = count(root.right);
      // 后序位置
      printf("节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点",
              root, leftCount, rightCount);
  
      return leftCount + rightCount + 1;
  }
  ```

  这两个问题的根本区别在于：一个节点在第几层，你从**根节点遍历过来的过程就能顺带记录**；而以一个节点为根的整棵子树有多少个节点，你需要**遍历完子树**之后才能数清楚。

  总结：

  **一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**

- 例题

  #### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

  给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

  ```java
      //每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和
      //base case: 当二叉树达到叶子结点，返回0
      //递推关系：
      // int result = maxleft + maxright;
      // max = Math.max(result,max);
      //返回值：以当前节点为头的二叉树的最大高度
  
  	int max;  //左右子树的最大深度之和
      public int diameterOfBinaryTree(TreeNode root) {
          max = 0;
          if(root==null) return 0;
          recur(root);
          return max;
      }
  
      //后序
      public int recur(TreeNode root){
          //base case
          if(root==null){
              return 0;
          }
  
          int maxleft = recur(root.left);
          int maxright = recur(root.right);
  
          //后序
          int result = maxleft + maxright;
          //更新最大值
          max = Math.max(result,max);
  
          //返回的是二叉树的高度
          return Math.max(maxleft,maxright) + 1;
      }
  ```

  

##### 2.3.2 中序

中序的特殊一般在BST



#### 2.4 层序遍历

- 模板

  ```java
  // 输入一棵二叉树的根节点，层序遍历这棵二叉树
  void levelTraverse(TreeNode root) {
      if (root == null) return;
      Queue<TreeNode> q = new LinkedList<>();
      q.offer(root);
  
      // 从上到下遍历二叉树的每一层
      while (!q.isEmpty()) {
          int sz = q.size();
          // 从左到右遍历每一层的每个节点
          for (int i = 0; i < sz; i++) {
              TreeNode cur = q.poll();
              // 将下一层节点放入队列
              if (cur.left != null) {
                  q.offer(cur.left);
              }
              if (cur.right != null) {
                  q.offer(cur.right);
              }
          }
      }
  }
  ```
  
  while 循环和 for 循环分管从上到下和从左到右的遍历,如图所示
  
  ![](appendix\3.png)

当然这个框架还可以灵活修改，题目不需要记录层数（步数）时可以去掉上述框架中的 for 循环，比如前文  [Dijkstra 算法](https://labuladong.gitee.io/algo/2/20/55/) 中计算加权图的最短路径问题，详细探讨了 BFS 算法的扩展。

值得一提的是，有些很明显需要用层序遍历技巧的二叉树的题目，也可以用递归遍历的方式去解决，而且技巧性会更强，非常考察你对前中后序的把控。



## 思维

### 1. 思维模板

- 思维一：是否可以通过遍历一遍二叉树得到答案？【遍历】【回溯】

  `traverse` 函数 + 外部变量

- 思维二：是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？【分解问题】【动态规划】【后序】

  `traverse` 函数 + 返回值

无论使用哪种思维模式，都需要思考：**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。



### 2. 题

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

- 思维一：

  - 可以。通过遍历，翻转每个节点的左右节点。
  - 单独抽出一个节点，需要让该节点的左右节点进行交换。
  - 什么时候做，前中后都可。

  ```java
  //方法一：遍历
  //可以。通过遍历，翻转每个节点的左右节点。
  //单独抽出一个节点，需要让该节点的左右节点进行交换。
  //什么时候做，前中后都可。
  
  //base case: 叶子节点返回null
  //递推：左右节点交换
  //返回值：以当前节点为树的交换后的头
      public TreeNode invertTree(TreeNode root) {
          //base case
          if(root==null) return root;
  
          TreeNode tmp = root.left;
          root.left = root.right;
          root.right = tmp;
  
          invertTree(root.left);
          invertTree(root.right);
  
          return root;
      }
  ```

- 思维二：

  - 可以。分解为交换左右两棵子树的子问题。
  - 单独抽出一个节点，需要让该节点的左右**子树**进行交换。
  - 什么时候做，后序。

  ```java
  //方法二：分解
  // - 可以。分解为交换左右两棵子树的子问题。
  // - 单独抽出一个节点，需要让该节点的左右**子树**进行交换。
  // - 什么时候做，后序。
  
  //base case: 叶子节点返回null
  //递推：左右子树交换
  //返回值：以当前节点为树的交换后的头
      public TreeNode invertTree(TreeNode root) {
          //base case
          if(root==null) return root;
  
          TreeNode l = invertTree(root.left);
          TreeNode r = invertTree(root.right);
  
          root.left = r;
          root.right = l;
  
          return root;
      }
  }
  ```

#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

题目：

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

解法：

- 思维一：

  - 可以，让中间虚拟出一个节点，遍历三叉树

  - 抽出一个节点。让它左右节点做如下递推

  - 遍历：好像都可以，先序吧

  ```java
      // 递归遍历：
      // 可以，让中间虚拟出一个节点，遍历三叉树
      // 抽出一个节点。让它左右节点做如下递推
      // 遍历：好像都可以，先序吧
  
      //base case: 如果到叶子节点 return 
      //递推：
      //node1,node2
      //node1.left.next = node1.right
      //node2.left.next = node2.right
      //node1.right.next = node2.left
      //返回值：无
  
      public Node connect(Node root) {
          if(root==null){
              return null;
          }
          recur(root.left,root.right);
          return root;
      }
  
      public void recur(Node p1, Node p2){
          //base case
          if(p1==null || p2==null){
              return;
          }
  
          // 将传入的两个节点穿起来
          p1.next = p2;
  
          // 连接相同父节点的两个子节点
          recur(p1.left, p1.right);
          recur(p2.left,p2.right);
          // 连接跨越父节点的两个子节点
          recur(p1.right,p2.left);
      }
  ```

  

- 思维二：不可行

- 层序遍历

  ```java
      //层序遍历
      
      public Node connect(Node root) {
          if(root==null) return root;
  
          //队列
          LinkedList<Node> q = new LinkedList<>();
          q.addLast(root);
  
          //开始层序遍历
          while(!q.isEmpty()){
              int len = q.size();
              //一层从左到右依次遍历
              for(int i=0;i < len;i++){
  
                  Node cur = q.removeFirst();
                  
                  // if(!q.isEmpty()){
                  //这个条件不对，是到最后一个节点才没有
                  if(i < len-1){
                      cur.next = q.getFirst();
                  }
  
                  if(cur.left!=null){
                      q.addLast(cur.left);
                  }
  
                  if(cur.right!=null){
                      q.addLast(cur.right);
                  }
              }
              //一层结束了
          }
          return root;
      }
  ```

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

**题目**：给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**解法：**

- 思维一：

  返回值为null，这是希望将其原地转换

   如果有返回值，则可以利用空间构造单链表,直接存储前序遍历的结果

  ```java
      //返回值为null，这是希望将其原地转换
      //如果有返回值，则可以利用空间构造单链表,直接存储前序遍历的结果
      TreeNode dummy = new TreeNode(-1);
      dummy.right = root;
      TreeNode p = dummy;
      public TreeNode flatten(TreeNode root) {
          //base case
          if(root==null) return;
  
          //递推
          p.right = root;
          p = p.right;
  
          flatten(root.left);
          flatten(root.right);
  
          return dummy.right;
      }
  ```

  

- 思维二：（一定要把图画出来，就会很清晰了）

    没有返回值，不能通过遍历的方式解决

  - 分解子问题：对于一个节点，返回以该节点为头的二叉树被拉平的链表的头

  - 抽出一个单个节点：把他的左右子树进行拉平，也就是拼接

  - 位置：后序

    ![](appendix\4.png)

  ```java
      //没有返回值，不能通过遍历的方式解决
      //分解子问题：对于一个节点，返回以该节点为头的二叉树被拉平的链表的头
      //抽出一个单个节点：把他的左右子树进行拉平，也就是拼接
      //位置：后序
  
  	//base case:叶子节点,return
  	//递推：把他的左右子树进行拉平，也就是拼接
  	//返回值：无，原地
      public void flatten(TreeNode root) {
          if(root==null) return;
          recur(root);
      }
  
      //对于一个节点，返回以该节点为头的二叉树被拉平的链表的头
      public TreeNode recur(TreeNode root){
          //base case
          if(root==null) return null;
  
          //递推
          TreeNode l = recur(root.left);
          TreeNode r = recur(root.right);
  
          //抽出的一个节点要做的事情
          root.left = null;
          root.right = l;
  
          TreeNode p = root; //保留当前的root
          while(p.right!=null){
              p = p.right;
          }
  
          p.right = r;
  
          return root;
      }
  ```

## 构造

**二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

#### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:

    创建一个根节点，其值为 nums 中的最大值。
    递归地在最大值 左边 的 子数组前缀上 构建左子树。
    递归地在最大值 右边 的 子数组后缀上 构建右子树。

返回 nums 构建的 最大二叉树 。

思路：

```java
    //分解：先构造根，构造左子，构造右子，返回头
    //单独抽取一个节点。lm = 找到左边的最大值，root.left = lm,rm = 找到右边的最大值,root.right = rm
    //位置：先序

    //base case : 叶子结点
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return recur(nums,0,nums.length-1);
    }

    //在区间[low,high]里进行处理
    public TreeNode recur(int[] nums,int low,int high){
        if(low > high){
            return null;
        }

        //找到最大值,记录最大值的索引
        int maxindex = low;
        for(int i = low;i <= high;i++){
            if(nums[maxindex] < nums[i]){
                maxindex = i;
            }
        }

        // System.out.println(nums[maxindex] + "\t" + maxindex + "\t[" + low + "," + high + "]");

        //构造二叉树
        TreeNode root = new TreeNode(nums[maxindex]);

        root.left = recur(nums,low,maxindex-1);
        root.right = recur(nums,maxindex + 1,high);

        return root;
    }
```

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

![](appendix\5.png)

```java
    //1,分解： 根，左子树，右子树
    //2,抽出一个节点。找到根，root.left = 左子树的根，root.right = 右子树的根
    //root = preorder[preStart]
    //root.left = recur(preorder,preStart+1,preStart+leftsize,inorder,inStart,inindex-1);
    // root.right = recur(preorder,preStart+leftsize+1,preEnd,inorder,inindex+1,inEnd);
    //3,位置：先序

    //base case:区间里没有元素了，返回null
    //递推：
    //root = preorder[preStart]
    //root.left = recur(preorder,preStart+1,preStart+leftsize,inorder,inStart,inindex-1);
    // root.right = recur(preorder,preStart+leftsize+1,preEnd,inorder,inindex+1,inEnd);
    //返回值：当前区间构建的树的根


    //利用hashmap存取下标和元素的对应关系，优化在inorder中找跟的index,因为没有重复的元素了
    HashMap<Integer,Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i = 0;i < inorder.length;i++){
            map.put(inorder[i],i);
        }

        return recur(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }

    public TreeNode recur(int[] preorder, int preStart, int preEnd,int[] inorder,int inStart,int inEnd){
        //base case
        if(preStart > preEnd){
            return null;
        }
        //
        int rootval = preorder[preStart];
        int inindex = map.get(rootval);

        TreeNode root = new TreeNode(rootval);
        int leftsize = inindex - inStart;
        root.left = recur(preorder,preStart+1,preStart+leftsize,inorder,inStart,inindex-1);
        root.right = recur(preorder,preStart+leftsize+1,preEnd,inorder,inindex+1,inEnd);

        return root;
    }
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

![](appendix\6.png)

```java
    HashMap<Integer,Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] inorder, int[] postorder ) {
        for(int i = 0;i < inorder.length;i++){
            map.put(inorder[i],i);
        }

        return recur(inorder,0,inorder.length-1,postorder,0,postorder.length-1);
    }

    public TreeNode recur(int[] inorder, int inStart, int inEnd,int[] postorder,int posStart,int posEnd){
        //base case
        if(inStart > inEnd){
            return null;
        }
        //
        int rootval = postorder[posEnd];
        // System.out.println(rootval+"\t"+inStart+"\t"+inEnd);
        // System.out.println(rootval+"\t"+posStart+"\t"+posEnd);
        // System.out.println(rootval);
        int inindex = map.get(rootval);

        TreeNode root = new TreeNode(rootval);
        int leftsize = inindex - inStart;
        root.left = recur(inorder,inStart,inindex-1,postorder,posStart,posStart+leftsize-1);
        root.right = recur(inorder,inindex+1,inEnd,postorder,posStart+leftsize,posEnd-1);

        return root;
    }
```

#### [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

题目：

给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。

如果存在多个答案，您可以返回其中 任何 一个。

思路：

由于前序和后序不能确定唯一的二叉树，可以假定root.left = preorder[left+1]

![](appendix\7.png)

方法与之前类似, 就是要注意base case

```java
    //假设左子树的根是先序遍历的之前的根的下一个值
    HashMap<Integer,Integer> map = new HashMap<>();
    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        for(int i = 0;i < postorder.length;i++){
            map.put(postorder[i],i);
        }

        return recur(preorder,0,preorder.length-1,postorder,0,postorder.length-1);
    }

    public TreeNode recur(int[] preorder, int preStart, int preEnd,int[] postorder,int postStart,int postEnd){
        //base case
        if(preStart > preEnd){
            return null;
        }

        //当没有左孩子
        if(preStart + 1 > preEnd){
            return new TreeNode(preorder[preStart]);
        }
        //递推
        int rootval = preorder[preStart];
        int leftval = preorder[preStart + 1];
        int postindex = map.get(leftval);

        TreeNode root = new TreeNode(rootval);

        int leftSize = postindex - postStart + 1;
        root.left = recur(preorder,preStart+1,preStart+leftSize,postorder,postStart,postindex);
        root.right = recur(preorder,preStart+leftSize+1,preEnd,postorder,postindex+1,postEnd-1);

        return root;
    }
```

#### [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

题目：给定一棵二叉树 `root`，返回所有**重复的子树**。

思路：

将子树的**前序序列化**保留，以此来判断是否有重复，注意空值要填null

```java
    //分解：求子树
    //对于单个节点：把当前子树的先序遍历(序列化)放到hashmap中，已经当前所有子树存入hashmap，对比是否与当前序列有重复的，放入结果中
    //位置：后序

    //放序列，对应的次数
    HashMap<String,Integer> map; 
    List<TreeNode> ans;
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        map = new HashMap<>(); 
        ans = new ArrayList<>();
        recur(root);
        return ans;
    }

    //base case: root==null， 叶子节点，序列化“#”
    //递推：先加入hashmap,再判断是否重复
    //返回值：返回以当前节点为根的二叉树的前序序列化
    public String recur(TreeNode root){
        //base case
        if(root==null){
            return "#";
        }

        //先添加
        String serial = root.val + "," + recur(root.left) + "," + recur(root.right);
        map.put(serial,map.getOrDefault(serial,0)+1);

        //判断与当前序列（子树）是否有重复的
        if(map.get(serial)==2) ans.add(root);
        return serial;
    }
```

