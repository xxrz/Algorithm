# 图

## 1. 图论基础

- 面试笔试很少出现图相关的问题，就算有，大多也是简单的遍历问题，基本上可以完全照搬多叉树的遍历。

- 邻接表，好处是占用的空间少。

  邻接表无法快速判断两个节点是否相邻。

  > 在常规的算法题中，邻接表的使用会更频繁一些，主要是因为操作起来较为简单

- 在无向图中，「度」就是每个节点相连的边的条数

  有向图的边有方向，所以有向图中每个节点「度」被细分为**入度**（指向该节点）和**出度**（该节点指出去）

- 其实环检测和拓扑排序的算法差别不大，只是拓扑排序会记录结果

  

### 1.1 遍历(DFS)

参考多叉树的遍历

```java
/* 多叉树遍历框架 */
void traverse(TreeNode root) {
    if (root == null) return;

    for (TreeNode child : root.children) {
        traverse(child);
    }
}
```

图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点。

所以，如果图包含环，遍历框架就要一个 `visited` 数组进行辅助，如果不含环则可以省略

```java
// 记录被遍历过的节点
boolean[] visited;
// 记录从起点到当前节点的路径(这块可以相应的节点类型的值)
boolean[] onPath;

/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (int neighbor : graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}
```

#### [797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

![image-20220418105146327](appendix\2总结——5图\image-20220418105146327.png)

```java
    //因为是无环图，所以不用visit
    // 记录所有路径
    List<List<Integer>> res = new LinkedList<>();
    // 维护递归过程中经过的路径
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        //graph是邻接表,其长度表示有几个节点
        traverse(graph, 0);
        return res;  
    }

    //s为遍历的当前节点
    //多叉树的先序遍历
    public void traverse(int[][] graph, int s){
        //添加节点到路径
        path.addLast(s);

        //base case
        if(s==graph.length-1){
            res.add(new LinkedList<>(path));
            ////移除叶子节点(也就是题目中的n)
            /////如果此处注释掉，那么最后的removeLast也可以保证n节点的移除
            // path.removeLast();
            // return;
        }
        
        //递归每个相邻节点
        for(int v:graph[s]){
            traverse(graph,v);
        }

        //移除非叶子节点的节点(除n外的节点)
        path.removeLast();
    }
```



### 1.2 环检测算法

以此题为例：[207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

题目：

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

    例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。

请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

思路：

**如果发现这幅有向图中存在环，那就说明课程之间存在循环依赖，肯定没办法全部上完；反之，如果没有环，那么肯定能上完全部课程**。（环就是互相依赖）

注意：环和连通不是一个概念，比如上题中的图是连通的，但是不存在环



#### 1.2.1 DFS

```java
    //两个节点不重复，这么做会减少计算量，如果碰到visited被标记为true，则说明前面已经对这个节点之后的样子做出判断了，无须再进行延伸，所以减少计算量
    boolean[] visited;//（代表以这个节点为头的路径是否有判断过）
    boolean[] onPath; //记录当前路径上存在的节点（只代表一条路径）
    //有环就是当前路径上存在两个一样的节点

    // 记录图中是否有环
    boolean hasCycle = false;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses,prerequisites);

        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];  

        //因为图不是连通的，所以需要遍历每个节点
        for (int i = 0; i < numCourses; i++) {
            // 遍历图中的所有节点
            traverse(graph, i);
        }

        // 只要没有循环依赖可以完成所有课程
        return !hasCycle;  
    }

    void traverse(List<Integer>[] graph, int i){
        //base case
        if(onPath[i]==true) {
            hasCycle = true;
            return;
        }

        if(visited[i]==true) return;
        
        //先序代码的位置
        visited[i] = true;
        onPath[i] = true;
        for(int v : graph[i]){
            traverse(graph,v);
        }

        onPath[i] = false;
    }

    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites){
        //图中共有numCourses个节点
        //二维数组，采用邻接表的方式表示图
        List<Integer>[] graph = new LinkedList[numCourses];
        
        for(int i = 0;i < numCourses;i++){
            //graph[i]中放得i节点到其他的节点的节点列表
            graph[i] = new LinkedList<>();
        }

        for(int[] edge:prerequisites){
            int from= edge[1],to = edge[0];
            // 添加一条从 from 指向 to 的有向边
            // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
            graph[from].add(to);
        }

        return graph;
    }
```



#### 1.2.2 BFS

BFS 算法思路：

1. 构建邻接表，和之前一样，边的方向表示「被依赖」关系。a->b，则先a后b

2. 构建一个 `indegree` 数组记录每个节点的入度，即 `indegree[i]` 记录节点 `i` 的入度。

3. 对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列。

4. **开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将新的入度变为 0 的节点加入队列**。（记住是变为0的节点）

5. **如果最终所有节点都被遍历过（`count` 等于节点数），则说明不存在环，反之则说明存在环**。

```java
    //bfs
    //构建入度
    int[] indegree;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        //建图 + 记录入度
        indegree = new int[numCourses];
        List<Integer>[] graph = buildGraph(numCourses,prerequisites);

        System.out.println(Arrays.toString(indegree));
        
        //根据入度初始化队列中的节点,找没有入度的点作为拓扑排序的起点
        Queue<Integer> q = new LinkedList<>();
        for(int i=0;i < indegree.length;i++){
            if(indegree[i]==0){
                //节点i没有入度，即没有依赖的节点，可以直接学
                //所以可以作为拓排序的起点，加入队列
                q.offer(i);
            }
        }

        //记录遍历的节点个数,用来判断节点是否遍历完，也就是最后是不是会成环
        int cnt = 0;

        //两种遍历方式都可以
        //1.
        // while(!q.isEmpty()){
        //     //弹出节点cur，并把他指向的节点的入度减一
        //     cnt++;
        //     int cur = q.poll();
        //     for(int next : graph[cur]){
        //         indegree[next]--;
        //         if(indegree[next]==0){
        //             q.offer(next);
        //         } 
        //     }
        // }

        //2.
        while(!q.isEmpty()){
            //弹出节点cur，并把他指向的节点的入度减一
            int len = q.size();
            //每一层
            for(int i = 0;i < len;i++){
                cnt++;
                int cur = q.poll();
                //操作，将所有指向节点的入度都减1
                for(int next : graph[cur]){
                    indegree[next]--;
                    if(indegree[next]==0){
                        q.offer(next);
                    } 
                }
            }
        }

        return cnt == numCourses;
    }

    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites){
        //图中共有numCourses个节点
        //二维数组，采用邻接表的方式表示图
        List<Integer>[] graph = new LinkedList[numCourses];
        
        for(int i = 0;i < numCourses;i++){
            //graph[i]中放得i节点到其他的节点的节点列表
            graph[i] = new LinkedList<>();
        }

        for(int[] edge:prerequisites){
            int from= edge[1],to = edge[0];
            // 添加一条从 from 指向 to 的有向边
            // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
            graph[from].add(to);
            // 构建入度
            indegree[to]++;
        }

        return graph;
    }
```



### 1.2 拓扑排序

#### 1.2.1 定义

在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：

    每个顶点出现且只出现一次。
    若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。

注意：

有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。

拓扑排序通常用来“排序”具有依赖关系的任务。

**直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的**，比如上图所有箭头都是朝右的。



以此题为例：[210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

题目：需要返回上课顺序



#### 1.2.2 DFS

如何进行拓扑排序？

**将后序遍历的结果进行反转，就是拓扑排序的结果**。

注意：

建的图中箭头方向是「被依赖」关系，比如节点 `1` 指向 `2`，含义是节点 `1` 被节点 `2` 依赖，即做完 `1` 才能去做 `2`，

如果反过来，把有向边定义为「依赖」关系，那么整幅图中边全部反转，就可以不对后序遍历结果反转。具体来说，就是把代码中 `graph[from].add(to);` 改成 `graph[to].add(from);` 就可以不反转了。

思路：

二叉树的后序遍历是什么时候？遍历完左右子树之后才会执行后序遍历位置的代码。换句话说，当左右子树的节点都被装到结果列表里面了，根节点才会被装进去。

**后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行**。

所以先序不可以，因为会伸下去

```java
//两个节点不重复，这么做会减少计算量，如果碰到visited被标记为true，则说明前面已经对这个节点之后的样子做出判断了，无须再进行延伸，所以减少计算量
    boolean[] visited;//（代表以这个节点为头的路径是否有判断过）
    boolean[] onPath; //记录当前路径上存在的节点（只代表一条路径）
    //有环就是当前路径上存在两个一样的节点
    // 记录后序遍历结果
    List<Integer> postorder = new ArrayList<>();

    // 记录图中是否有环
    boolean hasCycle = false;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses,prerequisites);

        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];

        //因为图不是连通的，所以需要遍历每个节点
        for (int i = 0; i < numCourses; i++) {
            // 遍历图中的所有节点
            traverse(graph, i);
        }

        if(hasCycle){
            return new int[]{};
        }

        Collections.reverse(postorder);
        int[] res = new int[numCourses];
        for(int i=0;i < numCourses;i++){
            res[i] = postorder.get(i);
        }

        return res;
    }

    void traverse(List<Integer>[] graph, int i){
        //base case
        if(onPath[i]==true) {
            hasCycle = true;
            return;
        }

        if(visited[i]==true) return;
        
        //先序代码的位置
        visited[i] = true;
        onPath[i] = true;
        for(int v : graph[i]){
            traverse(graph,v);
        }

        //后序代码的位置
        //加入当前节点，邻接表，也就是i
        postorder.add(i);
        onPath[i] = false;
    }

    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites){
        //图中共有numCourses个节点
        //二维数组，采用邻接表的方式表示图
        List<Integer>[] graph = new LinkedList[numCourses];
        
        for(int i = 0;i < numCourses;i++){
            //graph[i]中放得i节点到其他的节点的节点列表
            graph[i] = new LinkedList<>();
        }

        for(int[] edge:prerequisites){
            int from= edge[1],to = edge[0];
            // 添加一条从 from 指向 to 的有向边
            // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
            graph[from].add(to);
        }

        return graph;
    }
```



#### 1.2.3 BFS

1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。
2. 从图中删除该顶点和所有以它为起点的有向边。
3. 重复 1 和 2 直到当前的 DAG 图为空或**当前图中不存在无前驱的顶点为止**。**后一种情况说明有向图中必然存在环**。



BFS 算法思路：（对应上面的环检测的步骤，只是多了步记录）

1. 构建邻接表，和之前一样，边的方向表示「被依赖」关系。a->b，则先a后b

2. 构建一个 `indegree` 数组记录每个节点的入度，即 `indegree[i]` 记录节点 `i` 的入度。

3. 对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列。入队列的顺序其实就是拓扑排序的顺序。

4. **开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将新的入度变为 0 的节点加入队列**。（记住是变为0的节点）

5. **如果最终所有节点都被遍历过（`count` 等于节点数），则说明不存在环，反之则说明存在环**。

```java
    //bfs
    //构建入度
    int[] indegree;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        //建图 + 记录入度
        indegree = new int[numCourses];
        List<Integer>[] graph = buildGraph(numCourses,prerequisites);

        
        //根据入度初始化队列中的节点,找没有入度的点作为拓扑排序的起点
        Queue<Integer> q = new LinkedList<>();
        for(int i=0;i < indegree.length;i++){
            if(indegree[i]==0){
                //节点i没有入度，即没有依赖的节点，可以直接学
                //所以可以作为拓排序的起点，加入队列
                q.offer(i);
            }
        }

        //记录遍历的节点个数,用来判断节点是否遍历完，也就是最后是不是会成环
        int cnt = 0;
        //记录结果
        int[] res = new int[numCourses];

        //两种遍历方式都可以
        //1.
        // while(!q.isEmpty()){
        //     //弹出节点cur，并把他指向的节点的入度减一
        //     res[cnt++] = cur;
        //     int cur = q.poll();
        //     for(int next : graph[cur]){
        //         indegree[next]--;
        //         if(indegree[next]==0){
        //             q.offer(next);
        //         } 
        //     }
        // }

        //2.
        while(!q.isEmpty()){
            //弹出节点cur，并把他指向的节点的入度减一
            int len = q.size();
            //每一层
            for(int i = 0;i < len;i++){
                
                int cur = q.poll();
                // 弹出节点的顺序即为拓扑排序结果
                res[cnt++] = cur;
                //操作，将所有指向节点的入度都减1
                for(int next : graph[cur]){
                    indegree[next]--;
                    if(indegree[next]==0){
                        q.offer(next);
                    } 
                }
            }
        }
		
        //看是否有环
        return cnt==numCourses? res : new int[]{};
    }

    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites){
        //图中共有numCourses个节点
        //二维数组，采用邻接表的方式表示图
        List<Integer>[] graph = new LinkedList[numCourses];
        
        for(int i = 0;i < numCourses;i++){
            //graph[i]中放得i节点到其他的节点的节点列表
            graph[i] = new LinkedList<>();
        }

        for(int[] edge:prerequisites){
            int from= edge[1],to = edge[0];
            // 添加一条从 from 指向 to 的有向边
            // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
            graph[from].add(to);
            // 构建入度
            indegree[to]++;
        }

        return graph;
    }
```

