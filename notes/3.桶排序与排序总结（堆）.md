# 桶排序和排序总结

1. 堆是特殊的完全二叉树

   连续的空间一段（数组），可以对应完全二叉树

   左 2*i+1 

   右 2*i+2

   父 i-1/2 

   大根堆：每一颗子树的最大值是头结点的值

   大根堆：每一颗子树的最小值是头结点的值

   heapsize=0



2. 堆操作

   - heapinsert过程（向上）：
     新进来的数不断和**父节点**比较，大就换，再跟父比较，直到不比父大，或者到了头

     时间复杂度：logn

   - heapify取出最大的数，并去掉（向下）：将最后一个元素和堆顶交换，让堆顶和**孩子**中最大的比较，孩子大交换，直到没有孩子，或者孩子都没顶大

     heapsize确认heap的大小

     时间复杂度：logn

     

3. 堆排序

   一次heapInsert，heapsize++，选出一个最大值，扩充到整个数组，让其变成大根堆

   一次heapify排除最大值，继续选，heapsize--

   

4. 将整个数组变成大根堆，不是说是一个一个给的

   从右往左，可以只做heapify的过程

   时间复杂度：O(N）

   ```java
   // O(N*logN)
   //    for (int i = 0; i < arr.length; i++) { // O(N)
   //       heapInsert(arr, i); // O(logN)
   //    }
         // O(N)
         for (int i = arr.length - 1; i >= 0; i--) {
            heapify(arr, i, arr.length);
         }
   ```

   

   4. 例题

![题](appendix\堆1.png)

小根堆 K=6，先遍历前7个数据

小根堆的最小值弹出

小根堆就是优先级队列

```java
//小根堆
PriorityQueue<Integer> heap = new PriorityQueue<>();
//大跟堆，传一个策略
PriorityQueue<Integer> heap = new PriorityQueue<>(new Acomp());

```

堆扩容：O（N*logn）/N

黑盒堆，不要在内部搞，只是加一个，弹一个不高效 （这个题）

手写堆，对内部需要调整，高效



5. 比较器

想怎么比大小的策略,定义复杂的比较策略

C++：重载比较运算符==java：比较器

>任何compare方法:  
>如果返回负数，认为第一个参数应该排在前面   
>如果返回正数，认为第二个参数应该排在前面    
>如果返回0，认为谁放前面无所谓 

>Arrays.sort(students, new IdComparator());   
>arrList.sort(new AgeComparator());  

compareTo比较器

https://www.jianshu.com/p/323d120c6dae



6. 不基于比较的排序（桶排序）

   不基于比较的排序，没有基于比较的排序那么大的应用范围，是需要根据数据状况定制

   - 计数排序

   - 基数排序

     桶是容器，什么结构都可以，堆，队列..

     [017,013,025,100,072]

     先根据个位数放桶，桶从左往右倒出来，先进先出

     根据十位数，倒

     根据百位，倒

     - 代码

       count：词频数组——》前缀和，各自处理各自的片

       从右往左，划片，且最右边的是最后进去的，从而确定位置，为保证 先入桶的先出，辅助桶

     ![桶](appendix\桶1.png)



看看希尔排序，多轮插入排序

6. 排序总结

- 稳定性：相同的元素排序前后是否会变（非计数情况有用，相同值的比较）

  不稳定：

  ​	选择排序：333313333

  ​	快速排序：partition的过程就失去稳定性了

  ​	堆排：5446 只跟自己的父亲孩子玩

  稳定：

  ​	冒泡排序：

  ​	插入排序：

  ​	归并排序：先拷贝左边的就可以稳定，小和问题需要先拷右边的

  ​	桶排序：先入先出

- 总体

  |      |  时   |  空  |  稳  |
  | ---- | :---: | :--: | :--: |
  | 选择 |  n^2  |  1   |  X   |
  | 冒泡 |  n^2  |  1   |  √   |
  | 插入 |  n^2  |  1   |  √   |
  | 归并 | nlogn |  n   |  √   |
  | 快速 | nlogn | logn |  X   |
  | 堆   | nlogn |  1   |  x   |

  1）不基于比较的排序，对样本数据有严格要求，不易改写  
  2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用  
  3）基于比较的排序，时间复杂度的极限是O($N*logN$)  
  4）时间复杂度O($N*logN$)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存  在的。  
  5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并  

  

- 常见的坑

  1）归并排序的额外空间复杂度可以变成O(1)，“归并排序 内部缓存法”，但是将变得不再稳定。
      ==> 可以, 方法很难, 都不稳定了, 为什么不用堆排序?

  2）“原地归并排序" 是垃圾贴，会让时间复杂度变成O(N^2) 
      ==> 额外空间复杂度可以变成O(1), 但让时间复杂度退变成N^2, 用插入排序多好

  3）快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多。
     ==> 可以, 要求对数据范围做限制, 快排就是基于比较的排序, 对数据状况做限制, 为什么不用不基于比较的桶排序呢?

  题目5: [[在整型数组中把奇数放在左边偶数放在右边且保持稳定性]]

- 工程上的改进

  1)稳定性的考虑 

  利用归并保持稳定性

  2)充分利用O(N*logN)和O(N^2)排序各自的优势

  综合排序

  ![综合排序](\appendix\综合排序.png)

  小范围插入 ，大范围快速，归并