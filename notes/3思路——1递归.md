# 递归

## 链表

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```java
    //递归解法:
    //1. 返回值：交换完成后子链表的头
    //2. 递推关系：p1(head),p2(head.next)。p1连p2后面交换完成的链表的值，p2连p1
    //3. base case : 当p1或者p2为空的时候停止递归（也就是head、head.next）
    public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }

        ListNode next = head.next;
        head.next = swapPairs(next.next);
        next.next = head;

        return next;
        
    }
```

#### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

题目：

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

思路：

```java
//递归
//1. 返回值：反转后链表的头
//2. 递推关系：head是当前节点，node是除head以外反转好的子链的头（不再是head.next），试着1->2->3->4走下就明白了
//head.next.next = head,head.next=null
//3. base case: head==null || head.next==null(没有办法链接了)
    public ListNode reverseList(ListNode head){
        //base case
        if(head==null || head.next==null){
            return head;
        }

        //递推关系
        ListNode node = reverseList(head.next);

        //反转操作
        head.next.next = head;
        head.next = null;
		
        //返回值
        return node;
    }
```

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

题目：将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

思路：

```java
//递归
//1. 返回值：合并后的链的尾
//2. 递推关系：
//- p1 < p2: 返回p1; p1.next = p1.next和p2的合并的头
//- p2 < p1: 返回p2; p2.next = p2.next和p1的合并的头
//3. base case: 
//- p1==null return p2
//- p2==null return p1
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null ||l2==null){
            return l1!=null?l1:l2;
        }

        if(l1.val <= l2.val){
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l2.next,l1);
            return l2;
        }

    }
```



