# 二叉树

### 1. 二叉树结构

- 存储结构

  ```java
  public static class Node {
      public int value;
      public Node left;
      public Node right;
      
      public Node(int data) {
          this.value = data;
      }
  }
  ```



### 2.递归非递归的遍历

- 递归遍历

  ```java
  public static void f(Node head){
  	//1当前根节点（第几次到达）
      if(head==null){
          return;
      }
      //1
      f(head.left);
      //2
      //2
      f(head.right);
      //3
  }
  ```

  - 递归序

  ![1](appendix\二叉树1.png)

  一个节点会到达三次，如图所示

  - 先序：头左右。1,2,4,5,3,6,7。第一次到结点打印，其他无操作
  - 中序：左头右。4,2,5,1,6,7,3。第二次到节点打印，其他无操作
  - 后续：左右头。4,5,2,6,7,3,1。第三次到节点打印，其他无操作

- 非递归：任何递归都可以改成非递归

  - 先序:  头左右

    **注意入栈顺序是头右左，则出栈顺序是头左右**

    自己压栈，先压根节点，然后

    ![1](appendix\递归1.png)

    ```java
    public staic void preOrderUnRecur(Node head){
    	System.out.println("pre-order:");
        if(head!=null){
    		Stack<Node> stack = new Stack<Node>();
            //先压入一个头结点
            stack.push(head);
        }
        //注意循环条件
        while(!stack.isEmpty()){
            head = stack.pop();
            System.out.println(head.value + " ");
            
            //先右
            if(head.rigth!=null){
                stack.push(head.right);
            }
            //后左
            if(head.left!=null){
                stack.push(head.left);
            }
       } 
    }
    ```

  - 先序‘ （后序）：头右左。

    收集栈，出栈一起打印就是后序。

    ![1](appendix\树先序1.png)

     解释：栈1里出栈顺序是头右左，收集栈的出栈顺序就是左右头

    ```java
    public staic void posOrderUnRecur(Node head){
    	System.out.println("pos-order:");
        if(head!=null){
    		Stack<Node> s1 = new Stack<Node>();
            //收集栈
            Stack<Node> s2 = new Stack<Node>();
            //先压入一个头结点
            s1.push(head);
        }
        //注意循环条件
        while(!s1.isEmpty()){
            head = s1.pop();
            s2.push(head);
            
            //先左！！！！！
            if(head.left!=null){
                stack.push(head.left);
            }
            //后右
            if(head.right!=null){
                stack.push(head.right);
            }
        }
        
        while(!s2.isEmpty()){
    		System.out.print(s2.pop().value + " ");
        }
    }
    ```

  - 中序：左右中

    每棵子树，整棵树左边界（一路顺着left）进栈，依次弹的过程中打印，对弹出节点右树重复

    解释：因为所有的树都可以被左边界分解掉

    ![1](appendix\二叉树2.png)

    ![1](appendix\二叉树3.png)

    ```java
    public staic void inOrderUnRecur(Node head){
    	System.out.println("in-order:");
        if(head!=null){
    		Stack<Node> stack = new Stack<Node>();
            
            while(!stack.isEmpty() || head!=null){
                //不停的左边界进栈，head一路向左，必有空
                if(head! = null){
    				stack.push(head);
                    head = head.left;
                }else{
    				head = stack.pop();
                    System.out.print(head.value + " ");	
                    //往右动，再压左
                    head = head.right;
                }
            }
    }
    ```

    

### 3. 打印二叉树

用作：平常调试代码用，看看树的样子，向右旋转90度

```java
public class Code02_PrintBinaryTree {

	public static class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public static void printTree(Node head) {
		System.out.println("Binary Tree:");
		printInOrder(head, 0, "H", 17);
		System.out.println();
	}

	public static void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		printInOrder(head.right, height + 1, "v", len);
		String val = to + head.value + to;
		int lenM = val.length();
		int lenL = (len - lenM) / 2;
		int lenR = len - lenM - lenL;
		val = getSpace(lenL) + val + getSpace(lenR);
		System.out.println(getSpace(height * len) + val);
		printInOrder(head.left, height + 1, "^", len);
	}

	public static String getSpace(int num) {
		String space = " ";
		StringBuffer buf = new StringBuffer("");
		for (int i = 0; i < num; i++) {
			buf.append(space);
		}
		return buf.toString();
	}

	public static void main(String[] args) {
		Node head = new Node(1);
		head.left = new Node(-222222222);
		head.right = new Node(3);
		head.left.left = new Node(Integer.MIN_VALUE);
		head.right.left = new Node(55555555);
		head.right.right = new Node(66);
		head.left.left.right = new Node(777);
		printTree(head);

		head = new Node(1);
		head.left = new Node(2);
		head.right = new Node(3);
		head.left.left = new Node(4);
		head.right.left = new Node(5);
		head.right.right = new Node(6);
		head.left.left.right = new Node(7);
		printTree(head);

		head = new Node(1);
		head.left = new Node(1);
		head.right = new Node(1);
		head.left.left = new Node(1);
		head.right.left = new Node(1);
		head.right.right = new Node(1);
		head.left.left.right = new Node(1);
		printTree(head);
	}
}

```



### 4. 宽度优先遍历，求宽度

- 二叉树的深度优先遍历（先序遍历）

- 二叉树的宽度优先遍历：利用队列

  根左右，弹出就打印

  ![1](appendix\二叉树4.png)

  

