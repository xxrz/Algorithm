# 递归

### 设计递归函数

#### 1. 递归

1. 在实现递归函数之前，有两件重要的事情需要弄清楚

   1）**基本情况**： 不需要进一步的递归调用就可以直接计算答案的情况。 算到最后的答案。有时，基本案例也被称为 bottom cases，因为它们往往是问题被减少到最小规模的情况，也就是如果我们认为将问题划分为子问题是一种自上而下的方式的最下层。

   ```java
   其中 f(n−1)f(n - 1)f(n−1) 是青蛙选择跳一步后，剩下的子问题，同理 f(n−2)f(n - 2)f(n−2) 是青蛙选择跳两步后剩下的子问题。这样，我们就把问题进行了分解。
   
   下面再谈谈如何解决，正如上面谈到的解决步骤，如果规模足够小那么直接返回，否则继续降低规模进行递归求解。
   
   边界条件：确定边界条件——即当 n = 1 和 n = 2 时的情况。
   
   在明确了边角条件后，合并就非常的简单，也就是简单的相加即可了。
   ```

   **最小规模问题的解，是递归函数的出口，通过它来实现栈的pop操作，直到栈为空，问题求解。**

   2）**递推关系**： 一个问题的结果与其子问题的结果之间的关系。也就是说，告诉系统怎么调用自己。

          递归结束
          
          //递归调用之后的代码，这里表示返回上一层的逻辑。
          //1. 分治是多个子问题合并成更上一层子问题的合并过程的逻辑；
          //2. 回溯是状态重置的逻辑；

2. 模板

   - 由下到上【后续】:在每个递归层次上，我们首先递归地调用自身，然后根据返回值进行计算。（**依赖返回值**）

   ```java
   public 返回值 f(参数) {
       if (基本情况条件) return 基本情况的结果;       
       
       修改参数；
       返回值 = f(参数); 
       
       最终结果 = 根据参数与返回值计算
       return 最终结果;
   }
   ```

   ```java
   /** 
    * 模拟程序执行过程：
    * 5 + sum(4)
    * 5 + (4 + sum(3)
    * 5 + 4 + (3 + sum(2))
    * 5 + 4 + 3 + (2 + sum(1))
    * ------------------> 到达基本情况 sum(1) = 1 ，开始执行 ③ 行代码
    * 5 + 4 + 3 + (2 + 1)
    * 5 + 4 + (3 + 3)
    * 5 + (4 + 6)
    * (5 + 10)
    * 15
    * <p>
    * 由下到上：最终从 1 + 2 + 3 + 4 + 5 计算...
    * 递归函数「开始」部分调用自身，这个过程就是找到基本情况），然后根据返回值进行计算。
    */
   public int sum(int n) {
       if (n < 2) return n;       // ① 递归基本情况
       int childSum = sum(n - 1); // ② 寻找递归关系
       return n + childSum;       // ③ 根据返回值运算
   }
   ```

   - **由上到下**【先序】：在递归层级中，我们根据**当前「函数参数」计算出一些值，并在递归调用函数时将这些值传给自身**。（**依赖函数参数**，或者全局变量的变化）

     ```java
     /**
      * 模拟程序执行过程：
      * sum(5, 0)
      * sum(4, 5)
      * sum(3, 9)
      * sum(2, 12)
      * sum(1, 14)
      * 15
      * <p>
      * 由上到下：最终从 5 + 4 + 3 + 2 + 1 计算...
      * 递归函数「末尾」部分调用自身，根据逻辑先进行计算，然后把计算的中间变量传递调用函数。
      * <p>
      * 这种在函数末尾调用自身的递归函数叫做「尾递归」
      */
     public int sum2(int n, int sum) {
         if (n < 2) return 1 + sum;
         sum += n;
         return sum2(n - 1, sum);
     }
     ```

     ```java
     public 返回值 f(参数，中间变量) {
         if (基本情况条件) return 基本情况的结果与中间变量的计算结果;
         
         中间变量 = 根据参数与中间变量重新计算
         修改参数；
         
         return f(参数,中间变量);
     }
     ```




#### 2. 分治

- 使用「递归」实现的算法需要走完下面两条路径：（递归序，三次）

  先**「自顶向下」**拆分问题，直到不能拆分为止；

  再**「自底向上」**逐层把底层的结果向上汇报，直至得到原问题的解。

- 步骤：

  - **写出递归终止条件（易忽略），寻找基本情况**

  - **将原问题拆分成为规模更小的子问题（重点）**【中间变量】

    问题规模折半，即拆成两部分;

    问题规模减少1;

    如果数据结构是树的结构，拆分方式肯定是root和各个子节点

  - **将子问题的结果进行合并（难点）**

- 代码框架

  ```java
  返回值 func(param1, param2)
  {
      //1. 递归的终止条件
      if (n == 0) {
          return 返回值;
      }
  
      // 2. 拆分，对应「分而治之」算法的「分」，并且一定要得到一个结果，在思考过程中，要假定这个子问题是可以正确解决的
      // 用于第三步的合
      temp = func(param1, param3); //分治思想, 一般是折半(param2/2)，或者-1(param2 - 1)
      
      // 3. 在递归函数调用完成以后还可以做点事情, 对应「分而治之」的「合」
      ans = temp .....
      return ans;
  }
  ```

- 题目

  

  

#### 3. 回溯

- 到达最底的情况再返回

- 回溯法（backtracking）是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便，状态的重置。

  深搜：[修改当前节点状态]→[递归子节点]

  回溯：[修改当前节点状态]→[递归子节点]→[回改当前节点状态]。

- 重点：一是按引用传状态，二是所有的状态修改在递归完成后回改

  修改一般有两种情况，一种是修改最后一位输出，比如排列组合；一种是修改访问标记，比如矩阵里搜字符串。



#### 4. 举例说明分治和回溯

**一只青蛙一次可以跳上1级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法？**

将问题分解成：走一步的方案，走两步的方案

分解问题，递推公式：

```
f(n) = f(n - 1) + f(n - 2)
```

base:

```java
if(n < 2) 
    n
```

- 分治（由下自上，依赖返回值，后序）

  拿到结果后

  ```java
  public int sum(int n){
  	if (n < 2) return n;  //base
      
      return f(n-1) + f(n-2); //递推 + 返回
  }
  ```

- 回溯（有上自下，依赖参数，先序）

  走到叶子节点才把当前情况走完，故返回

  ```java
  int count;
  public int sum(int n){
  	count = 0;
      dfs(n);
  }
  
  public void dfs(int n){  //方案数，目标台阶数
  	if(n < 2){
          count += n; //base
          return;
      }
      
      dfs(n-1);
      dfs(n-2);  
  }
  ```



#### 5. 树中的递归

二叉树的遍历：剪枝一般放在先序处理，回溯一般放在后序处理



参考：

https://blog.csdn.net/xiaohulunb/article/details/104438504

https://leetcode-cn.com/circle/article/E3OViN/

