# 递归

### 设计递归函数

1. 在实现递归函数之前，有两件重要的事情需要弄清楚

   1）**基本情况**： 不需要进一步的递归调用就可以直接计算答案的情况。 有时，基本案例也被称为 bottom cases，因为它们往往是问题被减少到最小规模的情况，也就是如果我们认为将问题划分为子问题是一种自上而下的方式的最下层。

   **最小规模问题的解，是递归函数的出口，通过它来实现栈的pop操作，直到栈为空，问题求解。**

   2）**递推关系**： 一个问题的结果与其子问题的结果之间的关系。也就是说，告诉系统怎么调用自己。

          递归结束
          
          //递归调用之后的代码，这里表示返回上一层的逻辑。
          //1. 分治是多个子问题合并成更上一层子问题的合并过程的逻辑；
          //2. 回溯是状态重置的逻辑；

2. 递归中的分治

   - 使用「递归」实现的算法需要走完下面两条路径：（递归序，三次）

     先**「自顶向下」**拆分问题，直到不能拆分为止；

     再**「自底向上」**逐层把底层的结果向上汇报，直至得到原问题的解。

   - 步骤：

     - **写出递归终止条件（易忽略）**

     - **将原问题拆分成为规模更小的子问题（重点）**

       问题规模折半，即拆成两部分;

       问题规模减少1;

       如果数据结构是树的结构，拆分方式肯定是root和各个子节点

     - **将子问题的结果进行合并（难点）**

   - 代码框架

     ```java
     返回值 func(param1, param2)
     {
         //1. 递归的终止条件
         if (n == 0) {
             return 返回值;
         }
     
         // 2. 拆分，对应「分而治之」算法的「分」，并且一定要得到一个结果，在思考过程中，要假定这个子问题是可以正确解决的
         // 用于第三步的合
         temp = func(param1, param3); //分治思想, 一般是折半(param2/2)，或者-1(param2 - 1)
         
         // 3. 在递归函数调用完成以后还可以做点事情, 对应「分而治之」的「合」
         ans = temp .....
         return ans;
     }
     ```

3. 二叉树的遍历：剪枝一般放在先序处理，回溯一般放在后序处理



