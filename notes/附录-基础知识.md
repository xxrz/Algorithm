# 基础知识

### 数据类型

1. 基本数据类型大小

   10^5 = 100000

| 类型  | 范围                                     |                         | 字节 |
| ----- | ---------------------------------------- | ----------------------- | ---- |
| byte  | -128~127                                 | -2的7次方到2的7次方-1   | 1    |
| short | -32768~32767                             | -2的15次方到2的15次方-1 | 2    |
| int   | -2147483648~2147483647                   | -2的31次方到2的31次方-1 | 4    |
| long  | -9223372036854774808~9223372036854774807 | -2的63次方到2的63次方-1 | 8    |

2. 大数越界： 随着 n增大, f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终的返回值错误。

   求余运算规则： 设正整数 x, y, p，求余符号为⊙ ，则有 (x + y) ⊙  p = (x ⊙  p + y ⊙  p) ⊙ p。
   解析： 根据以上规则，可推出 f(n) ⊙  p = [f(n-1)⊙ p + f(n-2)⊙ p] ⊙ p，从而可以在循环过程中每次计算 sum=(a+b)⊙1000000007 ，此操作与最终返回前取余等价

3. Integer和int的比较问题
   - 如果Integer类型的两个数相等，如果范围在-128~127（默认），那么用“==”返回true，其余的范围会false，因为会变成地址比较。
   - 两个基本类型int进行相等比较，直接用==即可。
   - 一个基本类型int和一个包装类型Integer比较，用==也可，比较时候，Integer类型做了拆箱操作
   - Integer类型比较大小，要么调用Integer.intValue()转为基本类型用“==”比较，要么直接用equals比较



### 二叉树

- 满二叉树

  一棵深度为k，且有2^k-1个节点的树是满二叉树。

  1)        如果一颗树深度为h，最大层数为k，且深度与最大层数相同，即k=h;

  2)        它的叶子数是： 2^(h-1)   N+1/2;（N为节点个数）

  3)        第k层的结点数是： 2^(k-1)

  4)        总结点数是： 2^k-1 (2的k次方减一)

  5)        总节点数一定是奇数。

  6)        树高：h=log2(n+1)。

- 完全二叉树

  若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h 层所有的结点都连续集中在最左边，这就是完全二叉树。

  1)    深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。

  2)    树高h=log2n + 1。

  