# 基础知识

### 数据类型

1. 基本数据类型大小

   10^5 = 100000

| 类型  | 范围                                     |                         | 字节 |
| ----- | ---------------------------------------- | ----------------------- | ---- |
| byte  | -128~127                                 | -2的7次方到2的7次方-1   | 1    |
| short | -32768~32767                             | -2的15次方到2的15次方-1 | 2    |
| int   | -2147483648~2147483647                   | -2的31次方到2的31次方-1 | 4    |
| long  | -9223372036854774808~9223372036854774807 | -2的63次方到2的63次方-1 | 8    |

2. 大数越界： 随着 n增大, f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终的返回值错误。

   求余运算规则： 设正整数 x, y, p，求余符号为⊙ ，则有 (x + y) ⊙  p = (x ⊙  p + y ⊙  p) ⊙ p。
   解析： 根据以上规则，可推出 f(n) ⊙  p = [f(n-1)⊙ p + f(n-2)⊙ p] ⊙ p，从而可以在循环过程中每次计算 sum=(a+b)⊙1000000007 ，此操作与最终返回前取余等价

3. Integer和int的比较问题
   - 如果Integer类型的两个数相等，如果范围在-128~127（默认），那么用“==”返回true，其余的范围会false，因为会变成地址比较。
   - 两个基本类型int进行相等比较，直接用==即可。
   - 一个基本类型int和一个包装类型Integer比较，用==也可，比较时候，Integer类型做了拆箱操作
   - Integer类型比较大小，要么调用Integer.intValue()转为基本类型用“==”比较，要么直接用equals比较

4. 大数：大数的表示应用字符串 String 类型
   
5. 计算机数字存储：利用补码

   正数的补码是原码自身；

   负数的补码是原码取反+1；（相当于模了）【也可以从右向左第一个1及后面0不变，其他取反】

   -8 表示为：

   原码：10001000 (最高位为符号位)

   补码：11111000

   假设当前时针指向8点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨2小时，即8-2=6；另一种是顺拨10小时，8+10=12+6=6，即8-2=8+10=8+12-2(mod 12)．在12为模的系统里，加10和减2效果是一样的，因此凡是减2运算，都可以用加10来代替。

6. 无进位加法：异或

   进位：与运算后左移1（不是进位加法，只是进位）

   计算机中只有加法，所以将负数表述为补码就可以进行加法运算了
   
   ![](appendix\加法.png)

7. 异或运算：无进位相加

   * 0 ∧ N = N，N ∧ N = 0

   * 满足交换律,结合律

   * 同一批数异或结果相同，无论先后





### 二叉树

- 满二叉树

  一棵深度为k，且有2^k-1个节点的树是满二叉树。

  1)        如果一颗树深度为h，最大层数为k，且深度与最大层数相同，即k=h;

  2)        它的叶子数是： 2^(h-1)   N+1/2;（N为节点个数）

  3)        第k层的结点数是： 2^(k-1)

  4)        总结点数是： 2^k-1 (2的k次方减一)

  5)        总节点数一定是奇数。

  6)        树高：h=log2(n+1)。

- 完全二叉树

  若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h 层所有的结点都连续集中在最左边，这就是完全二叉树。

  1)    深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。

  2)    树高h=log2n + 1。

  