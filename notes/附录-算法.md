# 算法

## KMP

求子串在父串的位置。

### 暴力解法(O(M*N))

```java
    public int strStr(String haystack, String needle) {
        if(needle.isEmpty()) return 0;
        int len1 = haystack.length(),len2 = needle.length();
        char[] h= haystack.toCharArray(), n = needle.toCharArray();

        //开始循环
        for(int i = 0;i <= len1-len2;i++){
            int a = i, b =0;
            while(b < len2 && h[a]==n[b]){
                a++;
                b++;
            }
            if(b==len2) return i;
        }
        return -1;
    }
```



### KMP逻辑理解

根据**str2（子串）**，求最长前缀和后缀的相等的最大长度next 

- 例子：

  abbabbk

  处于k时，在k之前的前缀和后缀，不能取到整体

  | 缀数 |  1   | 2    | 3       | 4    | 5     |
  | ---- | :--: | ---- | ------- | ---- | ----- |
  | 前缀 |  a   | ab   | **abb** | abba | abbab |
  | 后缀 |  b   | bb   | **abb** | babb | bbabb |

  所以k的答案是3

  0位置规定为-1,1位置因为不能取整体是0

- KMP整体算法逻辑

  ![](appendix\KMP1.jpg)

  证明蓝色字的第二点：

  ![](appendix\KMP2.jpg)

  整体走一个例子：

  ![](appendix\KMP3.jpg)

  ![](appendix\KMP7.jpg)

  时间复杂度分析：

  ![](appendix\KMP4.jpg)

- 如何求next数组

  ![](appendix\KMP5.jpg)

  时间复杂度及代码细节：

  ![](appendix\KMP6.jpg)

- 代码

  
