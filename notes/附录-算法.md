# 算法

## KMP

求子串在父串的位置。

### 暴力解法(O(M*N))

```java
    public int strStr(String haystack, String needle) {
        if(needle.isEmpty()) return 0;
        int len1 = haystack.length(),len2 = needle.length();
        char[] h= haystack.toCharArray(), n = needle.toCharArray();

        //开始循环
        for(int i = 0;i <= len1-len2;i++){
            int a = i, b =0;
            while(b < len2 && h[a]==n[b]){
                a++;
                b++;
            }
            if(b==len2) return i;
        }
        return -1;
    }
```



### KMP逻辑理解

根据**str2（子串）**，求最长前缀和后缀的相等的最大长度next 

- 例子：

  abbabbk

  处于k时，在k之前的前缀和后缀，不能取到整体

  | 缀数 |  1   | 2    | 3       | 4    | 5     |
  | ---- | :--: | ---- | ------- | ---- | ----- |
  | 前缀 |  a   | ab   | **abb** | abba | abbab |
  | 后缀 |  b   | bb   | **abb** | babb | bbabb |

  所以k的答案是3

  0位置规定为-1,1位置因为不能取整体是0

- KMP整体算法逻辑

  ![](appendix\KMP1.jpg)

  证明蓝色字的第二点：

  ![](appendix\KMP2.jpg)

  整体走一个例子：

  ![](appendix\KMP3.jpg)

  ![](appendix\KMP7.jpg)

  时间复杂度分析：

  ![](appendix\KMP4.jpg)

- 如何求next数组

  ![](appendix\KMP5.jpg)

  时间复杂度及代码细节：

  ![](appendix\KMP6.jpg)

- 代码

  ```java
      public int strStr(String haystack, String needle) {
          if(needle.isEmpty()) return 0;
  
          if (haystack == null ||  needle.length() < 1 || haystack.length() < needle.length()) {
              return -1;
          }
          
  
          char[] h = haystack.toCharArray(); //母串
          char[] n = needle.toCharArray(); //子串
  
          int x = 0; //母串下标
          int y = 0; //子串下标
          
          //O(N)
          int[] next = getNext(n);
          while(x < h.length && y < n.length){
              if(h[x] == n[y]){
                  x++;
                  y++;
              }else if(next[y]==-1){  //y = 0;
                  x++; 
              }else{
                  y = next[y];
              }
          }
  
          return y==n.length? x-y : -1;
  
      }
  
      //只和子串有关
      public int[] getNext(char[] n){
          if(n.length==1) return new int[]{-1};
  
          int[] next = new int[n.length];
          next[0] = -1;
          next[1] = 0;
          int index = 2;
          int cn = 0;  //当前需要比较的位置，同时也是值
          while(index < n.length){
              if(n[index-1] == n[cn]){   //注意此处是index-1,因为前一个就不包含他本身
                  next[index++] = ++cn;  //此处是++cn
              }else if(cn > 0){  //为什么没有等  cn=0的时候是-1
                  cn = next[cn];
              }else{
                  next[index++] = 0;  //没有前后缀是0
              }
          }
          
          return next;
      }
  ```
  
  
